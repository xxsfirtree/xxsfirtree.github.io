<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【笔记】数据结构（非ACM版） | firtree</title><meta name="author" content="firtree"><meta name="copyright" content="firtree"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="各类型数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="【笔记】数据结构（非ACM版）">
<meta property="og:url" content="http://example.com/post/79666db.html">
<meta property="og:site_name" content="firtree">
<meta property="og:description" content="各类型数据结构">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-05-30T04:41:32.000Z">
<meta property="article:modified_time" content="2023-06-09T03:44:33.310Z">
<meta property="article:author" content="firtree">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/tutu.jpg"><link rel="canonical" href="http://example.com/post/79666db"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【笔记】数据结构（非ACM版）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-09 11:44:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/toumingdu.css"><link rel="stylesheet" href="/css/beijingtu.css"><meta name="referrer" content="no-referrer"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/tutu.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">firtree</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【笔记】数据结构（非ACM版）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-30T04:41:32.000Z" title="发表于 2023-05-30 12:41:32">2023-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T03:44:33.310Z" title="更新于 2023-06-09 11:44:33">2023-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【笔记】数据结构（非ACM版）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><font size="3">

<meta name="referrer" content="no-referrer">

<p><strong>数据结构：</strong></p>
<p>数据结构是互相之间存在一种或多种特定关系的数据元素的集合。</p>
<p>根据数据元素之间关系的不同特性，通常分为四种逻辑结构：</p>
<p>1）集合</p>
<p>2）线性结构</p>
<p>3）树形结构</p>
<p>4）图状或网状结构</p>
<br>

<p><strong>算法和算法分析：</strong></p>
<p>算法的特性：有穷性，确定性，可行性，输入输出性</p>
<p>设计算法的要求：正确性，可读性，健壮性，高效性</p>
<br>

<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表就是具有相同特性的数据元素的一个有限序列，是最常用且最简单的一种数据结构。</p>
<p>线性表的逻辑结构特征：</p>
<p>（1）有限性：线性表中数据元素的个数是有穷的</p>
<p>（2）相同性：本章线性表中数据元素的类型是同一的</p>
<p>（3）顺序性：线性表中相邻的数据元素 $a_i$ 和ai之间存在<strong>序偶关系</strong> $(a_{i-1}, a_i)$，即 $a_{i-1}$ 是 $a_i$ 的前驱， $a_i$ 是 $a_{i-1}$ 的后继；$a_1$ 无前驱，$a_n$ 无后继，其它每个元素有且仅有一个前驱和一个后继</p>
<br>

<p>线性表的存储表示有两种，顺序存储和链表存储。</p>
<br>

<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。</p>
<p>一般来说，线性表的第i个数据元素 $a_i$ 的存储位置为：</p>
<p>$$LOC(a_i) &#x3D; LOC(a_1) + (i-1)*l$$</p>
<br>

<p><strong>顺序表的存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 10  <span class="comment">// 线性表存储空间的初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10   <span class="comment">// 线性表存储空间的分配增量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1               <span class="comment">// 成功</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0            <span class="comment">// 失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;  <span class="comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  <span class="comment">// ElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType* elem;</span><br><span class="line">    <span class="type">int</span> length;    <span class="comment">// 当前长度</span></span><br><span class="line">    <span class="type">int</span> listsize;  <span class="comment">// 当前的存储容量</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>顺序表的功能实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性表L的初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    L.elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!L.elem)    <span class="keyword">return</span> ERROR;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.listsize = LIST_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消除线性表</span></span><br><span class="line"><span class="function">Status <span class="title">DestoryList</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L.elem);  <span class="comment">// 释放空间</span></span><br><span class="line">    L.elem = <span class="literal">NULL</span>;</span><br><span class="line">    L.length = L.listsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得线性表的长度，记忆保存的元素的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(SqList&amp; L)</span> </span>&#123; <span class="keyword">return</span> L.length; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个线性表是否为空表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListEmpty</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用e返回L中第i个数据元素的值</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.elem[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找：在线性表中找到元素e在登记号位置上</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.elem[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 若未找到，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入：在L中的第i个位置之前插入新的数据元素e，L的长度加1</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= L.listsize) &#123;</span><br><span class="line">        <span class="comment">// 线性表已满</span></span><br><span class="line">        ElemType* newbase = (ElemType*)<span class="built_in">realloc</span>(</span><br><span class="line">            L.elem, (L.listsize + LISTINCREMENT) * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!newbase)   <span class="keyword">return</span> ERROR;</span><br><span class="line">        L.elem = newbase;</span><br><span class="line">        L.listsize += LISTINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> *p, *q;</span><br><span class="line">    q = &amp;(L.elem[i - <span class="number">1</span>]);  <span class="comment">// 插入位置</span></span><br><span class="line">    <span class="keyword">for</span> (p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; --p) &#123;</span><br><span class="line">        *(p + <span class="number">1</span>) = *p;</span><br><span class="line">    &#125;</span><br><span class="line">    *q = e;</span><br><span class="line">    ++L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除：删除L的第i个数据元素，并用e返回其值，L的长度减1</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)  <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="type">int</span> *p, *q;</span><br><span class="line">    p = &amp;L.elem[i - <span class="number">1</span>];</span><br><span class="line">    e = *p;</span><br><span class="line">    q = &amp;L.elem[L.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (++p; p &lt;= q; ++p) &#123;</span><br><span class="line">        *(p - <span class="number">1</span>) = *p;</span><br><span class="line">    &#125;</span><br><span class="line">    --L.length;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印线性表中的所有元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutPut</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, L.elem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在顺序存储结构的线性表中插入或删除一个数据元素，平均约移动表中一半元素。</p>
<p>时间复杂度约为 $O(n)$</p>
<br>

<p><strong>优点：</strong></p>
<p>存储密度大（结点本身所占存储量 &#x2F; 结点结构所占存储量）</p>
<p>可以随机存取表中任一元素</p>
<p><strong>缺点：</strong></p>
<p>在插入、删除某一元素时， 需要移动大量元素</p>
<p>浪费存储空间</p>
<p>属于静态存储形式， 数据元素的个数不能自由扩充</p>
<br>

<h2 id="链式表"><a href="#链式表" class="headerlink" title="链式表"></a>链式表</h2><p>链表是一种物理存储结构上非连续、非顺序的存储结构</p>
<p>数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p>
<br>

<p>结点：数据元素的存储映像。由数据域和指针域两部分组成</p>
<p>链表：n个结点由指针链组成一个链表</p>
<p>头指针：是指向链表中第一个结点的指针</p>
<p>头结点：要表示一个单链表时，只需声明一个头指针 L ，指向单链表的第一个结点</p>
<p>首元结点：是指链表中存储第一个数据元素的结点</p>
<br>

<p><strong>在链表中设置头结点有什么好处？</strong></p>
<p>（1）便于首元结点的处理</p>
<p>首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其它位置一致， 无须进行特殊处理</p>
<p>（2）便于空表和非空表的统一处理</p>
<p>无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了</p>
<br>

<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><strong>单链表的存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1               <span class="comment">// 成功</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0            <span class="comment">// 失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;  <span class="comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  <span class="comment">// ElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span>* next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>单链表的功能实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表的初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断单链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁单链表</span></span><br><span class="line"><span class="function">Status <span class="title">DestoryList</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="keyword">while</span> (L) &#123;</span><br><span class="line">        p = L;  L = L-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空单链表</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next, *q;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用e返回L中第i个数据元素的值</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i)    <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值查找，找到就返回其地址</span></span><br><span class="line"><span class="function">LNode* <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第i个位置前插入元素e</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode* p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>)    <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode* s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个元素，并由e返回其值</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode* p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;next || j &gt; i - <span class="number">1</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    LNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印线性表中的所有元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutPut</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法：数据是倒叙插入</span></span><br><span class="line">ElemType a[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    LNode* s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法：数据是正序插入</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    LNode *s, *r = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = b[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表的特点：</p>
<p>表中最后一个结点的指针域指向头指针，整个链表形成一个环</p>
<p>从表中任一结点出发都可以找到其他的结点</p>
<p>循环链表的操作与单链表基本一致，但由于循环链表中没有NULL指针</p>
<p>故涉及遍历操作时，其终止条件就不再像非循环链表那样判断 p 或 p-&gt;next 是否为空</p>
<p>而是判断它们是否等于头指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将两个带尾指针的循环链表合并</span></span><br><span class="line"><span class="function">LinkList <span class="title">Connect</span><span class="params">(LinkList Ta, LinkList Tb)</span> </span>&#123;</span><br><span class="line">    LNode* p = Ta-&gt;next;</span><br><span class="line">    Ta-&gt;next = Tb-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> Tb-&gt;next;</span><br><span class="line">    Tb-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> Tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>比单链表多一个 <strong>前驱指针prior</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DuLNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DuLNode</span> *next, *prior;</span><br><span class="line">&#125; DuLNode, *DuLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回L中第i个数据元素的地址</span></span><br><span class="line"><span class="function">DuLNode* <span class="title">GetElem</span><span class="params">(DuLinkList L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    DuLNode* p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第i个位置之前插入元素e</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(DuLinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    DuLNode *p, *s;</span><br><span class="line">    <span class="keyword">if</span> (!(p = <span class="built_in">GetElem</span>(L, i)))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (!(s = (DuLinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DuLNode))))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">    p-&gt;prior-&gt;next = s;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    p-&gt;prior = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(DuLinkList&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    DuLNode *p, *s;</span><br><span class="line">    <span class="keyword">if</span> (!(p = <span class="built_in">GetElem</span>(L, i)))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><p><strong>顺序存储和链式存储的各自特点和应用环境：</strong></p>
<p>（1）顺序存储</p>
<p>顺序存储结构的特点是逻辑上相邻的数据元素，物理存储位置也相邻，即地址连续</p>
<p>并且，顺序表的存储空间需要预先分配</p>
<p>适用于插入和删除操作较少的情况下</p>
<p>（2）链式存储</p>
<p>各个元素存储在任意的地址空间，逻辑相邻的元素在物理内存中没有联系</p>
<p>适用于需要频繁进行插入和删除操作的情况下</p>
<br>

<h3 id="有序表的合并"><a href="#有序表的合并" class="headerlink" title="有序表的合并"></a>有序表的合并</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">已知顺序线性表La和Lb的元素按值非递减排列</span></span><br><span class="line"><span class="comment">归并La和Lb得到新的顺序线性表Lc，Lc的元素也按值非递减排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">MergeList</span><span class="params">(SqList La, SqList Lb, SqList&amp; Lc)</span> </span>&#123;</span><br><span class="line">    ElemType *pa, *pb, *pc, *pa_last, *pb_last;</span><br><span class="line">    pa = La.elem, pa_last = pa + La.length - <span class="number">1</span>;</span><br><span class="line">    pb = Lb.elem, pb_last = pb + Lb.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    Lc.listsize = Lc.length = La.length + Lb.length;</span><br><span class="line">    pc = Lc.elem = (ElemType*)<span class="built_in">malloc</span>(Lc.listsize * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!pc)    <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pa &lt;= *pb) *pc++ = *pa++;</span><br><span class="line">        <span class="keyword">else</span>    *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pa &lt;= pa_last)   *pc++ = *pa++;</span><br><span class="line">    <span class="keyword">while</span> (pb &lt;= pb_last)   *pc++ = *pb++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个有序链表合并为一个有序链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList</span><span class="params">(LinkList&amp; La, LinkList&amp; Lb, LinkList&amp; Lc)</span> </span>&#123;</span><br><span class="line">    LNode *pa = La-&gt;next, *pb = Lb-&gt;next, *pc;</span><br><span class="line">    Lc = pc = La;</span><br><span class="line">    <span class="keyword">while</span> (pa &amp;&amp; pb) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;data &lt;= pb-&gt;data) &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = pa ? pa : pb;</span><br><span class="line">    <span class="built_in">free</span>(Lb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="一元多项式的加法"><a href="#一元多项式的加法" class="headerlink" title="一元多项式的加法"></a>一元多项式的加法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1     <span class="comment">// 成功</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0  <span class="comment">// 失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;  <span class="comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  <span class="comment">// ElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> coef;  <span class="comment">// 系数</span></span><br><span class="line">    <span class="type">int</span> expn;  <span class="comment">// 指数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PNode</span>* next;</span><br><span class="line">&#125; PNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插法：数据是正序插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(LinkList&amp; p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    p = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PNode));</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PNode* s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(PNode));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;s-&gt;coef, &amp;s-&gt;expn);</span><br><span class="line">        PNode *pre = p, *q = p-&gt;next;</span><br><span class="line">        <span class="comment">// 保证指数递增</span></span><br><span class="line">        <span class="keyword">while</span> (q &amp;&amp; q-&gt;expn &lt; s-&gt;expn) &#123;</span><br><span class="line">            pre = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;next = q;</span><br><span class="line">        pre-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutPut</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    PNode* p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d  **&quot;</span>, p-&gt;coef, p-&gt;expn);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(LinkList La, LinkList Lb, LinkList&amp; Lc)</span> </span>&#123;</span><br><span class="line">    PNode *pa = La-&gt;next, *pb = Lb-&gt;next, *pc, *r;</span><br><span class="line"></span><br><span class="line">    Lc = pc = La;</span><br><span class="line">    <span class="keyword">while</span> (pa &amp;&amp; pb) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;expn &lt; pb-&gt;expn) &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pa-&gt;expn &gt; pb-&gt;expn) &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> sum = pa-&gt;coef + pb-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                r = pa;</span><br><span class="line">                pa = pa-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(r);</span><br><span class="line">                r = pb;</span><br><span class="line">                pb = pb-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pa-&gt;coef = sum;</span><br><span class="line">                pc-&gt;next = pa;</span><br><span class="line">                pc = pa;</span><br><span class="line">                pa = pa-&gt;next;</span><br><span class="line">                r = pb;</span><br><span class="line">                pb = pb-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pc-&gt;next = pa ? pa : pb;</span><br><span class="line">    <span class="built_in">free</span>(pb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    LinkList La, Lb, Lc;</span><br><span class="line">    <span class="built_in">Create</span>(La, n);</span><br><span class="line">    <span class="built_in">Create</span>(Lb, m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Merge</span>(La, Lb, Lc);</span><br><span class="line">    <span class="built_in">OutPut</span>(Lc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">7 0</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">9 8</span></span><br><span class="line"><span class="comment">5 17</span></span><br><span class="line"><span class="comment">8 1</span></span><br><span class="line"><span class="comment">22 7</span></span><br><span class="line"><span class="comment">-9 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>栈和队列都是线性表的一种特殊情况</p>
<p>栈： 是只允许在一端进行插入或删除操作的线性表</p>
<p>队列：是只允许在一端进行插入，在另一端删除的线性表</p>
<be>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>“先入后出”（FILO）原则</p>
<p>最先放入栈中元素在栈底，最后放入的元素在栈顶</p>
<p>而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p>
<br>

<p><strong>卡特兰数</strong></p>
<p>$n$ 个不同的元素进站，出栈元素不同排列的个数有 $\frac{1}{n+1}C_{2n}^n$ 个</p>
<p>和线性表相似，栈也有两种存储表示方式，顺序栈更加常见</p>
<br>

<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 10  <span class="comment">// 存储空间的初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10   <span class="comment">// 存储空间的分配增量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1                <span class="comment">// 成功</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0             <span class="comment">// 失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;  <span class="comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;  <span class="comment">// SElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    SElemType* base;</span><br><span class="line">    SElemType* top;</span><br><span class="line">    <span class="type">int</span> stacksize;  <span class="comment">// 当前的存储容量</span></span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base == top 表示栈空</span></span><br><span class="line"><span class="comment">// top - base == stacksize 表示栈满</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈的初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span> </span>&#123;</span><br><span class="line">    S.base = (SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空栈</span></span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack&amp; S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base) S.top = S.base;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁栈</span></span><br><span class="line"><span class="function">Status <span class="title">DextoryStack</span><span class="params">(SqStack&amp; S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base) &#123;</span><br><span class="line">        <span class="keyword">delete</span> S.base;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        S.base = S.top = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用e返回栈顶元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack&amp; S, SElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(S.top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新的元素</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack&amp; S, SElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base == S.stacksize) &#123;</span><br><span class="line">        <span class="comment">// 栈满，追加空间</span></span><br><span class="line">        S.base = (SElemType*)<span class="built_in">realloc</span>(</span><br><span class="line">            S.base, (S.stacksize + STACKINCREMENT) * <span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">        S.top = S.base + S.stacksize;</span><br><span class="line">        S.stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出栈顶元素</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack&amp; S, SElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *(--S.top);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>链表的头指针就是栈顶</p>
<p>不需要头结点</p>
<p>基本不存在栈满的情况</p>
<p>空栈相当于头指针指向NULL</p>
<p>插入和删除仅在栈顶处进行</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230531111630648.png" alt="image-20230531111630648"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1                <span class="comment">// 成功</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0             <span class="comment">// 失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;  <span class="comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;  <span class="comment">// SElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StackNode</span>* next;</span><br><span class="line">&#125; StackNode, *LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(LinkStack&amp; S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack&amp; S, SElemType e)</span> </span>&#123;</span><br><span class="line">    StackNode* p = (StackNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack&amp; S, SElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    StackNode* p = S;</span><br><span class="line">    S = S-&gt;next;</span><br><span class="line">    <span class="built_in">delete</span> (p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取栈顶元素</span></span><br><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack&amp; S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S) <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>“先进先出”（FIFO）原则</p>
<p>是一种特殊的线性结构，它只允许在队列的首部进行删除操作，即“出队”</p>
<p>在队列的尾部进行插入操作，即“入队”</p>
<br>

<p>同样的，栈也有两种存储表示方式，循环顺序队列更加常见</p>
<br>

<h3 id="循环顺序队列"><a href="#循环顺序队列" class="headerlink" title="循环顺序队列"></a>循环顺序队列</h3><p>用模运算将存储空间在逻辑上变成了 <strong>“环状”</strong> ，牺牲一个单元来区分队满和队空</p>
<p>(Q.rear + 1) % MAXQSIZE &#x3D;&#x3D; Q.front 表示队满</p>
<p>Q.rear &#x3D;&#x3D; Q.front  表示队空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100  <span class="comment">// 最大队列长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1          <span class="comment">// 成功</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0       <span class="comment">// 失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;  <span class="comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;  <span class="comment">// QElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line">    QElemType* base;</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue&amp; Q)</span> </span>&#123;</span><br><span class="line">    Q.base = (QElemType*)<span class="built_in">malloc</span>(MAXQSIZE * <span class="built_in">sizeof</span>(QElemType));</span><br><span class="line">    <span class="keyword">if</span> (!Q.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求队列中的元素个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue&amp; Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue&amp; Q, QElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MAXQSIZE == Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取队头元素</span></span><br><span class="line"><span class="function">QElemType <span class="title">GetHead</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front != Q.rear)  <span class="keyword">return</span> Q.base[Q.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p>当无法估计所用队列的长度时，宜采用链队列</p>
<p>与链栈不同，链队列有头结点</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230531152133237.png" alt="image-20230531152133237"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1     <span class="comment">// 成功</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0  <span class="comment">// 失败</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;  <span class="comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;  <span class="comment">// QElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span>* next;</span><br><span class="line">&#125; QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span> </span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (!Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="function">Status <span class="title">DestoryQueue</span><span class="params">(LinkQueue&amp; Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q.front) &#123;</span><br><span class="line">        QueuePtr p = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, QElemType e)</span> </span>&#123;</span><br><span class="line">    QueuePtr p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p-&gt;data = e; p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, QElemType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    QueuePtr p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取队头元素</span></span><br><span class="line"><span class="function">QElemType <span class="title">GetHead</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front != Q.rear) <span class="keyword">return</span> (Q.front-&gt;next-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p><strong>表达式的组成：</strong></p>
<p>操作数；常数、变量</p>
<p>运算符：算术运算符、关系运算符和逻辑运算符</p>
<p>界限符：左右括弧和表达式结束符</p>
<p>任何一个算术表达式都由操作数、算术运算符和界限符组成</p>
<p>后两者统称为算符</p>
<p>例如：# 3 * ( 7 - 2 ) #</p>
<br>
为了实现表达式求值。需要设置两个栈

<p>一个是算符栈 OPTR，用于寄存运算符</p>
<p>另一个称为操作数栈 QPND，用于寄存运算数和运算结果</p>
<p><strong>求值的处理过程：</strong></p>
<p>是自左至右扫描表达式的每一个字符</p>
<ul>
<li><p>当扫描到的是运算数，则将其压入栈OPND</p>
</li>
<li><p>当扫描到的是运算符时</p>
<ul>
<li>若这个运算符比OPTR栈顶运算符的优先级高，则入栈OPTR，继续向后处理</li>
<li>若这个运算符比OPTR栈顶运算符优先级低，则从OPND栈中弹出两个运算数，从OPTR中弹出栈顶运算符进行运算，并将运算结果压入栈OPND</li>
</ul>
</li>
<li><p>继续处理当前字符，直到遇到结束符为止。</p>
</li>
</ul>
<br>

<h1 id="串-数组和广义表"><a href="#串、数组和广义表" class="headerlink" title="串、数组和广义表"></a>串、数组和广义表</h1><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>即字符串，是由零个或多个字符组成的有限序列。一般记为</p>
<p>$$s&#x3D;’a_1a_2…a_n’$$</p>
<p>子串：一个串中任意个连续字符组成的子序列（含空串）</p>
<br>

<h3 id="模式串匹配-bf"><a href="#模式串匹配-BF" class="headerlink" title="模式串匹配 - BF"></a>模式串匹配 - BF</h3><p>就是暴力</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch[MAXLEN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length; </span><br><span class="line">&#125; SString;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子串T在主串S的第pos个字符后出现的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_BF</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] == T.ch[j]) i++, j++;</span><br><span class="line">        <span class="keyword">else</span> i = i - j + <span class="number">2</span>, j = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="模式串匹配-kmp"><a href="#模式串匹配-KMP" class="headerlink" title="模式串匹配 - KMP"></a>模式串匹配 - KMP</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s, t;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;  <span class="comment">// 下标从1开始</span></span><br><span class="line">    n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>(), s = <span class="string">&quot; &quot;</span> + s, t = <span class="string">&quot; &quot;</span> + t;</span><br><span class="line"></span><br><span class="line">    nx[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        nx[i] = nx[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (nx[i] &amp;&amp; t[i] != t[nx[i] + <span class="number">1</span>])   nx[i] = nx[nx[i]];</span><br><span class="line">        nx[i] += (t[i] == t[nx[i] + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (re <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n;) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">1</span> &amp;&amp; s[i] != t[j])  j = nx[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j])   i++, j++;</span><br><span class="line">        <span class="keyword">else</span>    i++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (j == m + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, i - m);</span><br><span class="line">            j = nx[m] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>设数组开始存储位置为 $$LOC(0,0)$$，存储每个元素需要 L 个存储单元</p>
<p>则数组元素 $a[i][j]$ 的存储位置为：</p>
<p>$$LOC(i,j)&#x3D;LOC(0,0)+(n*i+j)*L$$</p>
<br>

<p><strong>n维数组</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/B5FB0C24CFAF46274BBED7700E72FDAA.jpg" alt="img"></p>
<br>

<h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>（1）广义表中的数据元素有相对次序：一个直接前驱和一个直接后继</p>
<p>（2）广义表的长度定义为最外层所包含元素的个数：</p>
<p>如：C &#x3D; (a, ( b, d ) ) 是长度为 2 的广义表</p>
<p>（3）广义表的深度定义为该广义表展开后所含括号的重数：</p>
<p>A &#x3D; ( b, d ) 的深度为 1，B &#x3D; ( A, d ) 的深度为 2，C &#x3D; ( f, B, h ) 的深度为 3</p>
<p>PS：“原子” 的深度为 0;  “空表” 的深度为 1</p>
<p>（4）表头和表尾：非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</p>
<br>

<ul>
<li>对任意一个非空的广义表，其表头可能是单元素，也可能是广义表</li>
<li>对任意一个非空的广义表，其表尾一定是广义表</li>
<li>表尾是由除了表头以外的其余元素组成的广义表，所以，需要在表尾的直接元素外面再加一层括号</li>
</ul>
<br>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><strong>树的属性：</strong></p>
<ul>
<li><strong>结点的度</strong>（Degree）：结点的子树个数</li>
<li><strong>树的度</strong>：树的所有结点中最大的度数</li>
<li><strong>叶子结点</strong>（Leaf）：度为 0 的结点，也叫<strong>终端结点</strong></li>
<li><strong>结点的层次</strong>（Level）：规定根结点在1层，其他任一结点的层数是其父结点的层数加1</li>
<li><strong>树的深度</strong>（Depth）：树中所有结点中的最大层次</li>
</ul>
<br>

<p><strong>树的性质：</strong></p>
<ol>
<li>树中的结点数 &#x3D; 总度数 + 1</li>
<li>度为 m 的树第 i 层 至多 有 $m^{i − 1}$ 个结点</li>
<li>具有 n 个结点的 m 叉树的最小高度为 $log_m(n(m-1)+1)$</li>
</ol>
<br>

<p><strong>度为m的树、m叉树的区别</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230602094721628.png" alt="image-20230602094721628"></p>
<br>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li><p>第 i 层最多有 $2^{i-1}$ 个结点</p>
</li>
<li><p>高度为 h 的二叉树至多有 $2^h-1$ 个结点</p>
</li>
<li><p>对任何一课二叉树 T，如果其叶子结点数为 $n_0$，度为 2 的结点数为 $n_2$，则</p>
<ul>
<li>$n_0&#x3D;n_2+1$</li>
</ul>
</li>
<li><p>具有 n 个结点的完全二叉树的深度为 $\lfloor{log_2n}\rfloor+1$</p>
</li>
<li><p>如果对一棵有 n 个结点的完全二叉树的结点按层序编号，则对任一结点 i</p>
<ul>
<li>如果 i &#x3D; 1，则结点 i 是二叉树的根；如果 i &gt; 1，则其双亲是结点$\lfloor{i&#x2F;2}\rfloor$</li>
<li>如果 2i &gt; n，则结点 i 无左孩子；否则其左孩子是 2i</li>
<li>如果 2i + 1 &gt; n，则结点之无右孩子；否则其右孩子是 2i + 1</li>
</ul>
</li>
</ul>
<br>

<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>（1）顺序存储</p>
<p>这种顺序存储方式仅仅适用于完全二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100  <span class="comment">// 二叉树的最大结点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>

<br>

<p>（2）链式存储结构</p>
<p>在n个结点的二叉链表中，有 $n+1$ 个空指针域</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lChild, *rChild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历，包括先序遍历、中序遍历、后序遍历和层序遍历</p>
<br>

<p>由二叉树的先序序列和中序序列，或后序序列和中序序列可以确定唯一一棵二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1     <span class="comment">// 鎴愬姛</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0  <span class="comment">// 澶辫触</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lChild, *rChild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(BiTree &amp;T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBiTNode</span><span class="params">(BiTree &amp;T)</span> </span>&#123;</span><br><span class="line">    T = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    TElemType e;</span><br><span class="line">    std::cin &gt;&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="number">-1</span>) T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;data = e;</span><br><span class="line">        T-&gt;lChild = <span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;rChild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;请输入&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的左儿子值（-1代表无左儿子）：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">CreateBiTNode</span>(T-&gt;lChild);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;请输入&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的右儿子值（-1代表无右儿子）：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">CreateBiTNode</span>(T-&gt;rChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)  <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T-&gt;lChild);</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;lChild);</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T-&gt;lChild);</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T-&gt;rChild);</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    queue&lt;BiTNode*&gt; tree;</span><br><span class="line">    tree.<span class="built_in">push</span>(T);</span><br><span class="line">    <span class="keyword">while</span> (!tree.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        BiTNode* p = tree.<span class="built_in">front</span>();</span><br><span class="line">        tree.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tree.<span class="built_in">push</span>(p-&gt;lChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tree.<span class="built_in">push</span>(p-&gt;rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>利用二叉链表中的空指针域：</p>
<p>如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱</p>
<p>如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继</p>
<p>这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树</p>
<p>对二叉树按某种遍历次序使其变为线索二叉树的过程叫线索化</p>
<br>

<p>LTag： 若 LTag&#x3D;0，lchild域指向左孩子；</p>
<p>若 LTag&#x3D;1，lchild域指向其前驱。</p>
<p>RTag： 若 RTag&#x3D;0，rchild域指向右孩子；</p>
<p>若 RTag&#x3D;1，rchild域指向其后继。</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607092648463.png" alt="image-20230607092648463"></p>
<br>

<h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><p>（1）双亲表示法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTNode</span> &#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125; PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> root, n;    <span class="comment">// 根节点的位置和结点个数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>

<br>

<p>（2）孩子链表法</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605095002276.png" alt="image-20230605095002276"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 孩子结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双亲结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125; CTbox;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    CTbox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> root, n;</span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure>

<br>

<p>（3）孩子兄弟表示法</p>
<p>用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一 个兄弟结点</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605095929179.png" alt="image-20230605095929179"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span> &#123;</span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstchild, *nextsibling;</span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="与二叉树的相互转换"><a href="#与二叉树的相互转换" class="headerlink" title="与二叉树的相互转换"></a>与二叉树的相互转换</h3><p><strong>将树转换成二叉树</strong></p>
<p>①加线：在兄弟之间加一连线</p>
<p>②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p>
<p>③旋转：以树的根结点为轴心，将整树顺时针转45°</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/C687CE919D2723C53A440A1BA7BA80C0.jpg" alt="img"></p>
<br>

<p><strong>将二叉树转换成树</strong></p>
<p>①加线：若p结点是双亲结点的左孩子，则将p沿分支找到的所有右孩子，都与p的双亲用线连起来</p>
<p>②抹线：抹掉原二叉树中双亲与右孩子之间的连线</p>
<p>③调整：将结点按层次排列，形成树结构</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/73E2D00D2B89E716C9C6DC0CE63E0765.jpg" alt="img"></p>
<br>

<p><strong>将森林转换成二叉树</strong></p>
<p>先把每棵树变成二叉树</p>
<p>再把各个根结点相连，再旋转</p>
<br>

<p><strong>将二叉树转换成森林</strong></p>
<p>将二叉树中根结点与其沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树</p>
<p>再将孤立的二叉树还原成树</p>
<br>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605101754867.png" alt="image-20230605101754867"></p>
<br>

<p><strong>2. 森林的遍历</strong></p>
<p>（1）先序遍历</p>
<p>依次从左到右对森林中的每一棵树进行先根遍历</p>
<p>（2）中序遍历</p>
<p>依次从左到右对森林中的每一棵树进行后根遍历</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605102220269.png" alt="image-20230605102220269"></p>
<br>

<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>树的路径长度：从树根到每一个结点的路径长度之和</p>
<p>结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积</p>
<p>树的带权路径长度：树中所有叶子结点的带权路径长度之和</p>
<br>

<p>哈夫曼树：最优树，就是带权路径长度(WPL)最短的树</p>
<p>PS：”带权路径长度最短”是在度相同的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等</p>
<br>

<p><strong>哈夫曼算法：</strong></p>
<p>（1）根据 n 个给定的权值构成 n 棵二叉树的森林</p>
<p>（2）在森林中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和</p>
<p>（3）在森林中删除这两棵树，同时将新得到的二叉树加入森林中</p>
<p>（4）重复（2）（3）直到森林中只剩下一棵树</p>
<p>PS：哈夫曼树中共有 $2n-1$ 个结点，且其所有的分支结点的度均不为 1</p>
<br>

<p><strong>哈夫曼编码：</strong></p>
<ol>
<li>统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）</li>
<li>利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短</li>
<li>在哈夫曼树的每个分支上标上0或1 ：<ul>
<li>结点的左分支标0，右分支标1</li>
<li>把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码</li>
</ul>
</li>
</ol>
<br>

<p><strong>为什么哈夫曼编码能够保证是前缀编码?</strong></p>
<p>因为没有一片树叶是另一片树叶的祖先， 所以每个叶结点的编码就不可能是其它叶结点编码的前缀</p>
<p><strong>为什么哈夫曼编码能够保证字符编码总长最短?</strong></p>
<p>因为哈夫曼树的带权路径长度最短，故字符编码的总长最短</p>
<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>** HuffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> parent, lch, rch;</span><br><span class="line">&#125; HTNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在HT[1...idx]选择 parent为0 且 weight最小的两个结点，序号为s1, s2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(HuffmanTree&amp; HT, <span class="type">int</span> idx, <span class="type">int</span>&amp; s1, <span class="type">int</span>&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> min1 = INT_MAX, min2 = INT_MAX;</span><br><span class="line">    s1 = s2 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent)   <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HT[i].weight &lt;= min1) &#123;</span><br><span class="line">            min2 = min1, min1 = HT[i].weight;</span><br><span class="line">            s2 = s1, s1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (HT[i].weight &lt;= min2) &#123;</span><br><span class="line">            min2 = HT[i].weight;</span><br><span class="line">            s2 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造哈夫曼树和哈夫曼编码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatHuffmanTree</span><span class="params">(HuffmanTree&amp; HT, HuffmanCode HC, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">    HT = (HTNode*)<span class="built_in">malloc</span>((m + <span class="number">1</span>) * <span class="built_in">sizeof</span>(HTNode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        HT[i].lch = HT[i].rch = HT[i].parent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; HT[i].parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s1, s2;</span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);</span><br><span class="line">        HT[s1].parent = HT[s2].parent = i;</span><br><span class="line">        HT[i].lch = s1, HT[i].rch = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从叶子到根逆向求每个字符的哈夫曼编码</span></span><br><span class="line">    HC = (HuffmanCode)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="type">char</span>* cd = (<span class="type">char</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = i, f = HT[i].parent; f; c = f, f = HT[f].parent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[f].lch == c) cd[--start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cd[--start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HC[i] = (<span class="type">char</span>*)<span class="built_in">malloc</span>((n - start) * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图的逻辑结构：多对多</p>
<p><strong>连通、连通图和连通分量：</strong></p>
<p>在无向图中，若从顶点v 到顶点w 有路径存在，则称v 和w 是连通的。</p>
<p>若图G 中任意两个顶点都是连通的，则称图G 为连通图，否则称为非连通图。</p>
<p>无向图中的极大连通子图称为连通分量</p>
<p><strong>强连通图、强连通分量：</strong></p>
<p>在有向图中，若从顶点v 到顶点w 和从顶点w 到项点v 之间都有路径，则称这两个顶点是强连通的</p>
<p>若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量</p>
<br>

<h2 id="存图"><a href="#存图" class="headerlink" title="存图"></a>存图</h2><p>主要有<strong>邻接矩阵</strong>和<strong>邻接表</strong>两种存储结构</p>
<p><strong>邻接矩阵多用于稠密图，邻接表多用于稀疏图</strong></p>
<br>

<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p><strong>无向图：</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605153253588.png" alt="image-20230605153253588"></p>
<ol>
<li>无向图的邻接矩阵一定是一个对称矩阵。因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素</li>
<li>对于无向图，邻接矩阵的第i 行（或第 i 列）中非零元素的个数正好是第 i 个顶点的度</li>
<li>求顶点 $v_i$ 的所有邻接点就是将矩阵中第 i 行元素扫描一遍，$ A[i][j]&#x3D;1$ 就是邻接点</li>
</ol>
<br>

<p><strong>有向图：</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605153229053.png" alt="image-20230605153229053"></p>
<ol>
<li>主对角线上数值依然为0。但因为是有向图，所以此矩阵并不对称</li>
<li>有向图中，顶点 $v_i$ 的入度为是第 $v_i$ 列各数之和。出度为第 $v_i$ 行的各数之和</li>
</ol>
<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20  <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF INT_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;  <span class="comment">// 顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;      <span class="comment">// 边的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcCell</span> &#123;</span><br><span class="line">&#125; ArcCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    VerTexType vexs[MAX_VERTEX_NUM];               <span class="comment">// 顶点表</span></span><br><span class="line">    ArcType arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];  <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;  <span class="comment">// 图当前的点数和边数</span></span><br><span class="line">&#125; MGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到顶点对应的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex</span><span class="params">(MGraph &amp;G, <span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.vexs[i] == x) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(MGraph&amp; G)</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入点的信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">        std::cin &gt;&gt; G.vexs[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.arcnum; j++)</span><br><span class="line">            G.arcs[i][j] = INF;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存边</span></span><br><span class="line">    <span class="type">char</span> v1, v2;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.arcnum; k++) &#123;</span><br><span class="line">        std::cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">LocateVex</span>(G, v2);</span><br><span class="line">        G.arcs[i][j] = w;</span><br><span class="line">        G.arcs[j][i] = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p><strong>无向图：</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605164940709.png" alt="image-20230605164940709"></p>
<p><strong>有向图：</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605165021980.png" alt="image-20230605165021980"></p>
<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20  <span class="comment">// 最大顶点个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF INT_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> VerTexType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span>* nextarc;</span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">    VerTexType data;</span><br><span class="line">    ArcNode* firstarc;</span><br><span class="line">&#125; VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;  <span class="comment">// 当前的顶点数和边数</span></span><br><span class="line">&#125; ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到顶点对应的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex</span><span class="params">(ALGraph&amp; G, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.vertices-&gt;data == x)  <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateUDG</span><span class="params">(ALGraph&amp; G)</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; G.vertices[i].data;</span><br><span class="line">        G.vertices[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.arcnum; k++) &#123;</span><br><span class="line">        std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">LocateVex</span>(G, v2);</span><br><span class="line">        ArcNode *p1 = (ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">        p1-&gt;adjvex = j;</span><br><span class="line">        <span class="comment">// 头插法 v1-&gt;v2</span></span><br><span class="line">        p1-&gt;nextarc = G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc = p1;</span><br><span class="line">        <span class="comment">// 无向图 v2-&gt;v1（有向图则不需要）</span></span><br><span class="line">        ArcNode *p2 = (ArcNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ArcNode));</span><br><span class="line">        p1-&gt;adjvex = i;</span><br><span class="line">        p2-&gt;nextarc = G.vertices[j].firstarc;</span><br><span class="line">        G.vertices[j].firstarc = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p><strong>十字链表是有向图的一种链式存储结构</strong></p>
<p>对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。</p>
<p>十字链表就把邻接表与逆邻接表结合了起来</p>
<br>

<p><strong>我们重新定义顶点表结点结构：</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605175600623.png" alt="image-20230605175600623"></p>
<p>其中firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout 表示出边表头指针，指向该顶点的出边表中的第一个结点。</p>
<p><strong>重新定义的边表结点结构：</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605175644659.png" alt="image-20230605175644659"></p>
<p>其中 tailvex 是指弧起点在顶点表的下标，headvex 是指弧终点在顶点表中的下标</p>
<p>headlink是指入边表指针域，指向终点相同的下一条边</p>
<p>taillink是指边表指针域，指向起点相同的下一条边</p>
<br>

<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/E1EB73315703F3AEB1178048935994D9.jpg" alt="img"></p>
<br>

<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p><strong>邻接多重表是无向图的另一种链式存储结构。</strong></p>
<p>在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低</p>
<br>

<p><strong>重新定义的边表结点结构：</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605180134589.png" alt="image-20230605180134589"></p>
<p>其中 ivex 和 jvex 是与某条边依附的两个顶点在顶点表中下标</p>
<p>ilink 指向依附顶点 ivex 的下一条边，jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构</p>
<p><strong>每个顶点也用一一个结点表示，它由如下所示的两个域组成</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605180230425.png" alt="image-20230605180230425"></p>
<p>其中，data 域存储该顶点的相关信息，firstedge 域指示第一条依附于该顶点的边</p>
<br>

<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605180807904.png" alt="image-20230605180807904"></p>
<br>

<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>对于图的遍历来，通常有两种遍历次序方案：<strong>深度优先遍历</strong>和<strong>广度优先遍历</strong></p>
<br>

<p>（1）邻接矩阵存图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    VerTexType vexs[MAX_VERTEX_NUM];</span><br><span class="line">    ArcType arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125; MGraph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(MGraph&amp; G, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G.arcs[u][v] &amp;&amp; (!visited[v]))</span><br><span class="line">            <span class="built_in">DFS</span>(G, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>（2）邻接表存图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span>* nextarc;</span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">    VerTexType data;</span><br><span class="line">    ArcNode* firstarc;</span><br><span class="line">&#125; VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;  <span class="comment">// 当前的顶点数和边数</span></span><br><span class="line">&#125; ALGraph;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表进行DFS</span></span><br><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(ALGraph&amp; G, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[u])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ArcNode* tmp = G.vertices[u].firstarc;</span><br><span class="line">    <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">        <span class="type">int</span> v = tmp-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v])</span><br><span class="line">            <span class="built_in">DFS</span>(G, u);</span><br><span class="line">        tmp = tmp-&gt;nextarc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表进行BFS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(ALGraph&amp; G, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q[<span class="number">100</span>], h = <span class="number">0</span>, t = <span class="number">-1</span>;</span><br><span class="line">    q[++t] = u; visited[u] = <span class="literal">true</span>;</span><br><span class="line">    std::cout &lt;&lt; u &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &lt;= t) &#123;</span><br><span class="line">        <span class="type">int</span> now = q[h++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ArcNode* tmp = G.vertices[now].firstarc; tmp; tmp = tmp-&gt;nextarc) &#123;</span><br><span class="line">            <span class="type">int</span> v = tmp-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                std::cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">                visited[v] = <span class="literal">true</span>;</span><br><span class="line">                q[++t] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的 n − 1 条边</p>
<p>若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路</p>
<p>其中边的权值之和最小的那棵生成树，称为<strong>最小生成树</strong></p>
<br>

<p><strong>最小生成树算法主要有 Prim 算法和 Kruskal 算法</strong></p>
<br>

<p><strong>Prim</strong></p>
<p>从一个顶点出发，在保证不形成回路的前提下，每找到并添加一条最短的边，就把当前形成的连通分量当做一个整体或者一个点看待，然后重复“找最短的边并添加”的操作。</p>
<br>

<p><strong>Kruskal</strong></p>
<p>初始时为只有 n 个顶点而无边的非连通图 T，每个顶点自成一个连通分量</p>
<p>然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边</p>
<p>若该边依附的顶点落在T中不同的连通分量上，则将此边加入 T</p>
<p>否则舍弃此边而选择下一条权值最小的边</p>
<p>以此类推，直至 T 中所有顶点都在一个连通分量上。</p>
<br>

<p>prim算法的时间复杂度$O(n^2)$，Kruskal算法的时间复杂度$O(mlogm)$</p>
<br>

<h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p>
<p>单源最短路 – Dijkstra</p>
<p>多源最短路 – Floyd</p>
<br>

<h2 id="有向无环图及其应用"><a href="#有向无环图及其应用" class="headerlink" title="有向无环图及其应用"></a>有向无环图及其应用</h2><p>有向无环图：边有方向、图中无环</p>
<br>

<p>用一个有向图表示一个工程的各子工程及其相互制约的关系</p>
<p>其中以顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网</p>
<p>简称 AOV 网（Activity On Vertex）</p>
<p><strong>应用：拓扑排序</strong></p>
<br>

<p>用一个有向图表示一个工程的各子工程及其相互制约的关系</p>
<p>以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网</p>
<p>简称为 AOE 网（Activity On Edge）</p>
<p>AOE网具有以下两个性质：</p>
<ul>
<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li>
<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生</li>
</ul>
<p><strong>应用：关键路径</strong></p>
<br>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>每个 AOV 网都有一个或多个拓扑排序序列</p>
<p><strong>构造拓扑排序：</strong></p>
<p>。在有向图中选一个没有前驱的顶点且输出</p>
<p>。从图中删除该顶点和所有以它为尾的弧</p>
<p>。重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点</p>
<br>

<p>我们可以通过拓扑排序来检测 AOV 网中是否存在环：</p>
<p>对有向图构造其顶点的拓扑序列，若网中所有顶点都在它的拓扑序列中，则该 AOV 网无环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> indegree[MAX_VERTEX_NUM];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(ALGraph G)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化栈，存储入度为0的顶点</span></span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) <span class="built_in">Push</span>(S, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(S)) &#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (ArcNode* p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) &#123;</span><br><span class="line">            <span class="type">int</span> v = p-&gt;adjvex;</span><br><span class="line">            <span class="comment">// 入度为0，则入栈</span></span><br><span class="line">            <span class="keyword">if</span> (!--indegree[v]) <span class="built_in">Push</span>(S, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出顶点少了，有向图中有环，排序失败</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; G.vexnum) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 拓扑排序成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>关键路径 —— 路径长度最长的路径</p>
<p>路径长度 —— 路径上各活动持续时间之和</p>
<br>

<p>ve(vj) —— 表示事件 vj 的最早发生时间</p>
<p>vl(vj) —— 表示事件 vj 的最迟发生时间</p>
<p>e(i) —— 表示活动 ai 的最早开始时间</p>
<p>l(i) —— 表示活动 ai 的最迟开始时间</p>
<p>那么，l(i) - e(i) —— 表示完成活动 ai 的时间余量</p>
<p>时间余量为零的活动称为关键活动（一定在关键路径上）</p>
<br>

<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/C3984E6DACA7E5DE073BF00655DEB6F2.jpg" alt="img"></p>
<br>

<p><strong>求解关键路径：</strong></p>
<p>从源点出发，令 ve (源点) &#x3D; 0，按拓扑排序求其余顶点的最早发生时间 ve( )</p>
<p>从汇点出发，令 vl (汇点) &#x3D; v，按逆拓扑排序求其余顶点的最迟发生时间 vl( )</p>
<p>根据各顶点的 ve() 值求所有弧的最早开始时间 e()</p>
<p>根据各顶点的 vl() 值求所有弧的最迟开始时间 l()</p>
<p>求 AOE 网中所有活动的时间余量，为零的活动构成关键路径</p>
<br>

<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找表是由同一类型的数据元素（或记录）构成的集合</p>
<p>由于”集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构</p>
<br>

<p>关键字：用来标识一个数据元素（或记录）的某个数据项的值</p>
<ul>
<li>主关键字：可唯一地标识一个记录的关键字</li>
<li>次关键字：用以识别若干记录的关键字</li>
</ul>
<br>

<p>查找算法的评价指标：关键字的平均比较次数，也称平均查找长度（ASL）</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230606182536166.png" alt="image-20230606182536166"></p>
<br>

<h2 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h2><p><strong>查找表的存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;  <span class="comment">// 关键字域</span></span><br><span class="line">&#125; ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType* R;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; SSTable;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>（1）顺序查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable&amp; ST, KeyType key)</span> </span>&#123;</span><br><span class="line">    ST.R[<span class="number">0</span>].key = key;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = ST.length; ST.R[i].key != key; i--) ;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找第 i 个元素需要比较 n - i + 1 次，平均查找长度 $ASL&#x3D;(n+1)&#x2F;2$</p>
<p>时间复杂度 $O(n)$</p>
<br>

<p><strong>（2）折半查找（二分查找）</strong></p>
<p>只适用于有序表，且限于顺序存储结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Bin</span><span class="params">(SSTable&amp; ST, KeyType key)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">1</span>, high = ST.length;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (ST.R[mid].key == key) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; ST.R[mid].key) high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均查找长度 $ASL&#x3D;log_2{(n+1)}-1$</p>
<p>时间复杂度 $O(logn)$</p>
<br>

<p><strong>（3）分块查找</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/C4EEC47DC62CD50FD66C6342B284B7D4.jpg" alt="img"></p>
<br>

<h2 id="树表的查找"><a href="#树表的查找" class="headerlink" title="树表的查找"></a>树表的查找</h2><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a><strong>二叉排序树</strong></h3><p>二叉排序树或是空树，或是满足如下性质的二叉树：</p>
<ul>
<li>若其左子树非空，则左子树上所有结点的值均小于根结点的值</li>
<li>若其右子树非空，则右子树上所有结点的值均大于等于根结点的值</li>
<li>其左右子树本身又各是一棵二叉排序树</li>
</ul>
<br>

<p>中序遍历二叉排列树得到的是一个非递减序列</p>
<p><strong>二叉排序树的存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> InfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;         <span class="comment">// 关键字域</span></span><br><span class="line">    InfoType otherinfo;  <span class="comment">// 其他数据域</span></span><br><span class="line">&#125; ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line">    ElemType data;                    <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild, *rchild;  <span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125; BSTNode, *BSTree;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>查找（递归实现）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree&amp; T, KeyType key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!T) || key == T-&gt;data.key) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key) <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>含有 n 个结点的二叉排序树的平均查找长度和树的形态有关</p>
<p>最好情况下：$ASL&#x3D;log_2{n+ 1}-1$</p>
<p>最坏情况下退化为顺序查找：$ASL&#x3D;(n+1)&#x2F;2$</p>
<br>

<p><strong>插入</strong></p>
<ul>
<li>若二叉排序树为空，则插入结点作为根结点插入到空树中</li>
<li>否则，继续在其左、右子树上查找<ul>
<li>树中已有，不再插入</li>
<li>树中没有，查找直至某个叶子结点的左子树或右子树为空为止，则插入。结点应为该叶子结点的左孩子或右孩子</li>
</ul>
</li>
</ul>
<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在根指针T所指二叉排序树中递归地查找其关键字等于key的数据元素</span></span><br><span class="line"><span class="comment">若查找成功，则指针p指向该数据元素结点，并返回TRUE</span></span><br><span class="line"><span class="comment">否则指针p指向查找路径上访问的最后一个结点并返回FALSE</span></span><br><span class="line"><span class="comment">指针f指向T的双亲，其初始调用值为NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BSTree T, KeyType key, BSTree f, BSTree&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">        p = f;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;data.key == key) &#123;</span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key) <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild, key, T, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild, key, T, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BSTree&amp; T, ElemType e)</span> </span>&#123;</span><br><span class="line">    BSTree p;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SearchBST</span>(T, e.key, <span class="literal">NULL</span>, p)) &#123;</span><br><span class="line">        BSTNode* s = (BSTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">        s-&gt;data = e; s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p) T = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e.key &lt; p-&gt;data.key) p-&gt;lchild = s;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;rchild = s;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>删除</strong></p>
<p>（1）被删除的结点是叶子结点：直接删去该结点</p>
<p>（2）被删除的结点只有左子树或者只有右子树，直接用其左子树或者右子树替换它</p>
<p>（3）被删除的结点既有左子树，也有右子树</p>
<ul>
<li><p>以其中序前趋值替换之，然后再删除该前趋结点。前趋是左子树中最大的结点</p>
</li>
<li><p>也可以用其后继替换之，然后再删除该后继结点。后继是右子树中最小的结点</p>
</li>
</ul>
<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BSTree&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;rchild) &#123;</span><br><span class="line">        BSTree q = p;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;lchild) &#123;</span><br><span class="line">        BSTree q = p;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BSTree q = p, s = p-&gt;lchild;</span><br><span class="line">        <span class="comment">// 找到左子树中最大的结点</span></span><br><span class="line">        <span class="keyword">while</span> (s-&gt;rchild) &#123;</span><br><span class="line">            q = s; s = s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (q != p) q-&gt;rchild = s-&gt;lchild;  <span class="comment">// 重接 *q 的右子树</span></span><br><span class="line">        <span class="keyword">else</span> q-&gt;lchild = s-&gt;lchild;         <span class="comment">// 重接 *q 的左子树</span></span><br><span class="line">        <span class="built_in">free</span>(s); <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树（balanced binary tree），又称 AVL 树</p>
<p>一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：</p>
<ul>
<li>左子树与右子树的高度之差的绝对值小于等于 1</li>
<li>左子树和右子树也是平衡二叉排序树</li>
</ul>
<br>

<p>为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差</p>
<p>这个数字称为结点的平衡因子（BF）</p>
<p>平衡因子 &#x3D; 结点左子树的高度 - 结点右子树的高度</p>
<p>根据平衡二叉树的定义，平衡二叉树上所有结点的平衡因子只能是 -1、1 或 0</p>
<br>

<p><strong>失衡时的调整：</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/D41693E82076277C4BE64E23817787EE.jpg" alt="img"></p>
<br>

<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/7B2638ABFDCB5C810D588A90EC2920E0.jpg" alt="img"></p>
<p>实际上就是找出中间的那个数当作根节点，比它大的放在左边，比它小的放在右边</p>
<br>

<p><strong>LL型</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/95A506EA1A4EDBD4B3187C64C93FF5B8.jpg" alt="img"></p>
<br>

<p><strong>RR型</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/062942B8CDD296464F20B3D73145421E.jpg" alt="img"></p>
<br>

<p><strong>LR型</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607095745819.png" alt="image-20230607095745819"></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/B8049C249B744B468E89882F56814FB1.jpg" alt="img"></p>
<br>

<p><strong>RL型</strong></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607100339218.png" alt="image-20230607100339218"></p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/89611D4C92163372C6A08A7FAEF28418.jpg" alt="img"></p>
<br>

<h2 id="散列表的查找"><a href="#散列表的查找" class="headerlink" title="散列表的查找"></a>散列表的查找</h2><p>散列存储（哈希）：选取某个函数，依该函数按关键字计算元素的存储位置</p>
<p>冲突：不同的关键码映射到同一个散列地址</p>
<br>

<p><strong>构造好的散列函数：</strong></p>
<ul>
<li>所选函数尽可能简单，以便提高转换速度</li>
<li>所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费</li>
</ul>
<br>

<br>

<p><strong>构造散列函数考虑的因素：</strong></p>
<p>执行速度（即计算散列函数所需时间）</p>
<p>关键字的长度</p>
<p>散列表的大小</p>
<p>关键字的分布情况</p>
<p>查找频率</p>
<br>

<br>

<p><strong>散列表的构造方法：</strong></p>
<p>（1）直接定址法：$Hash(key)&#x3D;a*key+b$</p>
<p>以关键码 key 的某个线性函数为散列地址</p>
<p>优：不会产生冲突；劣：空间效率低</p>
<br>

<p>（2）除留余数法：$Hash(key)&#x3D;key\space mod\space p$</p>
<p>p 的选取：小于表长的一个质数</p>
<br>

<p>（3）其他方法</p>
<p>数字分析法、平方取中法、折叠法、随机数法等</p>
<br>

<br>

<p><strong>处理冲突的方法：</strong></p>
<p>（1）开放寻址法</p>
<p>有冲突时就去寻找下一个空的散列地址，并将数据元素存入</p>
<ul>
<li>线性探测：增量序列为 $1,2,…,q$</li>
<li>二次探测法：增量序列为 $1^2,-1^2,2^2,-2^2,…,q^2$</li>
<li>伪随机探测法：增量序列为伪随机数</li>
</ul>
<br>

<p>（2）链地址法（拉链法）</p>
<p>相同散列地址的记录链成一个单链表，m 个散列地址就设 m 个单链表</p>
<p>然后用一个数组将 m 个单链表的表头指针存储起来，形成一个动态的结构</p>
<p>例如：一组关键字为 {19，14，23，1，68，20，84，27，55，11，10，79 }</p>
<p>散列函数为 Hash（key）&#x3D; key  mod  13，则如下图所示：</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607113532923.png" alt="image-20230607113532923"></p>
<p>非同义词不会冲突，链表上结点空间是动态申请的，适用于表长不确定的情况</p>
<br>

<p>还有其他的方法比如：</p>
<ul>
<li><p>再散列法（双哈希）</p>
</li>
<li><p>建立一个公共溢出区</p>
</li>
</ul>
<br>

<br>

<p><strong>散列表的查找：</strong></p>
<p>查找的过程其实就是构造的逆过程</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/E382A2EECC416D91603EF6225C227C49.jpg" alt="img"></p>
<br>

<p>使用平均查找长度ASL来衡量查找算法，ASL取决于：</p>
<p>散列函数、处理冲突的方法、散列表的装填因子（表中记录数 &#x2F; 表长）</p>
<ul>
<li>散列表技术具有很好的平均性能，优于一些传统的技术</li>
<li>拉链法优于开放寻址法</li>
<li>除留余数法作散列函数优于其它类型函数</li>
</ul>
<br>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><strong>排序方法的分类：</strong></p>
<p>按数据存储介质：内部排序和外部排序</p>
<p>按比较器个数：串行排序和并行排序</p>
<p>按主要操作：比较排序和基数排序</p>
<p>按辅助空间：原地排序和非原地排序</p>
<p>按稳定性：稳定排序和非稳定排序</p>
<p>按自然性：自然排序和非自然排序</p>
<br>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>（1）顺序法：直接插入排序</p>
<p>（2）二分法：折半插入排序</p>
<p>（3）缩小增量：希尔排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> InfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;</span><br><span class="line">    InfoType otherinfo;</span><br><span class="line">&#125; RedType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    RedType r[MAXSIZE + <span class="number">1</span>];  <span class="comment">// 0号位置作哨兵</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>

<br>

<br>

<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.r[i].key &lt; L.r[i - <span class="number">1</span>].key) &#123;</span><br><span class="line">            <span class="comment">// 复制为哨兵</span></span><br><span class="line">            L.r[<span class="number">0</span>] = L.r[i];</span><br><span class="line">            <span class="comment">// 记录后移</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; L.r[j].key &gt; L.r[<span class="number">0</span>].key; j--)</span><br><span class="line">                L.r[j + <span class="number">1</span>] = L.r[j];</span><br><span class="line">            <span class="comment">// 插入到正确的位置</span></span><br><span class="line">            L.r[j] = L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BInsertSort</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= L.length; i++) &#123;</span><br><span class="line">        L.r[<span class="number">0</span>] = L.r[i];    <span class="comment">// 哨兵</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="type">int</span> low = <span class="number">1</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (L.r[<span class="number">0</span>].key &lt; L.r[mid].key) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--)</span><br><span class="line">            L.r[j + <span class="number">1</span>] = L.r[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先将整个待排记录序列分割成若干子序列，分别进行直接插入排序</p>
<p>待整个序列中的记录”基本有序”时，再对全体记录进行一次直接插入排序</p>
<p>算法特点：</p>
<p>1）缩小增量；2）多遍插入排序</p>
<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607170034782.png" alt="image-20230607170034782"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序表的希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> dk)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = dk + <span class="number">1</span>; i &lt;= L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.r[i].key &lt; L.r[i - dk].key) &#123;</span><br><span class="line">            L.r[<span class="number">0</span>] = L.r[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; (L.r[<span class="number">0</span>].key &lt; L.r[j].key); j--)</span><br><span class="line">                L.r[j + dk].key = L.r[j].key;</span><br><span class="line">            L.r[j + dk] = L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dlta[] 为增量数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(SqList&amp; L, <span class="type">int</span> dlta[], <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L, dlta[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>每趟不断将记录两两比较，并按“前小后大”规则交换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, flag = <span class="number">1</span>;</span><br><span class="line">    RedType x;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L.length - <span class="number">1</span> &amp;&amp; flag; i++) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= L.length - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (L.r[j].key &gt; L.r[j + <span class="number">1</span>].key) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                x = L.r[j];</span><br><span class="line">                L.r[j] = L.r[j + <span class="number">1</span>];</span><br><span class="line">                L.r[j + <span class="number">1</span>] = x;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度$O(n^2)$，很拉</p>
<br>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>通过一趟排序，将待排序记录分割成独立的两部分</p>
<p>其中一部分记录的关键字均比另一部分记录的关键字小， 则可分别对这两部分记录进行排序，以达到整个序列有序</p>
<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(SqList&amp; L, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    L.r[<span class="number">0</span>] = L.r[low];</span><br><span class="line">    <span class="type">int</span> pivotkey = L.r[low].key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey) high--;</span><br><span class="line">        L.r[low] = L.r[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey) low++;</span><br><span class="line">        L.r[high] = L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low] = L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSort</span><span class="params">(SqList&amp; L, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivotloc = <span class="built_in">Partition</span>(L, low, high);</span><br><span class="line">        <span class="built_in">QSort</span>(L, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QSort</span>(L, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速排序不适于对原本有序或基本有序的记录序列进行排序。</p>
<p>所以快排不是自然排序</p>
<br>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>在待排序的数据中选出最大（小）的元素放在其最终的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SelectSort</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= L.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 找到 L.r[i...L.length] 中最小元素的位置</span></span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">SelectMinKey</span>(L, i);</span><br><span class="line">        <span class="keyword">if</span> (i != j) <span class="built_in">swap</span>(L.r[i], L.r[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607181213182.png" alt="image-20230607181213182"></p>
<p><strong>堆的调整：</strong></p>
<p>小根堆：</p>
<ul>
<li>输出堆顶元素之后，以堆中最后一个元素替代之</li>
<li>然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换</li>
<li>重复上述操作，直至叶子结点，将得到新的堆，称这个过程为”筛选”</li>
</ul>
<br>

<p><strong>建堆：</strong></p>
<p>从一个无序序列建堆的过程就是一个反复“筛选”的过程</p>
<p>我们从最后一个非叶子结点开始向前调整（即编号为 n&#x2F;2 的结点开始）</p>
<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SqList HeapType; <span class="comment">// 采用顺序存储表示堆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整H.r[s...m]为一个大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType&amp; H, <span class="type">int</span> s, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    RedType rc = H.r[s];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// j为较大元素的下标</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; m &amp;&amp; (H.r[j].key &lt; H.r[j + <span class="number">1</span>].key)) j++;</span><br><span class="line">        <span class="keyword">if</span> (rc.key &gt;= H.r[j].key) <span class="keyword">break</span>;</span><br><span class="line">        H.r[s] = H.r[j];</span><br><span class="line">        s = j;</span><br><span class="line">    &#125;</span><br><span class="line">    H.r[s] = rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 R[1] 到 R[n] 进行堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HeapType&amp; H)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = H.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) <span class="built_in">HeapAdjust</span>(H, i, H.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = H.length; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(H.r[<span class="number">1</span>], H.r[i]);</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(H, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>将两个或两个以上的有序子序列“归并”为一个有序序列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将有序的 SR[i..m]和SR[m+1..n]合并成有序的TR[i..n]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(RedType SR[], RedType TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j, k;</span><br><span class="line">    <span class="keyword">for</span> (j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SR[i].key &lt; SR[j].key) TR[k] = SR[i++];</span><br><span class="line">        <span class="keyword">else</span> TR[k] = SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m) TR[k++] = SR[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n) TR[k++] = SR[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SR[s..t] 归并为 TR[s..t]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MSort</span><span class="params">(RedType SR[], RedType TR[], <span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t) TR[s] = SR[s];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = (s + t) / <span class="number">2</span>;</span><br><span class="line">        RedType tmp[MAXSIZE];</span><br><span class="line">        <span class="built_in">MSort</span>(SR, tmp, s, mid);</span><br><span class="line">        <span class="built_in">MSort</span>(SR, tmp, mid + <span class="number">1</span>, t);</span><br><span class="line">        <span class="built_in">Merge</span>(tmp, TR, s, mid, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(SqList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">MSort</span>(L.r, L.r, <span class="number">1</span>, L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>也叫桶排序或箱排序：</p>
<p>设置若干个箱子，将关键字为k的记录放入第k个箱子，然后在按序号将非空的连接</p>
<p>根据关键字排序，每个关键字进行一趟操作</p>
<br>

<p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/83D783C73CD2E88C81A8667882BBCD74.jpg" alt="img"></p>

</be></font></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">firtree</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/79666db.html">http://example.com/post/79666db.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">firtree</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="Wechat"/></a><div class="post-qr-code-desc">Wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="Alipay"/></a><div class="post-qr-code-desc">Alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/c24675b4.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【笔记】MySQL</div></div></a></div><div class="next-post pull-right"><a href="/post/e511c25d.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【笔记】Linux</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/511433eb.html" title="【题解】CF558_E"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-04</div><div class="title">【题解】CF558_E</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">顺序表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">链式表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">双向链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">线性表的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">有序表的合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">一元多项式的加法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">2.1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">2.1.1.</span> <span class="toc-text">顺序栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%A0%88"><span class="toc-number">2.1.2.</span> <span class="toc-text">链栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">2.2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="toc-number">2.2.1.</span> <span class="toc-text">循环顺序队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%E5%88%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">链队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">2.3.1.</span> <span class="toc-text">表达式求值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2-%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">串、数组和广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">3.1.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D-bf"><span class="toc-number">3.1.1.</span> <span class="toc-text">模式串匹配 - BF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D-kmp"><span class="toc-number">3.1.2.</span> <span class="toc-text">模式串匹配 - KMP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">广义表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.1.</span> <span class="toc-text">二叉树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.1.2.</span> <span class="toc-text">二叉树的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.2.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">4.3.</span> <span class="toc-text">树和森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">表示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.2.</span> <span class="toc-text">与二叉树的相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">4.3.3.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">4.4.</span> <span class="toc-text">哈夫曼树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">5.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%9B%BE"><span class="toc-number">5.1.</span> <span class="toc-text">存图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">5.1.3.</span> <span class="toc-text">十字链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">5.1.4.</span> <span class="toc-text">邻接多重表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.</span> <span class="toc-text">图的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">5.3.1.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">5.3.2.</span> <span class="toc-text">最短路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-number">5.4.</span> <span class="toc-text">有向无环图及其应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">5.4.1.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">5.4.2.</span> <span class="toc-text">关键路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">6.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">6.1.</span> <span class="toc-text">线性表的查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">6.2.</span> <span class="toc-text">树表的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">6.2.1.</span> <span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.2.2.</span> <span class="toc-text">平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">6.3.</span> <span class="toc-text">散列表的查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.2.</span> <span class="toc-text">折半插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">7.1.3.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.1.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.2.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">7.4.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">7.5.</span> <span class="toc-text">基数排序</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By firtree</div><div class="footer_custom_text">明知不可为而为之</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'LabIATq9q5czZzsPUmMPvHhE-gzGzoHsz',
      appKey: '1dl22OrvJXaMMW06EaPzPTdI',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>