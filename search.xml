<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【笔记】Android移动开发</title>
      <link href="/post/23934e5f.html"/>
      <url>/post/23934e5f.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><h1 id="android基础">Android基础</h1><p>Google 以 Apache 开源许可证的授权方式，发布了 Android 的源代码</p><p>Android 四大组件分别为 activity、service、content provider、broadcast receiver</p><br><p><strong>Android 体系结构：</strong></p><p>Android 采用分层结构，从高到低分为 4 层</p><p>依次是应用程序层、应用程序框架层、核心类库和 Linux 内核层</p><br><ul><li><p>应用程序层：是一个核心应用程序的集合，所有安装在手机上的应用程序都属于这一层</p></li><li><p>应用程序框架层：主要提供了构建应用程序时用到的各种 API</p></li><li><p>核心类库：包含了系统库及 Android 运行时库</p></li><li><p>Linux 内核层：为 Android 设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动等</p></li></ul><br><br><p><strong>Android 程序结构：</strong></p><p>（1）app 用于存放程序的代码和资源等内容。部分子目录的具体介绍如下：</p><ul><li><p>libs：用于存放第三方 jar 包</p></li><li><p>src / androidTest：该文件夹用于存放调试的代码文件</p></li><li><p>src / main / java：该文件夹用于存放程序的代码文件</p></li><li><p>src / lmain / res：该文件夹用于存放程序的资源文件</p></li><li><p>src / main / AndroidManifest.xml：它是整个程序的配置文件</p></li><li><p>app / build.gradle：该文件是 App 的 gradle 构建脚本。在该文件中有四个重要属性，分别是：compilveSdkVersion、buildToolsVersion、minSdkVersion、 targetSdkVersion。分别表示编译的SDK版本、编译的 Tools 版本、支持的最低SDK版本、支持的目标SDK版本（当前版本）</p></li></ul><p>（2）build.gradle：该文件是 Android 程序的 gradle 构建脚本</p><p>（3）local.properties：该文件用于指定 Android 程序中所使用的 SDK 路径</p><p>（4）settings.gradle：该文件用于配置在 Android 程序中使用到的子项目</p><br><br><p><strong>图片资源：</strong></p><p>根据屏幕密度不同，Android 会自动匹配不同文件中的图片资源</p><p>根据图片用途不同将图片分为 应用图标资源 和 界面中使用的图片资源</p><p>前者储存在以 mipmap 开头的文件夹中，后者储存在以 drawable 开头的文件夹中</p><br><p>（1）通过 java 代码调用图片资源</p><p><code>getResources().getDrawable(R.mipmap.ic_launcher) ;</code></p><p><code>getResources().getDrawable(R.drawable.icon) ;</code></p><br><p>（2）在 XML 布局中调用图片资源</p><p><code>@mipmap/ic_launcher</code></p><p><code>@drawable/icon</code></p><br><br><p><strong>主题和样式</strong></p><p>主题资源和 View 控件的具体样式都定义在 res / values 目录下的 styles.xml 文件中</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230609154122149.png" alt="image-20230609154122149"></p><p>（1）在 AndroidMainifest.xml 文件中设置主题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>...<br>android:theme = &quot;@style/AppTheme&quot;<br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）在 java 代码中设置主题</p><p><code>setTheme(R.style&gt;AppTheme)</code></p><br><p>（3）通过 style 属性引用 textViewStyle 样式</p><p><code>&lt;TextView ... style=&quot;@style/textViewStyle&quot;/&gt;</code></p><br><br><p><strong>布局资源</strong></p><p>（1）通过 Java 代码调用布局资源文件</p><p>在 Activity 中，找到 onCreate() 方法，在该方法中来加载布局资源</p><p><code>setContentView(R.layout.activity_main) ;</code></p><br><p>（2）在 XML 布局文件中调用</p><p><code>&lt;include layout=&quot;@layout/activity_main&quot; /&gt;</code></p><br><br><p><strong>字符串资源</strong></p><p>在 res / values 目录下的strings.xml 文件中定义字符串</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;app_name&quot;</span>&gt;</span>字符串<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p>（1）通过 java 代码调用</p><p>在 Activity 中，找到 onCreate() 方法，在该方法中来加载字符串资源</p><p><code>getResources().getString(R.string.app_main);</code></p><br><p>（2）在 XML 布局文件调用</p><p><code>@string/app_main</code></p><br><br><p><strong>颜色资源</strong></p><p>颜色资源通常定义在 res / values / colors.xml 文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>#fff<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p>（1）通过 java 代码调用</p><p>在 Activity 中，找到 onCreate() 方法，在该方法中来加载名称为 colorPrimary 的颜色资源</p><p><code>getResources().getColor(R.color.colorPrimary);</code></p><br><p>（2）在 XML 布局文件调用</p><p><code>@color/colorPrimary </code></p><br><br><p><strong>尺寸资源</strong></p><p>需要手动创建 res / values / dimens.xml 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dimen</span> <span class="hljs-attr">nema</span>=<span class="hljs-string">&quot;activity_horizontal_margin&quot;</span>&gt;</span>16dp<span class="hljs-tag">&lt;/<span class="hljs-name">dimen</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p>（1）通过 java 代码调用</p><p>在 Activity 中，找到 onCreate() 方法，在该方法中来加载名称为 activity_horizontal_margin 的颜色资源</p><p><code>getResources().getDimension(R.dimen.activity_horizontal_margin );</code></p><br><p>（2）在 XML 布局文件调用</p><p><code>@dimen/activity_horizontal_margin </code></p><p><br><br><br><strong>程序调试</strong></p><p>（1）单元测试</p><p>包括两种：</p><p>Android单元测试类：ExampleInstrumentedTest类</p><p>Junit单元测试类：ExampleUnitTest类</p><br><p>（2）Logcat 的使用</p><p>是 Android 中的命令行工具，用于获取系统从启动到关闭的日志信息</p><p>Android 使用 android.util.Log 类的静态方法实现输出程序的调试信息，LogCat 区域中日志信息根据日志级别的不同显示不同的颜色</p><p>Log 类所输出的日志内容分为六个级别</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230610225824445.png" alt="image-20230610225824445"></p><h1 id="常见界面布局">常见界面布局</h1><p>Android 界面由布局和控件组成。</p><br><p><strong>View控件：</strong></p><p>所有的 UI 元素都是通过 View 控件与 ViewGroup 容器构建的。</p><ul><li>Android 应用程序的每个界面必须有且只有一个 ViewGroup 容器</li></ul><br><br><h2 id="界面布局编写方式">界面布局编写方式</h2><p>（1）在 XML 布局文件中编写布局，通常放在 res / layout 文件夹中，可以使结构更加清晰。</p><p>（2）在 Java 代码中编写布局，先通过 new 关键字创建，将创建的 View 控件添加到 nViewGroup 容器中，从而实现在布局界面中显示 View 控件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RelativeLayout</span> <span class="hljs-variable">relativeLayout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RelativeLayout</span>(<span class="hljs-built_in">this</span>);<br>    RelativeLayout.<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RelativeLayout</span>.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT,RelativeLayout.LayoutParams.WRAP_CONTENT);<br><br>    <span class="hljs-comment">// addRule 参数对应 RelativeLayout 的 XML 布局属性</span><br>    params.addRule(RelativeLayout.CENTER_IN_PARENT);<br><span class="hljs-type">TextView</span> <span class="hljs-variable">textView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextView</span>(<span class="hljs-built_in">this</span>);     <span class="hljs-comment">// 创建 TextView 控件</span><br>textView.setText(<span class="hljs-string">&quot;Java 代码实现界面布局&quot;</span>);   <span class="hljs-comment">// 设置空间的文字内容</span><br>textView.setTextColor(Color.RED);           <span class="hljs-comment">// 设置控件的文字颜色</span><br><br><span class="hljs-comment">// 添加 TextView 对象和 TextView 的布局属性</span><br>relativeLayout.addView(textView, params);<br>setContentView((relativeLayout));<br></code></pre></td></tr></table></figure><br><br><h2 id="界面布局的通用属性">界面布局的通用属性</h2><p>5 种常用布局：线性布局、相对布局、表格布局、帧布局、约束布局</p><p>这些常用布局都必须指定 <code>android:layout_width</code> 和 <code>android:layout_heugh</code>，其他随意</p><br><p>布局的通用属性</p><table><thead><tr><th>属性名称</th><th>功能描述</th></tr></thead><tbody><tr><td>android:id</td><td>设置当前布局的唯一标识</td></tr><tr><td>android:layout_width</td><td>设置布局的宽度</td></tr><tr><td>android:layout_heigh</td><td>设置布局的高度</td></tr><tr><td>android:background</td><td>设置布局的背景</td></tr><tr><td>android:layout_margin</td><td>设置当前布局与屏幕边界、周围布局或控件的距离</td></tr><tr><td>android:padding</td><td>设置当前布局与该布局中控件的距离</td></tr></tbody></table><br><p><strong>（1）android:id</strong></p><p>在 XML 布局文件中它的属性值是通过&quot;@+id / 属性名称&quot; 定义的</p><p>为布局指定 android:id 属性后，在 R.java 文件中会自动生成对应的 int 值</p><p>在 Java 代码中通过 findViewByld() 方法传入该 int 值来获取该布局对象</p><br><br><p><strong>（2）android:layout_width / android:layout_heigh</strong></p><p>可以是具体的尺寸也可以是系统定义的值</p><ul><li>fill_parent：表示该容器的宽度与父容器的宽度（高度）相同</li><li>match_parent：同上</li><li>warp_content：表示该布局的宽度恰好能包裹它的内容</li></ul><br><br><p><strong>（3）android:background</strong></p><p>可以引用图片资源，也可以引用颜色资源</p><br><br><p><strong>（4）android:margin / android:padding</strong></p><p>值为具体的尺寸如 45dp</p><p>相似的还有：</p><p>android:layout_marginTop、android:layout_marginBottom、android:layout_marginLeft、android:layout_marginRight</p><p>android:paddingTop、android:paddingBottom、android:paddingLeft、android:paddingRight</p><br><h2 id="线性布局-linearlayout">线性布局 LinearLayout</h2><p>线性布局的子控件通常被指定为水平或者竖直排列</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">属性</span> = <span class="hljs-string">&quot;属性值&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><br><table><thead><tr><th>属性名称</th><th>功能描述</th></tr></thead><tbody><tr><td>android:orientation</td><td>设置布局内控件的排列顺序</td></tr><tr><td>android:weight</td><td>在布局内设置控件权重，属性值可直接写 int 值</td></tr><tr><td>gravity=“center”</td><td>表示布局内控件居中显示</td></tr></tbody></table><p><strong>android:orientation</strong></p><ul><li>vertical：表示 LinearLayout 内控件从上到下依次竖直排列</li><li>horizontal：表示 LinearLayout 内控件从左到右依次水平排列</li></ul><br><p><strong>android:weight</strong></p><p>通过具体的数值来设置显示比，在进行屏幕适配时起到关键作用</p><p>控件的 android:layout_width 属性一般要设置为 0dp 才会有权重占比的效果，并且</p><p>LnearLayout 中的 android:layout_width 需设置为 match_parent</p><br><h2 id="相对布局-relativelayout">相对布局 RelativeLayout</h2><p>相对布局通过相对定位的方式指定子控件的位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/akp/res/android&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">属性</span> = <span class="hljs-string">属性值</span></span><br><span class="hljs-tag"><span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><br><table><thead><tr><th>属性名称</th><th>功能描述</th></tr></thead><tbody><tr><td>android:layout_centerInParent</td><td>设置当前控件位于父布局的中央位置</td></tr><tr><td>android:layout_centerVertical</td><td>设置当前控件位于父布局的垂直居中位置</td></tr><tr><td>android:layout_centerHorizontal</td><td>设置当前控件位于父控件的水平居中位置</td></tr><tr><td>android:layout_above</td><td>设置当前控件位于某控件上方</td></tr><tr><td>android:layout_below</td><td>设置当前控件位于某控件下方</td></tr><tr><td>android:layout_toLeftOf</td><td>设置当前控件位于某控件左侧</td></tr><tr><td>android:layout_toRightOf</td><td>设置当前控件位于某控件右侧</td></tr><tr><td>android:layout_alignParentTop</td><td>设置当前控件是否与父控件顶端对齐</td></tr><tr><td>android:layout_alignParentLeft</td><td>设置当前控件是否与父控件左对齐</td></tr><tr><td>android:layout_alignParentRight</td><td>设置当前控件是否与父控件右对齐</td></tr><tr><td>android:layout_alignParentBottom</td><td>设置当前控件是否与父控件底端对齐</td></tr><tr><td>android:layout_alignTop</td><td>设置当前控件的上边界与某控件的上边界对齐</td></tr><tr><td>android:layout_alignBottom</td><td>设置当前控件的下边界与某控件的下边界对齐</td></tr><tr><td>android:layout_alignLeft</td><td>设置当前控件的下边界与某控件的左边界对齐</td></tr><tr><td>android:layout_alignRight</td><td>设置当前控件的下边界与某控件的右边界对齐</td></tr></tbody></table><p><strong>举个栗子：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230611101638476.png" alt="image-20230611101638476"></p><br><h2 id="表格布局-tablelayout">表格布局 TableLayout</h2><p>采用行、列的形式来管理控件。不需要明确声明其中的行列数，而是通过在表格中添加 TableRow 来控制</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TableLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">属性</span> = <span class="hljs-string">属性值</span></span><br><span class="hljs-tag">&lt;<span class="hljs-attr">TableRow</span>&gt;</span><br>UI 控件<br><span class="hljs-tag">&lt;<span class="hljs-name">TableRow</span>&gt;</span><br>UI 控件<br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">TableLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p>TableLayout 继承自 LinearLayout，因此完全支持 LinearLayout 所支持的属性，额外的还有</p><table><thead><tr><th>属性名称</th><th>功能描述</th></tr></thead><tbody><tr><td>android:stretchColumns</td><td>设置可拉伸的列。android:stretchColumns=“0” 表示第1列可拉伸</td></tr><tr><td>android:shrinkColumns</td><td>设置可收缩的列。android:shrinkColumns=“1, 2” 表示第2列、第3列可收缩</td></tr><tr><td>android:collapseColumns</td><td>设置可隐藏的列。android:collapseColumns=“0” 表示第1列可隐藏</td></tr></tbody></table><p><strong>TableLayout 中的控件常用属性：</strong></p><table><thead><tr><th>属性名称</th><th>功能描述</th></tr></thead><tbody><tr><td>android:layout_column</td><td>设置该控件显示的位置。android:layout_column=“1” 表示在第2个位置显示</td></tr><tr><td>android:layout_span</td><td>设置该控件占据几列，默认为1列</td></tr></tbody></table><p>需要注意的是，在 TableLayout 中，列的宽度由该列中最宽的那个单元格（控件）决定</p><p>整个 TableLayout 的宽度则取决于父容器的宽度</p><br><h2 id="帧布局-framelayout">帧布局 FrameLayout</h2><p>帧布局用于在屏幕上创建一块空白区域， 添加到该区域中的每个子控件占一帧，这些帧会一个一 个叠加在一起，后加人的控件会叠加在上一个控件上层。默认情况下，帧布局中的所有控件会与布局的左上角对齐</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span> <span class="hljs-attr">xmlns</span> <span class="hljs-attr">android</span>=<span class="hljs-string">&quot;http://schemas android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">属性</span> = <span class="hljs-string">&quot;属性值&quot;</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-attr">FrameLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><br><table><thead><tr><th>属性名称</th><th>功能描述</th></tr></thead><tbody><tr><td>android:foreground</td><td>设置FrameLayout容器的前景图像（始终在所有子控件之上）</td></tr><tr><td>andorid:foregroundGravity</td><td>设置前景图像显示的位置</td></tr></tbody></table><br><h1 id="android常见界面控件">Android常见界面控件</h1><h2 id="textview">TextView</h2><p>用于显示文本信息</p><table><thead><tr><th>属性名称</th><th>功能描述</th></tr></thead><tbody><tr><td>android:layout_width</td><td>设置 TextView 控件的宽度</td></tr><tr><td>android:layout_height</td><td>设置 TextView 控件的高度</td></tr><tr><td>android:id</td><td>设置 TextView 控件的唯一标识</td></tr><tr><td>android:background</td><td>设置 TextView 控件的背景</td></tr><tr><td>android:layout_margin</td><td>设置当前控件与屏幕边界或周围控件、布局的距离</td></tr><tr><td>android:padding</td><td>设置 TextView 控件与该控件中内容的距离</td></tr><tr><td>android:text</td><td>设置文本内容</td></tr><tr><td>android:textColor</td><td>没置文本中文字显示的颜色</td></tr><tr><td>android:textSize</td><td>设置文本中文字大小，推荐单位为sp</td></tr><tr><td>android:gravity</td><td>设置文本内容的位置，如设置成&quot;center”， 文本将居中显示</td></tr><tr><td>android:maxLength</td><td>设置文本最大长度，超出此长度的文本不显示</td></tr><tr><td>android:lines</td><td>设置文本的行数，超出此行数的文本不显示</td></tr><tr><td>android:maxLines</td><td>设置文本的最大行数，超出此行数的文本不显示</td></tr><tr><td>android:ellipsize</td><td>设置当文本超出 TextView 控件规定的范围时的显示方式。属性值可选为” start&quot;、“middle”、“end&quot; ，分别表示在文本开始、中间或者末尾显示省略号</td></tr><tr><td>android:drawableTop</td><td>在文本的顶部显示图像，该图像资源可以放在 res/drawable 文件夹中相应分辨率的目录下，通过“@drawable/文件名” 调用。类似的属性有android:drawableBottom、android:drawableLeft、android:drawableRight</td></tr><tr><td>android:lineSpacingExtra</td><td>设置文本的行间距</td></tr><tr><td>android:textStyle</td><td>设置文本样式：bold (粗体)、talic (斜体)、normal (正常)</td></tr></tbody></table><br><h2 id="edittext">EditText</h2><p>EdiTert 控件表示编辑框，它是 TextView 控件的子类，用户可在此控件中输人信息</p><p>除了支持 TextView 控件的属性，还支持些其他的常用属性：</p><table><thead><tr><th>属性名称</th><th>功能描述</th></tr></thead><tbody><tr><td>android:hint</td><td>控件中内容为空时显示的提示文本信息</td></tr><tr><td>android:textColorHint</td><td>控件中内容为空时显示的提示文本信息的颜色</td></tr><tr><td>android:password</td><td>输入文本框中的内容显示为“.”</td></tr><tr><td>android:phoneNumber</td><td>设置输入文本框中的内容只能是数字</td></tr><tr><td>android:minLines</td><td>设置文本的最小行数</td></tr><tr><td>android:scrollHorizontally</td><td>设置文本信息超出 EditText 控件的宽度情况下是否出现横拉条</td></tr><tr><td>android:editable</td><td>设置是否可编辑</td></tr></tbody></table><br><h2 id="button">Button</h2><p>继承自 TextView 控件，既可以显示文本又可以显示图片（还是建议使用ImageView）</p><p>同时可以通过点击来执行操作，为 Button 控件设置点击事件的方式有三种</p><p>（1）在布局文件中指定 onClick 属性的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag"><span class="hljs-attr">...</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:onClick</span>=<span class="hljs-string">&quot;click&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>然后就可以在 Activity 中定义专门的方法来实现点击事件，方法名必须与 onLClick 属性的值保持一致</p><br><p>（2）使用匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">btn.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br><span class="hljs-comment">// 实现点击事件的代码</span><br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><br><p>（3）使用 Activity 实现 OnClickListener 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Activity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle saveInstanceState)</span> &#123;<br>...<br>btn.setOnClickListener(<span class="hljs-built_in">this</span>);<br>&#125;<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">OnClick</span><span class="hljs-params">(View view)</span> &#123;<br><span class="hljs-comment">// 实现点击事件的代码</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="imageview">ImageView</h2><p>继承自 View 控件，可以加载各种图片资源</p><table><thead><tr><th>属性名称</th><th>功能描述</th></tr></thead><tbody><tr><td>android:layout_width</td><td>设置ImageView控件的宽度</td></tr><tr><td>android:layout_height</td><td>设置ImageView控件的高度</td></tr><tr><td>android:id</td><td>设置ImageView控件的唯一标识</td></tr><tr><td>android:background</td><td>设置ImageView控件的背景</td></tr><tr><td>android:layout_ margin</td><td>设置当前控件与屏幕边界或周围控件的距离</td></tr><tr><td>android:src</td><td>设置ImageView控件需要显示的图片资源</td></tr><tr><td>android:scaleType</td><td>将图片资源缩放或移动，以适应ImageView控件的宽高</td></tr><tr><td>android:tint</td><td>将图片渲染成指定的颜色</td></tr></tbody></table><p>值得注意的是</p><p>通过 android:background 属性和 android:src 属性为 ImageView 控件设置图片的方式相同，都是以 “@drawable / 图片名称” 的方式进行设置的</p><p>区别在于 android:background 属性设置的是背景，会根据 ImageView 控件的大小进于伸缩</p><p>而 android:src 属性设置的是前景，以原图大小显示</p><br><h2 id="radiobutton">RadioButton</h2><p>RadioButton 控件表示单选按钮，它是 Button 控件的子类，默认为未选中状态</p><p>每一个单选按钮都有 “选中” 和 “末选中” 两种状态，这两种状态是通过 android:checked 属性指定的。当可选值为 true 时，表示选中状态，否则表示未选中状态</p><p>在 Android 程序中 RadioButton 控件经常与 RadioGroup 配合使用，实现单选按钮的功能</p><p>RadioGroup 是单选组合框，可容纳多个 RadioButon 控件，但是在 RadioGroup 中不会出现多个RadioBtton 同时选中情况</p><p>RadioGroup 继承自 LinearLayout，可以使用 android:orientation属性设置布局内控件的排列顺序</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RadioGroup</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:属性名称</span> = <span class="hljs-string">&quot;属性值&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">...</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">RadioButton</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:属性名称</span> = <span class="hljs-string">&quot;属性值&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">...</span> &gt;</span><br>...<br><span class="hljs-tag">&lt;<span class="hljs-name">RadioGroup</span> /&gt;</span><br></code></pre></td></tr></table></figure><br><h2 id="checkbox">CheckBox</h2><p>CheckBox 控件表示复选框，它是 Button 控件的子类，用于实现多选功能</p><p>每一个复选框都有“选中”和“未选中”两种状态，这两种状态是通过 android:checked 属性指定的，当该属性的值为true时，表示选中状态，否则，表示未选中状态</p><br><h2 id="toast">Toast</h2><p>Thast 类是 Android 提供的轻量级信息提配机制，用于向用户提示即时消息，它显示在应用程序界面的最上层显示一段时间后自动消失，不会打断当前操作，也不获得焦点</p><p>使用 Toast 类显示提示信息：</p><p><code>Toast.makeText (Context, Text, Time).show();</code></p><p>上述代码首先通过调用 Toast 类的 makeText 方法设置提示信息，然后调用 show0 方法将提示信息显示到界面中</p><p>makeText() 方法中的参数：</p><ul><li>Context：表示应用程序环境的信息，即当前组件的上下文环境。Context 是一个抽象类，如果在 Activity 中使用 Toast 类的提示信息，那么该参数可设置为 “当前Activity.this&quot;</li><li>Text：表示提示的字符串信息</li><li>Time：表示显示信息的时长，其属性值包括 Toast.LENGTH_SHORT 和 Toast.LENGTH_LONG，分别表示显示较短时间和较长时间</li></ul><p>默认情况下，Toast 类的消息会显示在屏幕的下方，它通常适用于信息提醒</p><p>比如提示网络未连接、用户名密码输人错误或者退出应用程序等</p><br><p><strong>想要消除导航栏：</strong></p><p>在D:\app\src\main\AndroidManifest.xml 中修改 theme 的属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;<br></code></pre></td></tr></table></figure><br><h2 id="列表控件">列表控件</h2><p>在一个页面中显示多个条目，并且每个条目之间的布局风格一致</p><h3 id="listview-的使用">ListView 的使用</h3><p>以列表的形式显示内容，并且能够根据列表的高度自适应屏幕显示</p><table><thead><tr><th>属性名称</th><th>功能描述</th></tr></thead><tbody><tr><td>android:listSelector</td><td>当条目被点击后，改变条目的背景颜色</td></tr><tr><td>android:divider</td><td>设置分割线的颜色</td></tr><tr><td>android:dividerHeight</td><td>设置分割线的高度</td></tr><tr><td>android:scrollbars</td><td>是否显示滚动条</td></tr><tr><td>android:fadingEdge</td><td>去掉上边和下边的黑色阴影</td></tr></tbody></table><br><br><p><strong>常用数据适配器：</strong></p><p>数据适配器是数据与视图之间的桥梁</p><p>（1）BaseAdapter</p><p>是抽象类，通常在自定义数据适配器时会继承这 BaseAdapter，常用的抽象方法如下：</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>public int getCount()</td><td>获取 Item 条目的总数</td></tr><tr><td>public Object getItem(int position)</td><td>根据 position 获取某个 Item 的对象</td></tr><tr><td>piblic long getItemId(int position)</td><td>根据 position 获取某个 Item 的id</td></tr><tr><td>public View getView(int position, View convertView, ViewGroup parent)</td><td>获取相应 position 对应的 Item 视图，posution 是当前 Item 的位置，convertView用于复用旧视图，parent 用于加载 XML 布局文件</td></tr></tbody></table><br><p>（2）SimpleAdapter</p><p>继承自 BaseAdapter，在进行数据适配时，只要在构造方法中传入相应的参数即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleAdapter</span><span class="hljs-params">(Context context, List&lt;? extends Map&lt;String, ?&gt;&gt; data, </span><br><span class="hljs-params"><span class="hljs-type">int</span> resource, String[] from, <span class="hljs-type">int</span>[] to)</span><br></code></pre></td></tr></table></figure><ul><li>context：上下文对象</li><li>data：数据集合。data中的每一项对应 ListView 控件中条目的数据</li><li>resource：Item 布局的资源 id</li><li>from：Map 集合中的 key 值</li><li>to：Item 布局中对应的控件</li></ul><br><p>（3）ArrayAdapter</p><p>也是 BaseAdapter 的子类，ArrayAdapter 通常适配 TextView 控件，有多个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Public <span class="hljs-title function_">ArrayAdapter</span><span class="hljs-params">(Context context, <span class="hljs-type">int</span> resource)</span>;<br>Public <span class="hljs-title function_">ArrayAdapter</span><span class="hljs-params">(Context context, <span class="hljs-type">int</span> resource, <span class="hljs-type">int</span> textViewResourceId;</span><br><span class="hljs-params">Public ArrayAdapter(Context context, <span class="hljs-type">int</span> resource, T[] Objects)</span>;<br>Public <span class="hljs-title function_">ArrayAdapter</span><span class="hljs-params">(Context context, <span class="hljs-type">int</span> resource, <span class="hljs-type">int</span> textViewResourceId, T[] Objects)</span>;<br>Public <span class="hljs-title function_">ArrayAdapter</span><span class="hljs-params">(Context context, <span class="hljs-type">int</span> resource, <span class="hljs-type">int</span> textViewResourceId, List&lt;T&gt; objects)</span>;<br></code></pre></td></tr></table></figure><ul><li>contexe：上下文对象</li><li>resource：Item 布局的资源 id</li><li>textViewResourceId：Item 布局中相应的 TextView 控件的 id</li><li>T[] Objects：需要适配数组类型的数据</li><li>List<t> objects：需要适配 List 类型的数据</t></li></ul><br><h3 id="recyclerview">RecyclerView</h3><p>Android5.0后开始提供 RecyclerView控件，该控件可以在有限的窗口范围内显示大量的数据</p><p>（1）显示效果</p><p>通过 LayoutManager 类实现横向或竖向的列表效果、瀑布流效果和GridView效果</p><br><p>（2）数据适配器</p><p>使用的是 RecyclerView.Adapter，该数据适配器将 BaseAdapter 中的 getView() 方法拆分为 onCreateViewHolder() 方法和 onBindViewHolder() 方法，使代码编写规范化</p><br><p>（3）复用效果</p><p>RecyclerView控件复用 Item 对象的工作由该控件自己实现</p><br><p>（4）动画效果</p><p>可以通过 setItemAnimator() 方法为 Item 添加动画效果</p><br><h2 id="自定义控件">自定义控件</h2><p>通常开发 Android 应用程序的界面时，都不直接使用 View 控件，而是使用 View 控件的子类</p><p>虽然 Android 提供了很多继承自 View 类的控件，但是在实际开发中，还会出现不满足需求的情况。此时我们可以通过自定义控件的方式实现</p><p>最简单的自定义控件就是创建一个继承 View 类或其子类的类，并重写该类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Customview</span> <span class="hljs-params">(Context context)</span> &#123;<br><span class="hljs-built_in">super</span>(context);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CustonView</span> <span class="hljs-params">(Context context, AttributeSet attrs)</span> &#123;<br><span class="hljs-built_in">super</span>(context, attrs);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>自定义控件常用的3个方法：</p><p>（1）onMeasure() 用于测量尺寸，在该方法中可以设置控件自身或其子控件的宽高</p><p>（2）onDraw() 用于绘制图像，<code>onDraw(canvas)</code>中的参数 canvas 表示画布，常搭配 Paint 类（画笔）一起使用</p><p>（3）onLayout 用于指定子控件的位置</p><br><h1 id="程序活动单元-activity">程序活动单元 Activity</h1><p>Android 中的四大组件分别是 Activity、Service 、ContentProider 和 BradcastReceiver</p><p>其中，Activiry 是一个负责与用户交互的组件，每个 Android 应用程序中都会用Activity来显示界面及处理界面上一些控件的事件</p><br><h2 id="activity-生命周期">Activity 生命周期</h2><p>Activity 的生命周期指的是 Activity 从创建到销毁的整个过程</p><p>这个过程大致可以分为 5 种状态，分别是启动状态、运行状态、暂停状态、停止状态和销毁状态</p><br><p>（1）启动状态</p><p>Activity 的启动状态很短暂。一般情况下，当 Activity 启动之后便会进入运行状态</p><br><p>（2）运行状态</p><p>Activity 在此状态时处于界面最前端，它是可见的、有焦点的，并且可以与用户进行交互，如点击界面<br>中的按钮和在界面上输入信息等</p><p>PS：当 Activity 处于运行状态时，Android 会尽可能地保持这种状态，即使出现内存不足的情况，Android 也会先销毁栈底的 Activity 来确保当前 Activity 正常运行</p><br><p>（3）暂停状态</p><p>暂停状态下，Activity 对用户来说仍然可见，但它无法获取焦点，对用户的操作没有响应</p><p>例如，当Acivity 上覆盖了一个透明或者非全屏的界面时，被覆盖的 Activity 就处于智停状态</p><br><p>（4）停止状态</p><p>当 Activity 完全不可见时，他就处于停止状态，如果系统内存不足，那么这种状态下的 Activity 很容易被销毁</p><br><p>（5）</p><p>当 Activity 处于销毁状态时，将被清理出内存</p><p>PS：Activity 生命周期的启动状态和销毁状态是过渡状态，Acivity 不会在这两个状态停留</p><br><p><strong>生命周期方法：</strong></p><p>Activity 的生命周期包括创建、可见、获取焦点、失去焦点、不可见、重新可见、销毁等环节</p><p>针对每个环节 Activity 都定义了相应的回调方法</p><ul><li>onCreate()：创建 Activity 时调用，通常做一些初始化设置</li><li>onStart：Activity 即将可见时调用</li><li>onResume()：Activity 获取焦点时调用</li><li>onPause()：当前 Activity 被其他 Activity 覆盖或屏幕锁屏时调用</li><li>onStop()：Activity 对用户不可见时调用</li><li>onRestart()：Activity 从停止状态到再次启动状态时调用</li><li>onDestroy()：销毁 Activity 时调用</li></ul><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/A7F0D491E3D3CFC72EC24BEB7CBDE2EB.jpg" alt="img"></p><br><h2 id="activity-的创建-配置-关闭">Activity 的创建、配置、关闭</h2><p><strong>创建 Activity：</strong></p><p>（1）直接创建</p><p>（2）配置 Activity</p><ul><li>先创建一个普通的 Java 类，extends AppCompatActivity</li><li>再在 <code>AndroidMainifset.xml</code> 文件的 <code>&lt;application&gt;&lt;/application&gt;</code> 标签内配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">&quot;Activity 的结对路径&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><br><br><p><strong>启动 / 关闭 Activity：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 启动Avtivity，其名为 SecondActivity</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(MainActivity.<span class="hljs-built_in">this</span>, SecondActivity.class);<br>startActivity(intent);<br><br>finish(); <span class="hljs-comment">// 关闭当前Activity</span><br></code></pre></td></tr></table></figure><br><br><h2 id="intent">Intent</h2><p>Intent 为意图，是程序中各组件间进行交互的一种重要方式</p><p>它不仅可以指定当前组件要执行的动作，还可以在不同组件之间进行数据传递，分为两种类型</p><br><p><strong>显式 Intent：</strong></p><p>显示 Intent 直接指定目标组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, SecondActivity.class);<br>startActivity(intent);<br></code></pre></td></tr></table></figure><br><br><p><strong>隐式 Intent：</strong></p><p>影视 Intent 不会明确指出需要激活的目标组件，它被广泛的应用在不同应用程序之间进行消息传递</p><p>Android 会使用 IntentFilter 匹配相应的组件，匹配的属性主要包括3个，分别是action、data和 category 属性</p><ul><li>action：表示 Intent 对象要完成的动作</li><li>data：表示 Intent 对象中传递的数据</li><li>category ：表示为 action 属性添加的额外信息</li></ul><p>具体步骤：</p><p>（1）在 <code>AndroidMainifest.xml</code> 文件中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;activity android:name=<span class="hljs-string">&quot;.SecondActivity&quot;</span><br>&lt;intent-filter&gt;<br>&lt;action android:name=<span class="hljs-string">&quot;cn.itcase.START_ACTIVITY&quot;</span> /&gt;<br>&lt;category android:name=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;<br>    &lt;/intent-filter&gt;<br>&lt;/activity&gt;<br></code></pre></td></tr></table></figure><br><p>（2）在 MainActivity 中开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br><br><span class="hljs-comment">// 设置 action 动作，要和清单文件中设置的一样</span><br>intent.setAction(<span class="hljs-string">&quot;cn.itcase.START_ACTIVITY&quot;</span>);<br>startActivity(intent);<br></code></pre></td></tr></table></figure><br><p>IntentFilter 是过滤器，当系统发送一个隐式 Intent 后， Android 会将它与程序中每一个组件的过滤器进行匹配</p><p>匹配的属性有 action、data 和 category，需要这三个属性都匹配成功才能唤起相应的组件</p><br><h2 id="activity-之间的跳转">Activity 之间的跳转</h2><h3 id="数据传递">数据传递</h3><p>（1）使用 Intent 的 putExtra() 方法进行传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在从 MainActivity 跳转到 SecondActivity 时</span><br><span class="hljs-comment">// 利用 Intent 传递学生姓名，成绩和成绩是否合格等数据</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>intent.setClass(MainActivity.<span class="hljs-built_in">this</span>, SecondActivity.class);<br>intent.putExtra(<span class="hljs-string">&quot;studentName&quot;</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>intent.putExtra(<span class="hljs-string">&quot;englishScore&quot;</span>, <span class="hljs-number">98</span>);<br>intent.putExtra(<span class="hljs-string">&quot;isPassed&quot;</span>, <span class="hljs-literal">true</span>);<br>startActivity(intent);<br><br><span class="hljs-comment">// 在 SecondActivity 中通过 getXxxExtra() 方法来获取传过来的数据</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> getIntent();<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> intent.getStringExtra(<span class="hljs-string">&quot;studentName&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">englishScore</span> <span class="hljs-operator">=</span> intent.getInExtra(<span class="hljs-string">&quot;englishScore&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isPassed</span> <span class="hljs-operator">=</span> intent.getBooleanExtra(<span class="hljs-string">&quot;isPassed&quot;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><br><p>（2）使用Bubdle 类传递数据</p><p>与Map接口类似，通过键值对的形式保存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>intent.setClass(MainActivity.<span class="hljs-built_in">this</span>, SecondActivity.class);<br><span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>bundle.putString(<span class="hljs-string">&quot;account&quot;</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>bundle.putString(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>intent.putExtras(bundle);<br>srartActivity(intent);<br><br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> getIntent().getExtras();<br><span class="hljs-type">String</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> bundle.getString();<br><span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> bundle.getString();<br></code></pre></td></tr></table></figure><br><h3 id="数据回传">数据回传</h3><p>将数据在 SecondActivity 关闭时传回 MainActivity</p><p>（1）startActivityForResult() 方法</p><p>用于开启一个 Activity，并且当开启的 Activity 被销毁时，会从销毁的 Activity 中返回数据</p><p><code>startActivityForResult(Intent intent, int requestCode)</code></p><p>第一个参数为意图对象，第二个参数为请求码</p><br><p>（2）setResult() 方法</p><p>用于携带数据进行回传</p><p><code>setResult(int resultCode, Intent intent)</code></p><p>第一个参数表示返回码，第二个参数用于携带数据并返回至上一个界面</p><br><p>（3）onActivityResult() 方法</p><p><code>onActivityResult(int requestCode, int resultCode, Intent data)</code></p><p>第一个参数表示请求码，第二个参数表示返回码，第三个参数表示回传的数据</p><br><h3 id="activity-的启动模式">Activity 的启动模式</h3><p>Activity 有 4 种启动模式，分别为 standard、singleTop、singleTask 和 singleInstance</p><ul><li>standard 模式是 Activity 的默认启动方式，每启动一个 Activity 就会在栈顶创建一个新的实例</li><li>singleTop 模式会判断要启动的 Activity 实例是否位于栈顶，如果位于栈顶则直接复用，否则创建新的实例</li><li>singleTask 模式下每次启动该 Activity 时，系统首先会检查栈中是否存在当前 Activity 实例，如果存在则直接使用，并把当前 Activity 之上的所有实例全部出栈</li><li>singleInstance 模式会启动一个新的任务栈来管理 Activity 实例， 无论从哪个任务栈中启动该 Activity，该实例在整个系统中只有一个</li></ul><br><h2 id="fragment">Fragment</h2><p>Fragment（碎片）是一种可以嵌入在 Activity 中的 UI 片段，用来描述 Activity 中的一部分布局</p><br><p><strong>生命周期：</strong></p><p>Fragment 不能独立存在，必须嵌入到 Activity 中使用，所以 Fragment 生命周期直接受所在的 Activity 影响</p><ul><li><p>当在 Activity 中创建 Fragment 时，Fragment处于启动状态</p></li><li><p>当 Activity 被暂停时，其中的所有 Fragment 也被暂停</p></li><li><p>当 Activity 被销毁时，所有在该 Activity 中的 Fragment 也被销毁</p></li><li><p>当一个 Activity 处于运行状态时，可以单独地对每-个 Fragment 进行操作</p></li></ul><br><p>Fragment 的生命周期与 Activity 的生命周期很相似，额外的有</p><ul><li>onAttach()：Fragment 和 Activity 建立关联时调用</li><li>onCreateView()：Fragment  创建视图（加载布局）时调用</li><li>onActivityCreate()：Fragment  相关联的 Activity 已经创建完成时调用</li><li>onDestoryView()：Fragment 关联的视图被移除时调用</li><li>onDetach()：Fragment  和 Activity 接触关联时调用</li></ul><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230612190724983.png" alt="image-20230612190724983"></p><br><br><p><strong>创建 Fragment</strong></p><p>创建 Fragment 时必须创建一个类继承 Fragment</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewsListFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fragment</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> &#123;<br><span class="hljs-type">View</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> inflater.inflate(R.layout.fragment, container, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> v;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><br><p><strong>在 Activity 中添加 Fragment</strong></p><p>Fragment 创建完成后并不能单独使用，需要将 Fragment 添加到 Activity 中</p><p>（1）在布局文件中添加，必须指定 <code>android:name</code> 属性，其值为 Fragment 的全路径名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/skp/res/android&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;cn.itcase.NewsListFragment&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/newsList&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p>（2）在 Activity 中动态的加载 Fragment</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br><span class="hljs-meta">@SuppressLint(&quot;NesApi&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(bundle sacedInstance)</span> &#123;<br><span class="hljs-built_in">super</span>.onCreate(sacedInstance);<br>        setContentView(R.layout.activity_main);<br>        <br>        <span class="hljs-comment">// 实例化Fragment对象</span><br>        <span class="hljs-type">NewsListFragment</span> <span class="hljs-variable">fragment</span> <span class="hljs-operator">=</span> nre <span class="hljs-title function_">NewsListFragment</span><span class="hljs-params">()</span>;<br>        <br>        <span class="hljs-comment">// 获取FragmentTransaction实例</span><br>        <span class="hljs-type">FragmentManager</span> <span class="hljs-variable">fm</span> <span class="hljs-operator">=</span> getFragmentManager();<br>        <br>        <span class="hljs-comment">// 开启FragmentTransaction事务</span><br>        <span class="hljs-type">FragmentTransaction</span> <span class="hljs-variable">beginTransaction</span> <span class="hljs-operator">=</span> fm.beginTransaction();<br>        <br>        beginTransaction.replace(R.id.ll, fragment);<br>        beginTransaction.commit();<span class="hljs-comment">// 提交事务</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h1 id="数据存储">数据存储</h1><p>Andioid 平台提供了 5 种数据存储方式</p><table><thead><tr><th>存储方式</th><th>特点</th></tr></thead><tbody><tr><td>文件存储</td><td>提供了openFileInput()方法和openFileOutput() 方法来读取设备上的文件</td></tr><tr><td>SharedPerences 存储</td><td>以 XML 格式将数据存储到设备中</td></tr><tr><td>SQLite 数据库存储</td><td>自带的轻量级的数据库。运算速度快，占用资源少，还支持基本 SQL 语法</td></tr><tr><td>ContentProvider</td><td>Android 四大组件之一，主要应用于程序之间的数据交换，可以将自己的数据共享给其他应用程序</td></tr><tr><td>网络存储</td><td>通过网络提供的存储空间来存储 / 获取数据信息</td></tr></tbody></table><br><h2 id="文件存储">文件存储</h2><h3 id="将文件存入文件">将文件存入文件</h3><p>有两种存储方式：内部存储和外部存储</p><br><p><strong>内部存储</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> openFileOutput(String name, <span class="hljs-type">int</span> mode);<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> openFileInput(String name)<br></code></pre></td></tr></table></figure><p>参数 name 表示文件名，mode 表示文件的操作模式，可选的取值有 4 种：</p><ul><li>MODE_ PRIVATER：该文件只能被当前程序读写</li><li>MODE_ APPEND：该文件的内容可以追加</li><li>MODE_ WORLD_ READABLE：该文件的内容可以被其他程序读</li><li>MODE_ WORLD_ WRITEABLE：该文件的内容可以被其他程序写</li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;data.txt&quot;</span>;<span class="hljs-comment">// 文件名称</span><br><span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloworld&quot;</span>;<span class="hljs-comment">// 保存数据</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>    fos = openFileOutput(fileName, MODE_PRIVATE);<br>    fos.write(content.getBytes());  <span class="hljs-comment">// 将数据写入文件中</span><br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (fos != <span class="hljs-literal">null</span>) &#123;<br>            fos.close();    <span class="hljs-comment">// 关闭输出流</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><br><p><strong>外部存储</strong></p><p>是指将数据以文件的形式存储到一些外部设备（例如 SD 卡或者设备内嵌的存储卡），属于永久性的存储方式</p><p>外部存储的文件可以被其他应用程序共享</p><br><p>eg. 向外部设备（SD 卡）中存储数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> Environment.getExternalStorageState();   <span class="hljs-comment">// 获取 SD 卡的状态</span><br><br><span class="hljs-keyword">if</span> (state.equals(Environment.MEDIA_MOUNTED)) &#123;  <span class="hljs-comment">// 判断 SD 卡是否可用</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">SDPath</span> <span class="hljs-operator">=</span> Environment.getExternalStorageDirectory();    <span class="hljs-comment">// 获取 SD 卡路径</span><br>   <br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SDPath, <span class="hljs-string">&quot;data.txt&quot;</span>);<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Helloworld&quot;</span>;<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        fos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>        fos.write(data.getBytes());<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (fos != <span class="hljs-literal">null</span>) &#123;<br>                fos.close();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="从文件中读取数据">从文件中读取数据</h3><p><strong>读取内部存储文件中的数据</strong></p><p>使用 FileInputStream 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>    fis = openFileInput(<span class="hljs-string">&quot;data.txt&quot;</span>);<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[fis.available()];<br>    fis.read(buffer);<br>    content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer);<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (fis != <span class="hljs-literal">null</span>) &#123;<br>            fis.close();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><br><p><strong>读取外部存储文件中的数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> Environment.getExternalStorageState();<br><span class="hljs-type">File</span> <span class="hljs-variable">SDPath</span> <span class="hljs-operator">=</span> Environment.getExternalStorageDirectory();    <span class="hljs-comment">// 获取SD卡路径</span><br><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SDPath, <span class="hljs-string">&quot;data.txt&quot;</span>);<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>    fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>    br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(fis));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> br.readLine();<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (br != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            br.close();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fis != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fis.close();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><br><h2 id="sharepreferences-存储">SharePreferences 存储</h2><p>SharePreferences 是 Android 上的一个轻量级存储类，当程序中有一些少量的数据需要持久化存储时，可以使用 SharePreferences。</p><h3 id="将数据存入-sharepreferences">将数据存入 SharePreferences</h3><p>使用 SharePreferences 存储数据时，首先需要调用 getSharedPreferences() 方法获取 SharePreferences 的实例对象</p><p>因为该对象本身只能获取数据，不能对数据进行存储和修改，所以需要调用 edit() 方法获取到可编辑的 Edior 对象</p><p>最后通过 Edior 对象的 puxXxx() 方法存储数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 SharePreferences 实例对象</span><br><span class="hljs-type">SharedPreferences</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> getSharedPreferences(<span class="hljs-string">&quot;data&quot;</span>, MODE_PRIVATE);<br><br><span class="hljs-comment">// 获取编辑器</span><br>SharedPreferences.<span class="hljs-type">Editor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> sp.edit();<br><br><span class="hljs-comment">// 存入数据</span><br>editor.putString(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>editor.putInt(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-comment">// 提交</span><br>editor.commit();<br></code></pre></td></tr></table></figure><br><h3 id="读取-删除-sharepreferences-中的数据">读取 / 删除 SharePreferences 中的数据</h3><p><strong>读取数据：</strong></p><p>只需要获取 SharePreferences 对象，然后通过 getXxx() 方法获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SharedPreferences</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> getSharedPreferences(<span class="hljs-string">&quot;data&quot;</span>, MODE_PRIVATE);<br><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> sp.getString(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>第二个参数为缺省值，当 key 值不存在时，返回缺省值</p><br><br><p><strong>删除数据：</strong></p><p>只需要调用 Editor 对象的 remove() 方法或者 clear() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">editor.remove(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">// 删除 key 为&quot;name&quot; 的数据</span><br>editor.clear();<span class="hljs-comment">// 删除所有数据</span><br></code></pre></td></tr></table></figure><p>PS：</p><p>获取数据的 key 值与存入数据的 key 值数据类型要一致，否则查找不到指定数据</p><p>保存 SharedPreferences 的 key 值时，可使用静态常量保存以免操作时写错</p><br><h2 id="sqlite-数据库存储">SQLite 数据库存储</h2><h3 id="创建-sqlite">创建 SQLite</h3><p>先创建一个继承 SQLitePOpenHelper 的类，在重写 onCreate() 方法和 onUpgrade() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SQLiteOpenHelper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyHelper</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, <span class="hljs-string">&quot;itcase.db&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 数据库第一次被创建时调用该方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> &#123;<br>        <span class="hljs-comment">// 初始化表的结构，执行建表的SQL语句</span><br>        db.execSQL(<span class="hljs-string">&quot;CREATE TABLE information(_id INTEGER PRIMARY KEY AUTOINCREMENT, name VARCHAR(20), price INTEGER)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 当数据库的版本号增加时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-type">int</span> oldVersion, <span class="hljs-type">int</span> newVersion)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该方法中通过 super 方法调用父类的构造方法，并传入四个参数</p><p>分别是上下文对象、数据库名称、游标工厂（通常是null）和数据库版本</p><br><h3 id="sqlite-的基本操作">SQLite 的基本操作</h3><p><strong>新增数据</strong></p><p>使用 SQLiteDatabase 类的 insert() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String name, String price)</span> &#123;<br>    <span class="hljs-type">MyHelper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHelper</span>(MainActivity.<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-comment">// 获取可读写的 SQLiteDatabase 对象</span><br>    <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getReadableDatabase();<br><br>    <span class="hljs-comment">// 创建 ContentValues 对象</span><br>    <span class="hljs-type">ContentValues</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br><br>    <span class="hljs-comment">// 将数据添加到 ContentValues 对象中</span><br>    values.put(<span class="hljs-string">&quot;name&quot;</span>, name);<br>    values.put(<span class="hljs-string">&quot;price&quot;</span>, price);<br><br>    <span class="hljs-comment">// 插入一条数据到 information 表中</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> db.insert(<span class="hljs-string">&quot;information&quot;</span>, <span class="hljs-literal">null</span>, values);<br>    <br>    <span class="hljs-comment">// 使用后一定要调用 close() 关闭数据库连接</span><br>    db.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>Insert() 方法可以接受三个参数：</p><p>第一个参数是数据表的名称</p><p>第二个参数表示：如果发现将要插入的行为空行，会将这个列名的值设为null</p><p>第三个参数为 ContentValues 对象</p><br><br><p><strong>删除数据</strong></p><p>使用 SQLiteDatabase 类的 delete() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>    <span class="hljs-type">MyHelper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHelper</span>(MainActivity.<span class="hljs-built_in">this</span>);<br>    <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getWritableDatabase();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> db.delete(<span class="hljs-string">&quot;information&quot;</span>, <span class="hljs-string">&quot;_id=?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;id+<span class="hljs-string">&quot;&quot;</span>&#125;);<br>    db.close();<br>    <span class="hljs-keyword">return</span> number;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除数据时不需要使用 ContentValues  类来添加参数</p><p>而是使用一个字符串和一个字符串数组来添加参数名和参数值</p><br><br><p><strong>修改数据</strong></p><p>使用 SQLiteDatabase 类的 update() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name, String price)</span> &#123;<br>    <span class="hljs-type">MyHelper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHelper</span>(MainActivity.<span class="hljs-built_in">this</span>);<br>    <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getWritableDatabase();<br><br>    <span class="hljs-type">ContentValues</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>    values.put(<span class="hljs-string">&quot;price&quot;</span>, price);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> db.update(<span class="hljs-string">&quot;information&quot;</span>, values, <span class="hljs-string">&quot;name=?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;name&#125;);<br><br>    db.close();<br>    <span class="hljs-keyword">return</span> number;<br>&#125;<br></code></pre></td></tr></table></figure><p>update() 方法传递了四个参数：</p><p>第一个参数表示数据库表的名称</p><p>第二个参数表示最新的数据</p><p>第三个参数是要修改的数据的查找条件</p><p>第四个参数表示查找条件的参数</p><br><br><p><strong>查询数据</strong></p><p>使用 SQLiteDatabase 类的 query() 方法，该方法返回的是一个行数集合 Cursor</p><p>在使用完 Cuesor 后，一点要及时关闭否则会造成内存泄漏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>    <span class="hljs-type">MyHelper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHelper</span>(MainActivity.<span class="hljs-built_in">this</span>);<br>    <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getWritableDatabase();<br><br>    <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> db.query(<span class="hljs-string">&quot;information&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;_id=?&quot;</span>,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;id+<span class="hljs-string">&quot;&quot;</span>&#125;, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">if</span> (cursor.getCount() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Curse 提供了遍历查询的方法</span><br>        <span class="hljs-keyword">while</span> (cursor.moveToNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">_id</span> <span class="hljs-operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;_id&quot;</span>));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;name&quot;</span>));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;price&quot;</span>));<br>        &#125;<br>    &#125;<br>    cursor.close();<br>    db.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>query() 方法包含七个参数</p><p>第一个参数表示表的名称、第二个参数表示询问的列名</p><p>第三个参数表示接收查询条件的子句，第四个参数表示接收查询子句对应的条件值</p><p>第五个参数表示分组方式，第六个参数用于接收 having 条件、第七个参数表示排序方式</p><br><br><p><strong>使用 SQL 语句进行数据库操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加一条数据</span><br>db.execSQL(<span class="hljs-string">&quot;insert into information (name, price) values (?, ?)&quot;</span>, <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;name, price&#125;);<br><br><span class="hljs-comment">// 删除一条数据</span><br>db.execSQL(<span class="hljs-string">&quot;delete from infromation where _id = 1&quot;</span>);<br><br><span class="hljs-comment">// 修改一条数据</span><br>db.execSQL(<span class="hljs-string">&quot;update infromation set name=? where price=?&quot;</span>, <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;name, price&#125;);<br><br><span class="hljs-comment">// 查询</span><br><span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> db.rawQuery(<span class="hljs-string">&quot;select * from information where name=?&quot;</span>, <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;name&#125;);<br></code></pre></td></tr></table></figure><br><h3 id="sqlite-数据库的事务">SQLite 数据库的事务</h3><p>数据库事务是一个对数据库执行工作的单元，是针对数据库的一组操作，它可以由一条或多条 SQL 语句组成</p><p>事务是以逻辑顺序完成的工作单位或序列，可以由用户手动操作完成，也可以由某种数据库程序自动完成</p><br><p>事务的操作比较严格，它必须包括 ACID</p><p>ACID 是指数据库事务正确执行的 4 个基本要素：包括原子性、一致性、隔离性和持久性</p><br><p>eg. 张三取出 1000 元，王五存入 1000 元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyHelper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHelper</span>(MainActivity.<span class="hljs-built_in">this</span>);<br><span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getWritableDatabase();<br><br><span class="hljs-comment">// 开启事务</span><br>db.beginTransaction();<br><span class="hljs-keyword">try</span> &#123;<br>    db.execSQL(<span class="hljs-string">&quot;update information set account = account - 1000 where name=?&quot;</span>,<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;张三&quot;</span>&#125;);<br><br>    db.execSQL(<span class="hljs-string">&quot;update information set account = account + 1000 where name=?&quot;</span>,<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;王五&quot;</span>&#125;);<br><br>    <span class="hljs-comment">// 标记数据库事务执行成功</span><br>    db.setTransactionSuccessful();<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    Log.i(<span class="hljs-string">&quot;事务执行失败&quot;</span>, e.toString());<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>    db.endTransaction();   <span class="hljs-comment">// 关闭事务</span><br>    db.close();            <span class="hljs-comment">// 关闭数据库</span><br>&#125;<br></code></pre></td></tr></table></figure><br><h1 id="内容提供者和内容观察者">内容提供者和内容观察者</h1><p>为了实现跨程序共享数据的功能，Android 提供了一个组件 contentProvider（内容提供者）</p><p>为了观察程序中数据的变化，Android 提供了一个内容观察者</p><br><h2 id="内容提供者">内容提供者</h2><p>若程序之间需要共享数据，则会使用 contentProvider，<strong>contentProvider是Android四大组件之一</strong></p><p>它不仅允许一个程序访问另一个程序，同时还可以选择对哪一部分数据进行共享</p><p>contentProvider 类的实例需要通过 Context 中的 getContentResolve() 方法获取</p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230613214145413.png" alt="image-20230613214145413"></p><p><strong>1.数据模型（Data Model）</strong></p><p>contentProvider 使用基于数据库模型的简单表格来提供需要共享的数据</p><br><br><p><strong>2.Uri</strong></p><p>contentProvider 与 SQLiteDatabase 类似，提供了一系列增、删、改、查的方法对数据进行操作</p><p>不同的是，contentProvider 中的增、删、改、查方法以 Uri 的形式对外提供数据，Uri 为 contentProvider 中的数据建立了唯一的标识符</p><p>Uri 主要由 3 部分组成，分别是 scheme、authority 和 path：</p><ul><li>scheme 是以 “content://&quot; 开头的前级，表示操作的数据被 contentProvider 控制，不会被修改;</li><li>authority 表示为 contentProvider 设置的唯一标识，该标识主要用来区分不同的应用程序</li><li>path 表示资源或数据，当访问者需要操作不同的数据时，该部分可以动态修改</li></ul><br><h2 id="创建内容提供者">创建内容提供者</h2><p>如果想要创建一个内容提供者， 则首先需要创建一个继承抽象类 contentProvider 的类</p><p>接着重写该类中的 onCreate()、insert()、delete()、 update()、 query()、getType()方法</p><br><p>先在程序包名处新建一个 【Content Provider】文件，指定内容提供者的名称和唯一标识（一般为包名）</p><p>内容提供者创建完成后， Android Studio 会在 AndroidManifest.xml 文件中进行注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyContentProvider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;com.example.try01&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><p><provider> 标签中的配置用于注册创建的 MyContentProvider：</provider></p><ul><li>name：该属性的值是 MyContentProvider 的全名称</li><li>authorities：该属性的值标识了 MyContentProvider 提供的数据，该值可以是一个或多个URI authority，多个 authority 名称之间需要用分号隔开，该属性的值通常设置为包名</li><li>enabled：该属性的值表示 MyContentProvider 能否被系统实例化。默认的值为true</li><li>exported：该属性的值表示 MyContentProvider 能否被其他应用程序使用</li></ul><p>PS：每个应用程序中创建的 ContentProvider 都必须在 AndroidManifest.xml 文件的 <provider> 标签中定义</provider></p><br><h2 id="访问其他应用程序的数据">访问其他应用程序的数据</h2><p>在不同应用程序之间交换数据时，应用程序会通过 ContentProvider 暴露自己的数据，并通过 ContentResolver 对程序暴露的数据进行操作，因此 ContentResolver 充当着一个 “中介” 的角色</p><p>因为在使用 ContentProvider 暴露数据时提供了相应操作的 Uri ，所以在访问现有的 ContentProvider 时要指定相应的 Uri，然后再通过 ContentResolver 来实现对数据的操作</p><p>（1）通过 parse() 方法解析 Uri</p><p>首先通过 Uri的 parse() 方法将字符串 Uri 解析为一个 Uri 类型的对象</p><p><code>Uri uri = Uri.parse (&quot;content://cn.itcast.mycontentprovider/person&quot;);</code></p><br><p>（2）通过 query() 方法查询数据</p><p>通过 getContentReolver() 方法获取 CntenResolver 对象，调用该对象的 query() 方法查询数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ContentResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> context.getContentResolver();<br><span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> resolver.query(Uri uri, String[] projection, String selection,<br>                                    String[] selectionArgs, String sortOrder);<br></code></pre></td></tr></table></figure><ul><li>uri：表示查询其他程序的数据时需要的Uri</li><li>projection：表示要查询的内容，该内容相当于数据库表中每列的名称</li><li>selection：表示设置的查询条件，相当于SQL语句中的 where，如果该参数传入的值为 null，则表示没有查询条件</li><li>selectionArgs：该参数需要配合参数 selection 使用，如果参数 selection 中有 “?”，则传递的参数<br>selectionArgs 会替换掉 “?”，否则参数 selectionArgs 传递的值为null</li><li>SortOrder：表示查询的数据按照什么顺序进行排序，默认升序。若想降序，则传递的值为&quot; DESC&quot;</li></ul><br><p>（3）通过 while() 循环语句遍历查询的数据</p><p>通过query() 方法查询数据后，会将该数据存放在 Cursor 对象中</p><p>接着通过 while 循坏语句将 Cursor 对象中的数据遍历出来，最后调用 Cursor 对象的 close() 方法来关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (cursor.moveToNext()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> cursor.getString(<span class="hljs-number">0</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> cursor.getLong(<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> cursor.getInt(<span class="hljs-number">2</span>);<br>&#125;<br>cursor.close();<br></code></pre></td></tr></table></figure><br><h2 id="urimatch-类">UriMatch 类</h2><p>每个 ContentProvider 都会有一个 Uri，当对 ContentProvider 中的数据进行操作时，会通过对应的 Uri 指定相关的数据并进行操作，如果一个 ContentProvider 中含有多个数据源，就需要对不同的 Uri 进行区分，此时可以用 UriMatcher 类对 Uri 进行匹配</p><p>（1）初始化 UriMatcher 类<br>在 ContentProvider 中对 UriMatcher 类进行初始化</p><p><code>UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);</code></p><p>在上述代码中，构造函数 UriMacher 的参数表示 Uri 没有匹配成功的匹配码，该匹配码通常使用 -1 来表示</p><br><p>（2）注册需要的Uri</p><p>将需要用的 Uri 通过 addURI() 方法注册到 UriMacher 对象中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">matcher.addURI(<span class="hljs-string">&quot;cn.itcast.contentprovider&quot;</span>, <span class="hljs-string">&quot;people&quot;</span>, PEOPLE);<br>matcher.addURI(<span class="hljs-string">&quot;cn.itcast.contentprovider&quot;</span>, <span class="hljs-string">&quot;peoson/#&quot;</span>, PEOPLE_ID);<br></code></pre></td></tr></table></figure><p>在上述代码中，addURI() 方法中的第1个参数表示 Uri 的 authority 部分，第2个参数表示 Uri 的 path 部分，第3个参数表示 Uri 匹配成功后返回的匹配码</p><br><p>（3）与已经注册的 Uri 进行匹配</p><p>在 ContentProvider 重写的 query()、insert()、 update()、 delete() 方法中，可以通过 UriMatcher 对象的 match() 方法来匹配 Uri，通过 switch() 循环语句将每个匹配结果区分开，并做相应的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> Uri.parse(<span class="hljs-string">&quot;content://&quot;</span> + <span class="hljs-string">&quot;cn.itcast.contentprovider&quot;</span> + <span class="hljs-string">&quot;/people&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> matcher.match(uri);<br><span class="hljs-keyword">switch</span> (match) &#123;<br><span class="hljs-keyword">case</span> PEOPLE:<br>...<br>    <span class="hljs-keyword">case</span> PEOPLE_ID:<br>    ...<br>   <span class="hljs-keyword">default</span>:<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="内容观察者">内容观察者</h2><p>内容观察者（ContentObserver）用于观察指定 Uri 代表的数据的变化</p><p>当 ContentObserver 观察到指定 Uri 代表的数据发生变化时就触发 ContentObserver 的 onChange() 方法</p><p>此时在 onChange() 方法中使用 ContentResovler 可以查询到变化的数据</p><br><p><strong>创建内容观察者</strong></p><p>在 Android 程序中，创建一个继承 ContentObserver 类的 MyObserver 类并重写构造方法和onChange() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ContentObserver</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObserver</span> <span class="hljs-params">(Handler handler)</span> &#123;<br><span class="hljs-built_in">super</span> (handler);<br>    &#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onChange</span> <span class="hljs-params">(<span class="hljs-type">boolean</span> selfChange)</span> &#123;<br><span class="hljs-built_in">super</span>.onChange(selfChange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，构造方法 MyObserver() 中的 handler 参数可以是主线程中的 Handler 对象，也可以是其他线程中的 Handler 对象。当 MyObserver 类观察到Uri代表的数据发生变化时，程序会回调 onChange() 方法</p><br><br><p><strong>注册内容观察者</strong></p><p>首先通过 getContentResolver() 方法获取 ContentResolver 的对象 resolver</p><p>接着通过该对象 registerContentObserver() 方法来注册创建的内容观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ContentResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> getContentResolver();<br><span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> Uri.parse(<span class="hljs-string">&quot;content://aaa.bbb.ccc&quot;</span>);<br><br><span class="hljs-comment">//注册内容观察者</span><br>resolver.registerContentObserver(uri, <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObserver</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>()));<br></code></pre></td></tr></table></figure><p>registerContentObservert() 方法中：</p><p>第 1 个参数表示内容提供者的Uri</p><p>第 2 个参数表示是否只匹配提供的 Uri，当该参数为 true 时，表示可以匹配 Uri 派生的其他 Uri；为 false 时，表示只匹配当前提供的Uri</p><p>第 3 个参数表示创建的内容观察者</p><br><br><p><strong>取消注册内容观察者</strong><br>当不需要内容观察者时，可以通过 unregisterContentObserver() 方法取消注册</p><p>通常情况下，取消注册的操作会在 Activity 的 onDestroy() 方法中进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>.onDestroy() ;<br>    <br>    <span class="hljs-comment">// 取消注册内容观察者</span><br>getContentResolver().unregisterContentObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObserver</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><br><h1 id="广播机制">广播机制</h1><p>在 Android 中，广 播是一种在组件之间传递消息的机制</p><p>如果要接收并过滤广播中的消息，则需要使用 BroadeastReceiver（广播接收者）</p><p>广播接收者是四大组件之一， 通过广播接收者可以监听系统中的广播消息，实现在不同组件之间的通信</p><br><ul><li>广播接收者通过 Binder 机制在处理中心中进行注册</li><li>广播发送者通过 Binder 机制向 AMS 发送广播</li><li>AMS 查找到符合相应条件的广播接收者，会将广播发送到相应的消息循环队列中</li><li>程序执行消息循环时会获取到此广播，并会回调广播接收者中的 onReceive() 方法进行相关的处理</li><li>对于不同的广播类型与不同的广播接收者的注册方式，广播机制在具体实现上会有不同</li></ul><p>广播发送者和广播接收者分别属于观察者模式中的消息发布和消息订阅两端，AMS 属于中间的处理中心</p><br><p>广播作为 Andoid 组件间的通信方式，可以使用的场景：</p><ul><li>在同一个 App 内部的同一组件内进行消息通信（单个或多个线程之间）</li><li>在同一个 App 内部的不同组件之间进行消息通信（单个进程）</li><li>在同一个 App 具有多个进程的不同组件之间进行消息通信</li><li>在不同App的组件之间进行消息通信</li><li>在特定情况下，Acdroid 与 App 之间进行消息通信</li></ul><br><h3 id="创建广播接收者">创建广播接收者</h3><p>（1）创建一个继承 BroadcastReceiver 的类并重写 onReceiver() 方法</p><p>（2）直接 new 一个【Broadcast Receiver】</p><br><h3 id="注册广播接收者">注册广播接收者</h3><ul><li>动态注册：在 Activity 中通过代码注册</li><li>静态注册：在清单文件中通过配置广播接收者完成注册</li></ul><br><p>（1）动态注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-keyword">private</span> MyBroadcastReceiver receiver;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br><br>        receiver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBroadcastReceiver</span>();<br>        <br>        <span class="hljs-comment">// 实例化过滤器并设置要过滤的 action</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;android.provider.Telephony.SMS_RECEIVED&quot;</span>;<br>        <span class="hljs-type">IntentFilter</span> <span class="hljs-variable">intentFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>();<br>        intentFilter.addAction(action);<br>        <br>        <span class="hljs-comment">// 注册广播</span><br>        registerReceiver(receiver, intentFilter);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br><br>        <span class="hljs-comment">// Activity 销毁时注销广播接收者</span><br>        unregisterReceiver(receiver);<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBroadcastReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BroadcastReceiver</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><br><p>（2）静态注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyReceiver&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><p>静态注册使无论应用程序是否处于运行状态，广播接收者都会对程序进行监听</p><p>PS：Android 8.0 后，静态注册的广播接收者将无法接收广播</p><br><h2 id="自定义广播">自定义广播</h2><p>当系统提供的广播不足以满足需求时，可以自定义广播，并编写对应的广播接收者</p><br><h2 id="广播的类型">广播的类型</h2><p>中提供了两种广播类型，分别是无序广播和有序广播</p><br><p><strong>无序广播</strong></p><p>无序广播是完全异步执行的，发送广播时，所有监听这个广播的广播接收者都会接收到此广播消息</p><p>但接收和执行的顺序不确定。无序广播的效率较高，但无法被拦截</p><br><p><strong>有序广播</strong></p><p>有序广播是按照广播接收者声明的优先级别被依次接收，发送广播时，只会有一个广播接收者能够接收此消息</p><p>在此广播接收者中逻辑执行完毕之后，广播才会继续传递</p><p>相比无序广播，有序广播的广播效率较低，但此类型广播的广播接收者是有先后顺序的，并可被拦截</p><br><p>动态注册广播接收者时，可以使用 IntentFilter 对象的 setPriority() 方法设置优先级别</p><p>setPriority() 方法中传递的值越大，优先级越高</p><p>如果两个广播接收者的优先级相同，则先注册的广播接收者优先级高</p><p>即如果两个程序监听了同一个广播事件，同时设置了相同的优先级，则先安装的程序优先接收</p><br><h1 id="服务">服务</h1><p>通常在程序下载些大文件时，如果程序突然退出，此时下教文件的任务会中断</p><p>此时，我们可以使用 Andrid 提供的服务来下载大文件</p><p>服务是一个长期运行在后台的用户组件，没有用户界面。可以在后台下载文件、 还可以在后合执行很多任务</p><p>Service（服务）是 Android 四大组件之一，是能够在后台长时间执行操作并且不提供用户界面的应用程序组件</p><p>可以与其他组件进行交互，一般由 Activity 启动，但是并不依赖于Activity</p><p>Service 通常被称为“后台服务”，它的应用场景主要有两个，分别是后台运行和跨进程访问</p><br><p><strong>后台运行</strong></p><p>Android 可以在后台长时间进行操作而不用提供界面信息，只有当系统必须要回收内在资源时，才会被销毁</p><br><p><strong>跨进程访问</strong></p><p>当 Serice 被其他应用组件启动时，即使用户切换到其他应用程序，服务仍将在后台继续运行</p><br><h2 id="服务的创建">服务的创建</h2><p>跟 广播接收者 q像，只要先 new 【Service】，然后Android Studio 会自动在清单文件中注册服务</p><p>MyService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Return the communication channel to the service.</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Not yet implemented&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>AndroidManifest.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyService&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><br><h2 id="服务的生命周期">服务的生命周期</h2><p>服务的生命周期与启动方式有关，一种是 startService() 方法，一种是 bindService() 方法</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/436C81EC83753E03FA2244FDCFA112A4.jpg" alt="img"></p><br><ul><li>onCreate()：第一次创建服务时执行的方法</li><li>onStartCommand()：调用 startService() 方法启动服务时执行的方法</li><li>onBind()：调用 bindService() 方法启动服务时执行的方法</li><li>onUnbind()：调用unBindService() 方法断开服务绑定时执行的方法</li><li>onDestory()：服务被销毁时执行的方法</li></ul><p>如果想要停止通过 startService() 方法启动的服务，只需调用 stopService() 方法即可</p><p>如果想要停止通过 bindService() 方法启动的服务，需要调用 unbindService() 方法解绑</p><br><h2 id="服务的启动方式">服务的启动方式</h2><p><strong>通过 startService() 方法：</strong></p><p>在程序中通过调用 startService() 方法启动的服务会长期在后台运行，并且启动服务的组件与服务之间没有关联</p><p>即使启动服务的组件被销毁，服务依旧会运行</p><br><br><p><strong>通过 BindService() 方法</strong></p><p>当一个组件通过调用 binService() 方法启动服务时，服务会与组件绑定，程序允许组件与服务交互。组件一旦退出或者调用 unbindService() 方法解绑服务，服务就会被销毁。多个组件可以绑定一个服务</p><p><code>BindService(Intent service, ServiceConnection conn, int flag)</code></p><br><ul><li>service：用于指定要启动的 Service</li><li>conn：用于监听调用者（服务绑定的组件）与 Service 之间的连接状态<ul><li>连接成功时，程序回调onServiceConnected ( ComponentName name, IBinder service) 方法</li><li>断开连接时，程序回调 onServiceDisconnected ( ComponentName name )方法</li></ul></li><li>flags：表示组件绑定服务时是否自动创建Service<ul><li>参数为0，表示不自动创建</li><li>参数为 “BIND AUTO_ CREATE&quot;，表示自动创建</li></ul></li></ul><br><h2 id="服务的通信">服务的通信</h2><p>有两种，本地服务通信是指应用程序内部的通信，远程服务通信是指两个应用程序之间的通信</p><p>使用这两种方式进行通信时，必须保证服务以绑定方式开启，否则无法进行通信和数据交换</p><br><h1 id="网络编程">网络编程</h1><h2 id="通过-http-访问网络">通过 HTTP 访问网络</h2><p>Android 对 HTTP 通信提供支持，通过标准的 Java 类 HttpURLConnection 便可实现基于 URL 的请求及响应功能。HttpURLConnection 继承自 URLConnection 类，它可以发送和接收任何类型和长度的数据，也可以设置网络请求的方式和超时时间</p><br><p><strong>使用 HttpURLConnection 访问网络</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 URL 的构造方法中传入要访问的资源路径</span><br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;Http://www.itcast.cn&quot;</span>);<br><span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (HttpURLConnection)url.openConnection();<br><br><span class="hljs-comment">// 设置请求方式</span><br>conn.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>);<br><br><span class="hljs-comment">// 设置超时时间</span><br>conn.setConnectTimeout(<span class="hljs-number">5000</span>);<br><br><span class="hljs-comment">// 获取服务器返回的输入流</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> conn.getInputStream();<br><br><span class="hljs-comment">// 关闭 http 链接</span><br>conn.disconnect();<br></code></pre></td></tr></table></figure><p>在使用 HttpURLConnection 访问网络时，通常有两种网络请求方式，“GET” 和 “POST”</p><br><p><strong>GET 方式提交数据</strong></p><p>以实体的方式得到由请求 URL 指向的资源信息，他向服务器提交的参数跟在请求 URL 后面</p><p>所以通过这种方式访问的内容一般要小于 1k</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Http://localhost:8080/web/LoginServlet?username=&quot;</span><br>                 + URLEncoder.encode(<span class="hljs-string">&quot;zhangsan&quot;</span>)<br>                 + <span class="hljs-string">&quot;&amp;password=&quot;</span> + URLEncoder.encode(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(path);<br><span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (HttpURLConnection)url.openConnection();<br><br>conn.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>);<br>conn.setConnectTimeout(<span class="hljs-number">5000</span>);<br><br><span class="hljs-comment">// 获取状态码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">responseCode</span> <span class="hljs-operator">=</span> conn.getResponseCode();<br><br><br><span class="hljs-comment">// 访问码为200表示访问成功</span><br><span class="hljs-keyword">if</span> (responseCode == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> conn.getInputStream();<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>POST 方式提交</strong></p><p>提交时，数据以键值对的形式封装在请求实体中，用户通过浏览器无法看到，比较安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Http://localhost:8080/web/LoginServlet&quot;</span>;<br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(path);<br><span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (HttpURLConnection)url.openConnection();<br>conn.setConnectTimeout(<span class="hljs-number">5000</span>);<br>conn.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br><br><span class="hljs-comment">// 封装要提交的数据</span><br><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;username=&quot;</span> + URLEncoder.encode(<span class="hljs-string">&quot;Zhangsan&quot;</span>)<br>    + <span class="hljs-string">&quot;&amp;password=&quot;</span> + URLEncoder.encode(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">// 指定提交的数据的类型</span><br>conn.setRequestProperty(<span class="hljs-string">&quot;content-Type&quot;</span>, <span class="hljs-string">&quot;application/x-www-from-urlencoded&quot;</span>);<br><br><span class="hljs-comment">// 指定提交的数据的长度</span><br>conn.setRequestProperty(<span class="hljs-string">&quot;content-Length&quot;</span>, data.length() + <span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-comment">// 设置允许向外写数据</span><br>conn.setDoOutput(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 利用输出流将数据写给服务器</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> conn.getOutputStream();<br>os.write(data.getBytes());<br><br><span class="hljs-comment">// 获取状态码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> conn.getResponseCode();<br><br><span class="hljs-keyword">if</span> (code == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> conn.getInputStream();<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="使用-webview-控件">使用 WebView 控件</h2><p><strong>浏览网页：</strong></p><p>Android 默认提供内置浏览器，可以使用 WebView 来实现，可以在 xml 文件中通过 <wenview> 标签来实现，也可以在 java 文件中 new</wenview></p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>loadUrl(String url)</td><td>加载指定 URL 对应的页面</td></tr><tr><td>loadData(String data, String mimeType, String encoding)</td><td>将指定的字符串加载到浏览器中</td></tr><tr><td>loadDataWithBaseURL(String baseUel, String data, String mimeType, String encoding, String historyUrl)</td><td>基于 URL 加载指定的数据</td></tr><tr><td>capturePicture()</td><td>创建当前屏幕的快照</td></tr><tr><td>goBack()</td><td>执行后退操作</td></tr><tr><td>goForward()</td><td>执行前进操作</td></tr><tr><td>stopLoading()</td><td>停止加载当前的页面</td></tr><tr><td>reload()</td><td>刷新当前页面</td></tr></tbody></table><br><br><p><strong>执行 HTML 代码</strong></p><p>WebView 类提供了 loadData() 和 loadDataWithBaseURL() 方法加载 HTML代码</p><p>当使用loadData() 方法来加载带中文的HTML代码时会产生乱码，但是 loadDataWithBaseURL() 方法不会</p><p>loadDataWithBaseURL()</p><p><code>loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl)</code></p><ul><li>baseUrl：用于指定当前页使用的基本URL。如果为 null, 则使用默认的 about:blank</li><li>data：用于指定要显示的字符串数据</li><li>mimeType：用于指定要显示内容的MIME类型。如果为null，则默认使用 text / html</li><li>encoding：用于指定数据的编码方式</li><li>historyUrl: 用于指定当前页的历史URL</li></ul><br><br><p><strong>支持 JavaScript 代码</strong></p><p>首先获取 WebView 控件的 WebSettings 对象，然后调用该对象的 setJavaScriptEnabled() 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vaja">WebSettings settings = webView.getSettings();<br>settings.setJvaScriptEnabled(true);<br></code></pre></td></tr></table></figure><br><p>此时对于大部分的 JavaScrip 代码都可以加载出来。但是对于使用 window.alert() 方法弹出的提示框却加载不出来。可以通过 WenView 控件的 setWebChromeClient() 方法实现</p><p><code>webview.setWebChromeClient(new WebChromeClient());</code></p><br><h2 id="json">JSON</h2><p>是一种新的数据格式，表示一种轻量级的数据交互格式，不能直接显示到程序的界面上，而是要将数据解析为一个集合或对象的形式。有两种表示结构，分别是对象结构和数组结构。</p><br><p><strong>对象结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>key1:value1,<br>key2:value2,<br>...<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>数组结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[<br>value1,<br>value2,<br>...<br>]<br></code></pre></td></tr></table></figure><br><h3 id="json-解析">JSON 解析</h3><p>假设我们有两条 JSON 数据，json1 是对象结构，json2 是数组结构</p><br><p><strong>1. 使用 JSONObject 类和 JSONArray 类解析</strong></p><p>（1）使用 JSONObject 类解析对象结构的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsobObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(json1);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jsonObj.optString(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> jsonObj.optInt(<span class="hljs-string">&quot;age&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">married</span> <span class="hljs-operator">=</span> jsonObj.optBoolean(<span class="hljs-string">&quot;married&quot;</span>);<br></code></pre></td></tr></table></figure><br><p>（2）使用 JSONArray 类解析数组结构的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>(json2);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; jsonArray.length(); i++) &#123;<br><span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsobObj</span> <span class="hljs-operator">=</span> jsonArray.getJSONObject(i);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jsonObj.optString(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> jsonObj.optInt(<span class="hljs-string">&quot;age&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br><br><p><strong>2. 使用 Gson 类解析</strong></p><p>通过 Gson 库的 fronJson() 方法来解析 JSON 数据，在使用 Gson 库前必须创建 JSON 数据对应的实体类，实体类中的成员名称必须和 JSON 数据中的 key 一致</p><br><p>（1）利用 Gson 库解析对象结构的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-type">Person1</span>  <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> gson.fronJson(json1, Person1.class);<br></code></pre></td></tr></table></figure><br><p>（2）利用 Gson 库解析数组结构的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gson</span> <span class="hljs-variable">gson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>();<br><span class="hljs-type">Type</span> <span class="hljs-variable">ListType</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeToken</span>&lt;List&lt;Person2&gt;&gt;()&#123;&#125;.getType();<br>List&lt;Person2&gt; person2 = gson.fronJson(json2, listType); <br></code></pre></td></tr></table></figure><br><h2 id="handler-消息机制">Handler 消息机制</h2><p>Handler 是一种异步回调机制，主要负责与子线程进行通信，主要包括四个关键对象</p><ul><li>Message：在线程之间传递的消息</li><li>Handler：处理者，主要负责 Message 的发送以及处理</li><li>MessageQueue：消息队列，存放 Handler 发送过来的消息，按照先入先出的规则执行</li><li>Looper：不断的从消息队列中抽取消息并传递到 Handler 对象的 handleMessage() 方法中</li></ul><br><h1 id="图形图像处理">图形图像处理</h1><h2 id="常见的绘图类">常见的绘图类</h2><p>Android 中常见的绘图类有  Bitmap 、BitmapFactory、Paint、Canvas 类</p><p>可以分别实现创建位图、将指定资源解析为位图、创建画笔、绘制画布等功能</p><br><h3 id="bitmap">Bitmap</h3><p>用来创建位图，位图就是由图片元素的单个点组成，有像素、长、宽、颜色等描述信息</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>createBitmap(int width, int height, Config config)</td><td>创建位图，width 表示要创建的图片的宽度，height 表示高度，config表示图片的配置信息</td></tr><tr><td>createBitmap(int colors[], int offset, int stride, int width, int height, Config config)</td><td>使用颜色数组创建一个指定宽高的位图，颜色数组的个数为 width * height</td></tr><tr><td>createBitmap(Bitmap src)</td><td>使用源位图创建一个新的位图</td></tr><tr><td>createBitmap(Bitmap source, int x, int y, int width, int height)</td><td>从源位图的指定坐标开始剪切一个指定宽高的图像，用于创建新的位图</td></tr><tr><td>createBitmap(Bitmap source, int x，int y, int width, int height, Matrix m, boolean filter)</td><td>按照 Matrix 规则从源位图的指定坐标开始剪切一个指定宽高的图像</td></tr></tbody></table><p>创建一个 Bitmap 类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Bitmap.<span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> Bitmap.Config.ARGB_8888;<br><span class="hljs-type">Bitmap</span> <span class="hljs-variable">bitmip</span> <span class="hljs-operator">=</span> Bitmap.createBitmap(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, config);<br></code></pre></td></tr></table></figure><br><h3 id="bitmapfactory-类">BitmapFactory 类</h3><p>BitmapFactory 表示位图工厂，主要用于从不同的数据源中解析、创建 Bitmap 对象</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>decodeFile(String pathName)</td><td>将指定路径的文件解码为位图</td></tr><tr><td>decodeStream(InputStream is)</td><td>将指定输入流解码为位图</td></tr><tr><td>decodeResource(Resources res, int id)</td><td>将给定的资源 id 解析为位图</td></tr></tbody></table><p>eg. 要把drawable 文件夹中的 icon.png 图片解码为位图</p><p><code>Bitmap bitmap = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);</code></p><br><h3 id="paint-类">Paint 类</h3><p>表示画笔，主要用于描述图形的颜色和风格，如线宽、颜色、透明度和填充效果等</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>setARGB(int a, int r, int g, int b)</td><td>设置颜色</td></tr><tr><td>setColor(int color)</td><td>设置颜色</td></tr><tr><td>setAlpha(int a)</td><td>设置透明度</td></tr><tr><td>setAntiAlias(boolean aa)</td><td>画笔是否使用抗锯齿功能</td></tr><tr><td>setTextAlign(Align align)</td><td>设置绘制文本时的文本对齐方式，参数值为 Align.CENTER、Align.LEFT、Align.RIGHT</td></tr><tr><td>setTextSize(float textSize)</td><td>设置绘制文本时的文字大小</td></tr><tr><td>setFakeBoldText(boolean fakeBoldText)</td><td>设置绘制文字是否为粗体</td></tr><tr><td>setDither(boolean dither)</td><td>指定是否使用图像抖动处理</td></tr><tr><td>setShadowLayer(float radius, float dx, float dy, int color)</td><td>设置阴影</td></tr><tr><td>setXfermode(Xfermode xfermode)</td><td>设置图像的混合模式</td></tr></tbody></table><p>eg. 设置一个画笔，颜色为红色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Paint</span> <span class="hljs-variable">paint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Paint</span>();<br>paint.setColor(Color.RED);<br></code></pre></td></tr></table></figure><br><h3 id="canvas-类">Canvas 类</h3><p>代表画布，可以绘制各种图形</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>drawRect(Rect r, Paint paint)</td><td>使用画笔绘制矩形</td></tr><tr><td>drawOval(RectF oval, Paint paint)</td><td>使用画笔绘制椭圆形</td></tr><tr><td>drawCircle(float cx, float cy, float radius, Paint paint)</td><td>使用画笔绘制圆形</td></tr><tr><td>drawLine(float startX, float startY, float stopX, float stopY,  Paint paint)</td><td>使用画笔在指定位置画线</td></tr><tr><td>drawRoundRect(RectF rect, float rx, float ry, Paint paint)</td><td>使用画笔绘制圆角矩形</td></tr></tbody></table><br><h2 id="为图像添加特效">为图像添加特效</h2><p>Matrix 类本身不能对图像进行修改，但是他可以与其他 API 结合来控制图形图像的变换</p><table><thead><tr><th>特效</th><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>平移</td><td>setTranslate(float dx, float dy)</td><td>指定图像在x、y轴平移 dx、dy</td></tr><tr><td></td><td>proTranslate(float dx, float dy)</td><td>使用前乘的方式计算在x、y轴移动的距离</td></tr><tr><td></td><td>postTranslate(float dx, float dy)</td><td>使用后乘的方式计算在x、y轴移动的距离</td></tr><tr><td>旋转</td><td>setRotate(float degrees)</td><td>指定图像旋转 degrees 度</td></tr><tr><td></td><td>preRotate(float degrees)</td><td>使用前乘的方式指定图像旋转 degrees 度</td></tr><tr><td></td><td>postRotate(float degrees, float px, float py)</td><td>使用后乘的方式以 px 和 py 为轴心旋转 degrees 度</td></tr><tr><td>缩放</td><td>setScale(float sx, float sy)</td><td>指定图像在x、y轴的缩放比例为 sx 和 xy</td></tr><tr><td></td><td>preScale(float sx, float sy)</td><td>使用前乘的方式计算缩放比</td></tr><tr><td></td><td>postScale(float sx, float sy)</td><td>使用后乘的方式计算缩放比</td></tr><tr><td>倾斜</td><td>setSkew(float kx, float ky)</td><td>指定图像在x、y轴的倾斜值</td></tr><tr><td></td><td>preSkew(float kx, float ky)</td><td>使用前乘的方式计算倾斜值</td></tr><tr><td></td><td>postSkew(float kx, float ky)</td><td>使用后乘的方式计算倾斜值</td></tr></tbody></table><br><h2 id="动画">动画</h2><p>Android 提供了三种动画模式：补间动画、逐帧动画、属性动画</p><br><h3 id="补间动画">补间动画</h3><p>通过对 View 进行一系列的动画操作实现，有四种类型</p><br><p><strong>1. 透明度渐变动画</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">alpha</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:interpolator</span>=<span class="hljs-string">&quot;@android:anim/linear_interpolator&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:repeatMode</span>=<span class="hljs-string">&quot;reverse&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">&quot;infinite&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fromAlpha</span>=<span class="hljs-string">&quot;1.0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:toAlpha</span>=<span class="hljs-string">&quot;0.0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>interpolator：控制动画的变化速度</li><li>repeatMode：指定动画重复的方式</li><li>repeatCount：动画重复次数</li><li>duration：动画播放时长</li><li>fromAlpha / toAlpha：动画开始和结束时的透明度</li></ul><br><p><strong>2. 旋转动画</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rotate</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fromDegrees</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:toDegrees</span>=<span class="hljs-string">&quot;360&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">&quot;50%&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">&quot;50%&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:repeatMode</span>=<span class="hljs-string">&quot;reverse&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">&quot;infinite&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;1000&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>fromDegrees / toDegrees：开始和结束时的角度</li><li>pivotX / pivotY：旋转点的坐标</li></ul><br><p><strong>3. 缩放动画</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scale</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fromXScale</span>=<span class="hljs-string">&quot;1.0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fromYScale</span>=<span class="hljs-string">&quot;1.0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:toXScale</span>=<span class="hljs-string">&quot;0.5&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:toYScale</span>=<span class="hljs-string">&quot;0.5&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">&quot;50%&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">&quot;50%&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">android:repeatMode</span>=<span class="hljs-string">&quot;reverse&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">&quot;infinite&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;3000&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>fromXScale / fromYScale：开始时x、y轴上的缩放系数</li><li>toXScale / toYScale：结束时x、y轴上的缩放系数</li><li>pivotX  / pivotY：缩放点的坐标</li></ul><br><p><strong>4. 平移动画</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">translate</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fromXDelta</span>=<span class="hljs-string">&quot;0.0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fromYDelta</span>=<span class="hljs-string">&quot;0.0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:toXDelta</span>=<span class="hljs-string">&quot;100.0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:toYDelta</span>=<span class="hljs-string">&quot;0.0&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">android:repeatMode</span>=<span class="hljs-string">&quot;reverse&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">&quot;infinite&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;4000&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>fromXDelta / fromYDelta：开始时的坐标</li><li>toXDelta / toYDelta：结束时的坐标</li></ul><br><br><p>补间动画也可以在java代码中编写</p><p>分别使用 AlphaAnimation、RotateAnimation、ScaleAnimation、TranslateAnimation 类来实现上述四种动画效果</p><br><h2 id="逐帧动画">逐帧动画</h2><p>是按照提前准备好的惊涛图像按顺序播放，产生动画效果</p><p>使用时，先在 res/drawable 中创建逐帧动画的 xml 文件，并在该文件的 item 标签中通过设置 <code>android:drawable</code> 与 <code>android:duration</code> 指定需要的图片和显示时间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">animation-list</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@drawable/wifi01&quot;</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">&quot;@drawable/wifi02&quot;</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">animation-list</span>&gt;</span><br></code></pre></td></tr></table></figure><br><p>也可以通过 AnimationDrawable 类在 Java 代码中定义逐帧动画</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        <span class="hljs-type">ImageView</span> <span class="hljs-variable">imageView</span> <span class="hljs-operator">=</span> (ImageView) findViewById(R.id.iv);<br>        <span class="hljs-type">AnimationDrawable</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnimationDrawable</span>();<br><br>        a.addFrame(getResources().getDrawable(R.drawable.img_1), <span class="hljs-number">200</span>);<br>        a.addFrame(getResources().getDrawable(R.drawable.img_2), <span class="hljs-number">200</span>);<br><br>        imageView.setBackground(a);<br>        a.setOneShot(<span class="hljs-literal">false</span>);    <span class="hljs-comment">// 循环播放</span><br>        a.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="属性动画">属性动画</h2><p>一种对属性值不断进行操作的模式</p><p>具体不会</p><h1 id="多媒体应用开发">多媒体应用开发</h1><h2 id="音频播放">音频播放</h2><h3 id="mediaplayer">MediaPlayer</h3><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>setDataSource()</td><td>设置要播放的音频位置</td></tr><tr><td>prepare()</td><td>在开始播放器的准备工作</td></tr><tr><td>start()</td><td>开始或继续播放音频</td></tr><tr><td>pause()</td><td>暂停播放音频</td></tr><tr><td>reset()</td><td>重置</td></tr><tr><td>seekTo()</td><td>从指定位置开始播放音频</td></tr><tr><td>stop()</td><td>停止播放音频且无法再次播放</td></tr><tr><td>release()</td><td>释放资源</td></tr><tr><td>isPlaying()</td><td>判断当前是否在播放音频</td></tr><tr><td>getDuration()</td><td>获取载入音频的时长</td></tr></tbody></table><br><p><strong>1. 实例化 MediaPlayer 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MediaPlayer</span> <span class="hljs-variable">mediaPlayer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaPlayer</span>();<br>mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);<br></code></pre></td></tr></table></figure><p>setAudioStreamType() 的参数表示音频类型</p><ul><li>AudioManager.STREAM_MUSIC：音乐</li><li>AudioManager.STREAM_RING：响铃</li><li>AudioManager.STREAM_ALARM：闹钟</li><li>AudioManager.STREAM_NOTEIFICATION：提示音</li></ul><br><p><strong>2. 设置数据源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置播放应用自带的音频</span><br>mediaPlayer = MediaPlayer.create(MainActivity.<span class="hljs-built_in">this</span>, R.raw.xxx);<br><br><span class="hljs-comment">// 设置播放 SD 卡中的音频</span><br>mediaPlayer.setDataSource(<span class="hljs-string">&quot;SD卡中的音频文件路径&quot;</span>);<br><br><span class="hljs-comment">// 设置播放网络音频文件</span><br>mediaPlayer.setDataSource(<span class="hljs-string">&quot;http://www.xxx.mp3&quot;</span>);<br></code></pre></td></tr></table></figure><p>设置播放网络音频文件时要在清单文件中添加网络访问权限</p><p><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code></p><br><p><strong>3. 播放音频文件</strong></p><p>（1）小音频文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mediaPlayer.prepare();<br>mediaPlayer.start();<br></code></pre></td></tr></table></figure><p>（2）大音频文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">mediaPlayer.prepareAsync();<br>mediaPlayer.setOnPreparedListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaPlayer</span>.OnPreparedListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPrepared</span><span class="hljs-params">(MediaPlayer mediaPlayer)</span> &#123;<br>        mediaPlayer.start();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><br><p><strong>4. 暂停播放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mediaPlayer != <span class="hljs-literal">null</span> &amp;&amp; mediaPlayer.isPlaying()) &#123;<br>    mediaPlayer.pause();<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>5. 重新播放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 播放状态下重播</span><br><span class="hljs-keyword">if</span> (mediaPlayer != <span class="hljs-literal">null</span> &amp;&amp; mediaPlayer.isPlaying()) &#123;<br>    mediaPlayer.seekTo(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 暂停状态下重播</span><br><span class="hljs-keyword">if</span> (mediaPlayer != <span class="hljs-literal">null</span>) &#123;<br>    mediaPlayer.seekTo(<span class="hljs-number">0</span>);<br>    mediaPlayer.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>seekTo() 用于定位播放，如果参数为0，表示从头播放</p><br><p><strong>6. 停止播放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mediaPlayer != <span class="hljs-literal">null</span> &amp;&amp; mediaPlayer.isPlaying()) &#123;<br>    mediaPlayer.stop();<br>    mediaPlayer.release();<br>    mediaPlayer = <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="soundpool">SoundPool</h3><p>音频池，可以同时播放多个短小的音频</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>load()</td><td>加载音频文件</td></tr><tr><td>play()</td><td>播放音频</td></tr><tr><td>pause(int streamID)</td><td>根据id，暂停播放</td></tr><tr><td>resume(int streamID)</td><td>根据id，继续播放</td></tr><tr><td>stop(int streamID)</td><td>根据id，停止播放</td></tr><tr><td>unload(int SoundID)</td><td>卸载id为 soundID 的音频</td></tr><tr><td>release()</td><td>释放资源</td></tr></tbody></table><br><p><strong>1. 创建 SoundPool 类</strong></p><p><code>public SoundPool (int maxStreams, int streamType, int srcQuality)</code></p><ul><li>maxStreams：最多音频数</li><li>streamType：音频类型</li><li>srcQuality：音频质量，默认 0</li></ul><br><p><strong>2. 加载音频文件</strong></p><p>调用 load() 方法来加载</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>public int load(Context context, int resId, int priority)</td><td>通过指定的资源id加载音频文件，resId表示指定的资源id，priority 表示播放声音的优先级</td></tr><tr><td>public int load(String path, int priority )</td><td>通过音频文件的路径加载音频，path表示音频文件的路径</td></tr><tr><td>public int load(AssetFileDescriptor afd, int priority)</td><td>在 AssetFileDescriptor 所对应的文件中加载音频</td></tr><tr><td>public int load ( FileDescriptor fd, long offset, long length, int priority )</td><td>加载 FileDescriptor对 象中从 ofiet 开始长度为 length 的音频</td></tr></tbody></table><br><p><strong>3. 播放音频</strong></p><p><code>play(int soundID, float leftVolume, floatrightVolume, int priority, int loop, float rate)</code></p><ul><li>soundID：要播放的音频id，该音频是通过load() 方法返回的音频</li><li>leftVolume：左声道的音量，取值范围为 0.0~1.0</li><li>rightVolume：右声道的音量，取值范围为 0.0~1.0</li><li>priorty：播放音频的优先级，数值越大，优先级越高</li><li>loop：循环播放的次数，0表示不循环，-1表示循环</li><li>rate：播放速率，1 表示正常播放速率，0.5 表示最低播放速率，2表示最高播放速率</li></ul><br><h2 id="视频播放">视频播放</h2><h3 id="videoview">VideoView</h3><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>setVideoPath()</td><td>设置要播放的视频文件的位置</td></tr><tr><td>start()</td><td>开始或继续播放视频</td></tr><tr><td>pause()</td><td>暂停播放视频</td></tr><tr><td>resume()</td><td>重播</td></tr><tr><td>seekTo()</td><td>从指定位置开始播放视频</td></tr><tr><td>isPlaying()</td><td>判断当前是否正在播放视频</td></tr><tr><td>grtDuration()</td><td>获取载入的视频时长</td></tr></tbody></table><br><p><strong>1. 在布局文件中添加 VideoView 控件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">VideoView</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/videoview&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><br><p><strong>2. 视频的播放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">VideoView</span> <span class="hljs-variable">videoView</span> <span class="hljs-operator">=</span> (VideoView) findViewById(R.id.videoview);<br><span class="hljs-comment">// 播放本地视频</span><br>videoView.setVideoPath(<span class="hljs-string">&quot;...&quot;</span>);<br><br><span class="hljs-comment">// 播放网络视频</span><br>videoView.setVideoURI(Uri.parse(<span class="hljs-string">&quot;http://www.xxx.avi&quot;</span>));<br></code></pre></td></tr></table></figure><p>设置播放网络视频文件时要在清单文件中添加网络访问权限</p><p><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code></p><br><p><strong>3. 为 VideoView 添加控制器</strong></p><p>使用 VideoView 播放视频时，可以通过 setMediaController() 添加一个媒体控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MediaController</span> <span class="hljs-variable">controller</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaController</span>(context);<br>videoView.setMediaController(controller);<br></code></pre></td></tr></table></figure> <br><h3 id="mediaplayer-surfaceview">MediaPlayer / SurfaceView</h3><p>将 MediaPlayer 和 SurfaceView 结合使用。MediaPlayer播放视频，SurfaceView 显示图像</p><p>可以避免因画图任务繁重而造成主线程阻塞，从而提高程序的性能</p><br><p><strong>1. 在布局中添加 SurfaceView 控件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">SurfaceView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/surfaceview&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><br><p><strong>2. 获取界面控件并设置类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SurfaceView</span> <span class="hljs-variable">surfaceView</span> <span class="hljs-operator">=</span> (SurfaceView) findViewById(R.id.surfaceview);<br><span class="hljs-type">SurfaceHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> surfaceView.getHolder();<br>holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);<br></code></pre></td></tr></table></figure><br><p><strong>3. 回调 addCallback() 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">holder.addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SurfaceHolder</span>.Callback() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">surfaceCreated</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SurfaceHolder surfaceHolder)</span> &#123;<br>        Log.i(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;surface创建好了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">surfaceChanged</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SurfaceHolder surfaceHolder, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2)</span> &#123;<br>        Log.i(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;surface的大小发生变化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">surfaceDestroyed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> SurfaceHolder surfaceHolder)</span> &#123;<br>        Log.i(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;surface被销毁了&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><br><p><strong>4. 播放视频</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MediaPlayer</span> <span class="hljs-variable">mediaPlayer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaPlayer</span>();<br>mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);<br><br>mediaPlayer.setDataSource(<span class="hljs-string">&quot;视频资源路径&quot;</span>);<br><br><span class="hljs-comment">// SurfaceView 与 MediaPlayer 进行关联</span><br>mediaPlayer.setDisplay(holder);<br><br><span class="hljs-comment">// 将视频文件解析到内存之中</span><br>mediaPlayer.prepareAsync();<br>mediaPlayer.start();<br></code></pre></td></tr></table></figure><br></font>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】MySQL</title>
      <link href="/post/c24675b4.html"/>
      <url>/post/c24675b4.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><h1 id="sql">SQL</h1><p>全称 Structured Query Language，结构化查询语言。</p><p>操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准</p><br><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL</p><ul><li>DDL：数据定义语言，用来定义数据库对象（数据库，表， 字段）</li><li>DML：数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL：数据查询语言，用来查询数据库中表的记录</li><li>DCL：数据控制语言，用来创建数据库用户、控制数据库的访问权限</li></ul><br><h2 id="mysql的数据类型">MySQL的数据类型</h2><p>（1）数值类型</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小(byte)</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">TINYINT</td><td style="text-align:center">1</td><td style="text-align:center">小整数</td></tr><tr><td style="text-align:center">SMALLINT</td><td style="text-align:center">2</td><td style="text-align:center">大整数</td></tr><tr><td style="text-align:center">MEDIUMINT</td><td style="text-align:center">3</td><td style="text-align:center">大整数</td></tr><tr><td style="text-align:center">INT/INTEGE</td><td style="text-align:center">4</td><td style="text-align:center">大整数</td></tr><tr><td style="text-align:center">BIGINT</td><td style="text-align:center">8</td><td style="text-align:center">极大整数</td></tr><tr><td style="text-align:center">FLOAT</td><td style="text-align:center">4</td><td style="text-align:center">单精度浮点数</td></tr><tr><td style="text-align:center">DOUBLE</td><td style="text-align:center">8</td><td style="text-align:center">双精度浮点数</td></tr><tr><td style="text-align:center">DECIMAL</td><td style="text-align:center"></td><td style="text-align:center">小数</td></tr></tbody></table><br><p>（2）字符串类型</p><table><thead><tr><th>类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>CHAR</td><td style="text-align:left">定长字符串(需要指定长度)</td></tr><tr><td>VARCHAR</td><td style="text-align:left">变长字符串(需要指定长度)</td></tr><tr><td>TINYBLOB</td><td style="text-align:left">不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td style="text-align:left">短文本字符串</td></tr><tr><td>BLOB</td><td style="text-align:left">二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td style="text-align:left">长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td style="text-align:left">二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td style="text-align:left">中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td style="text-align:left">二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td style="text-align:left">极大文本数据</td></tr></tbody></table><p>char 与 varchar 都可以描述字符串</p><p>char 是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关</p><p>而 varchar 是变长字符串，指定的长度为最大占用长度 。相对来说，char 的性能会更高些</p><br><p>（3）日期时间类型</p><table><thead><tr><th>类型</th><th>大小</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>DATA</td><td>3</td><td>YYYY-MM-DD</td><td>日期</td></tr><tr><td>TIME</td><td>3</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>YYYY</td><td>年份</td></tr><tr><td>DATETIME</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td><td>时间戳</td></tr></tbody></table><br><h2 id="ddl">DDL</h2><p>数据定义语言，用来定义数据库对象（数据库，表， 字段）</p><br><h3 id="数据库操作">数据库操作</h3><p>（1）查询所有数据库</p><p><code>show databases;</code></p><br><p>（2）查询当前数据库</p><p><code>select databases();</code></p><br><p>（3）创建数据库</p><p><code>create database [ if not exists ] 数据库名 [ 字符集 ] [ 排序规则 ];</code></p><br><p>（4）删除数据库</p><p><code>drop database [ if exists ] 数据库名;</code></p><br><p>（5）切换数据库</p><p><code>use 数据库名;</code></p><br><h3 id="表操作">表操作</h3><h4 id="表操作-查询">表操作 - 查询</h4><p>（1）查询当前数据库所有的表（需要先进入该数据库）</p><p><code>show tables;</code></p><br><p>（2）查看指定表结构</p><p><code>desc 表名;</code></p><br><p>（3）查询指定表的建表语句</p><p><code>show create table 表名;</code></p><br><p>（4）创建表结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(<br>字段1 字段1类型 [ COMMENT 字段1注释 ],<br>字段2 字段2类型 [ COMMENT 字段2注释 ],<br>字段3 字段3类型 [ COMMENT 字段3注释 ],<br>......<br>字段n 字段n类型 [ COMMENT 字段n注释 ]<br>) [COMMENT 表注释] ;<br></code></pre></td></tr></table></figure><br><p>eg. 设计一张员工信息表，要求如下：</p><ol><li>编号（纯数字）</li><li>员工工号（字符串类型，长度不超过10位）</li><li>员工姓名（字符串类型，长度不超过10位）</li><li>性别（男 / 女，存储一个汉字）</li><li>年龄（正常人年龄，不可能存储负数）</li><li>身份证号（二代身份证号均为18位，身份证中有 X 这样的字符）</li><li>入职时间（取值年月日即可）</li></ol><br><p>对应的建表语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table emp (<br>    id        int comment &#x27;编号&#x27;,<br>    workno    varchar(10) comment &#x27;工号&#x27;,<br>    name      varchar(10) comment &#x27;姓名&#x27;,<br>    gender    char(1) comment &#x27;性别&#x27;,<br>    age       tinyint unsigned comment &#x27;年龄&#x27;,<br>    idcard    char(18) comment &#x27;身份证号&#x27;,<br>    entrydate date comment &#x27;入职时间&#x27;<br>) comment &#x27;员工表&#x27;;<br></code></pre></td></tr></table></figure><br><h4 id="表操作-修改">表操作 - 修改</h4><p>（1）添加字段</p><p><code>alter table 表名 add 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></p><br><p>（2）修改数据类型</p><p><code>alter table 表名 modify 字段名 新数据类型 (长度);</code></p><br><p>（3）修改字段名和字段类型</p><p><code>alter table 表名 change 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></p><br><p>（4）删除字段</p><p><code>alter table 表名 drop 字段名;</code></p><br><p>（5）修改表名</p><p><code>alter table 表名 rename to 新表名;</code></p><br><h4 id="表操作-删除">表操作 - 删除</h4><p>（1）删除表</p><p><code>drop table [ IF EXISTS ] 表名</code></p><p>可选项 IF EXISTS 代表只有表名存在时才会删除该表，表名不存在则不执行删除操作</p><p>如果不加该参数项，删除一张不存在的表，执行将会报错</p><br><p>（2）删除指定表，并重新创建表</p><p><code>truncate table 表名;</code></p><br><h2 id="dml">DML</h2><p>数据操作语言，用来对数据库表中的数据进行增删改</p><br><h3 id="添加数据">添加数据</h3><p>（1）给指定字段添加数据</p><p><code>insert into 表名 (字段名1, 字段名2, ...) values (值1, 值2, ...);</code></p><br><p>（2）给全部字段添加数据</p><p><code>insert into 表名 values (值1, 值2, ...);</code></p><br><p>（3）批量添加数据</p><p><code>insert into 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值 1, 值2, ...);</code></p><br><p><code>insert into 表名 values (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></p><br><p><strong>PS：</strong></p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的</li><li>字符串和日期型数据应该包含在引号中</li><li>插入的数据大小，应该在字段的规定范围内</li></ul><br><h3 id="修改元素">修改元素</h3><p>修改数据的基本语法：</p><p><code>update 表名 set 字段名1 = 值1, 字段名2 = 值2, .... [ WHERE 条件 ];</code></p><br><p>eg. 将所有的员工入职日期修改为 2008-01-01</p><p><code>update employee set entrydate = '2008-01-01';</code></p><br><p>PS：修改语句的条件可以有，也可以没有。如果没有条件，则会修改整张表的所有数据</p><br><h3 id="删除数据">删除数据</h3><p>删除数据的基本语法：</p><p><code>delete from 表名 [ while 条件 ];</code></p><br><p><strong>PS：</strong></p><ul><li><p>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据</p></li><li><p>DELETE 语句不能删除某一个字段的值（可以使用 UPDATE，将该字段值置为 NULL ）</p></li><li><p>当进行删除全部数据操作时，datagrip 会询问是否确认删除，直接点击 Execute 即可</p></li></ul><br><h2 id="dql">DQL</h2><p>数据查询语言，数据查询语言，用来查询数据库中表的记录</p><br><p>DQL 查询语句的语法结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>字段列表<br>FROM<br>表名列表<br>WHERE<br>条件列表<br>GROUP BY<br>分组字段列表<br>HAVING<br>分组后条件列表<br>ORDER BY<br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></table></figure><br><h3 id="基础查询">基础查询</h3><p>不带任何的查询条件，查询的语法为：</p><p>（1）查询多个字段</p><p><code>select 字段1, 字段2, 字段3 ... from 表名;</code></p><p><code>select * from 表名;</code>   代表查询所有字段</p><br><p>（2）字段设置别名</p><p><code>select 字段1 [ as 别名1 ], 字段2 [ as 别名2 ] ... from 表名;</code></p><p><code>select 字段1 [ 别名1 ], 字段2 [ 别名2 ] ... from 表名;</code></p><p>PS：一旦为表起了别名，就不能再使用表名来指定对应的字段了，只能够使用别名来指定字段</p><br><p>（3）去除重复记录</p><p><code>select distinct 字段列表 from 表名</code></p><p>eg. 查询公司员工的上班地址有哪些（不要重复）</p><p><code>select distinct workaddress '工作地址' from emp;</code></p><br><h3 id="条件查询">条件查询</h3><p>语法：</p><p><code>select 字段列表 from 表名 where 条件列表;</code></p><br><p><strong>条件：</strong></p><p>（1）常用的比较运算符</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !=</td><td>不等于</td></tr><tr><td>between … and …</td><td>在某个范围之内（含最大最小值）</td></tr><tr><td>in(…)</td><td>在 in 之后的列表中</td></tr><tr><td>like 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>is null</td><td>是空</td></tr></tbody></table><br><p>（2）常用的逻辑运算符</p><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>and 或 &amp;&amp;</td><td>并且</td></tr><tr><td>or 或 ||</td><td>或者</td></tr><tr><td>not 或 !</td><td>非</td></tr></tbody></table><br><h3 id="聚合函数">聚合函数</h3><p>将一列数据作为一个整体，进行纵向计算</p><br><p>常见的聚合函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><br><p>语法：</p><p><code>select 聚合函数(字段列表) from 表名;</code></p><p>PS：NULL值不参与所有聚合函数的运算</p><br><h3 id="分组查询">分组查询</h3><p>语法：</p><p><code>select 字段列表 from 表名 [ where 条件 ] group by 分组字段名 [having 过滤后条件];</code></p><br><p>where 与 having 区别：</p><p>（1）执行时机不同：</p><p>where 是分组之前进行过滤，不满足 where 条件，不参与分组，having 是分组之后对结果进行过滤</p><p>（2） 判断条件不同：</p><p>where 不能对聚合函数进行判断，而 having 可以</p><br><p>eg. 根据性别分组 , 统计男性员工 和 女性员工的数量</p><p><code>select gender, count(*) from emp group by gender;</code></p><br><h3 id="排序查询">排序查询</h3><p>语法：</p><p><code>select 字段列表 from 表名 order by 字段1 排序方式1, 字段2 排序方式2;</code></p><br><p>排序方式：</p><ul><li>ASC：升序（默认值）</li><li>DESC：降序</li></ul><p>PS：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><br><h3 id="分页查询">分页查询</h3><p>语法：</p><p><code>select 字段列表 from 表名 limit 起始索引, 查询记录数;</code></p><br><p>PS：</p><p>起始索引从 0 开始，起始索引 = （查询页码 - 1）* 每页显示记录数</p><p>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL 中是 limit</p><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10</p><br><p>eg1. 查询第1页员工数据, 每页展示10条记录</p><p><code>select * from emp limit 10;</code></p><p>eg2. 查询第2页员工数据，每页展示10条记录</p><p><code>select * from emp limit 10, 10;</code></p><br><h3 id="执行顺序">执行顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FROM<br>表名列表<br>WHERE<br>条件列表<br>GROUP BY<br>分组字段列表<br>HAVING<br>分组后条件列表<br>SELECT<br>字段列表<br>ORDER BY<br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></table></figure><br><h2 id="dcl">DCL</h2><p>数据控制语言，用来管理数据库用户、控制数据库的访问权限</p><br><h3 id="管理用户">管理用户</h3><p>（1）查询用户</p><p><code>select *  from mysql.user;</code></p><br><p>（2）创建用户</p><p><code>create user '用户名'@'主机名' identified by '密码';</code></p><br><p>（3）修改用户密码</p><p><code>alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';</code></p><br><p>（4）删除用户</p><p><code>drop user '用户名'@'主机名';</code></p><br><h3 id="权限管理">权限管理</h3><p>MySQL 中定义了很多种权限，但是常用的就以下几种：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>all, all privileges</td><td>所有权限</td></tr><tr><td>select</td><td>查询数据</td></tr><tr><td>insert</td><td>插入数据</td></tr><tr><td>update</td><td>修改数据</td></tr><tr><td>delete</td><td>删除数据</td></tr><tr><td>alter</td><td>修改表</td></tr><tr><td>drop</td><td>删除数据库 / 表 / 视图</td></tr><tr><td>create</td><td>创建数据库 / 表</td></tr></tbody></table><br><p>（1）查询权限</p><p><code>show grants for '用户名'@'主机名';</code></p><br><p>（2）授予权限</p><p><code>grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';</code></p><br><p>（3）撤销权限</p><p><code>revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';</code></p><br><p>PS：</p><ul><li>多个权限之间，使用逗号分隔</li><li>授权时，数据库名和表名可以使用 * 进行通配，代表所有</li></ul><br><p>eg. 撤销 ‘heima’@‘%’ 用户的itcast数据库的所有权限</p><p><code>revoke all on itcast.* from 'heima'@'%';</code></p><br><h1 id="函数">函数</h1><p>MySQL 中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数</p><br><h2 id="字符串函数">字符串函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>concat (s1, s2, … sn)</td><td>字符串拼接，将 S1，S2，… Sn 拼接成一个字符串</td></tr><tr><td>lower (str)</td><td>将字符串str全部转为小写</td></tr><tr><td>upper (str)</td><td>将字符串str全部转为大写</td></tr><tr><td>lpad (str, n, pad)</td><td>左填充，用字符串 pad 对 str 的左边进行填充，达到 n 个字符串长度</td></tr><tr><td>rpad (str, n, pad)</td><td>右填充，用字符串 pad 对 str 的右边进行填充，达到 n 个字符 串长度</td></tr><tr><td>trim (str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>substring (str, start, len)</td><td>返回从字符串 str 从 start 位置起的 len 个长度的字符串</td></tr></tbody></table><br><h2 id="数值函数">数值函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>cell (x)</td><td>向上取整</td></tr><tr><td>floor (x)</td><td>向下取整</td></tr><tr><td>mod (x, y)</td><td>返回 x/y 的模</td></tr><tr><td>rand ()</td><td>返回 0~1 内的随机数</td></tr><tr><td>round (x, y)</td><td>求参数 x 的四舍五入的值，保留 y 位小数</td></tr></tbody></table><br><h2 id="日期函数">日期函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>curdate ()</td><td>返回当前日期</td></tr><tr><td>curtime ()</td><td>返回当前时间</td></tr><tr><td>now ()</td><td>返回当前日期和时间</td></tr><tr><td>year (date)</td><td>获取指定date的年份</td></tr><tr><td>month (date)</td><td>获取指定date的月份</td></tr><tr><td>day (date)</td><td>获取指定date的日期</td></tr><tr><td>date_add (date, expr)</td><td>返回一个日期/时间值加上一个时间间隔 expr 后的时间值</td></tr><tr><td>datediff (date1, date2)</td><td>返回起始时间 date1 和 结束时间 date2 之间的天 数</td></tr></tbody></table><br><h2 id="流程函数">流程函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>if (value, t, f)</td><td>如果 value 为 true，则返回 t，否则返回 f</td></tr><tr><td>ifnull (value1, value2)</td><td>如果value1不为空，返回 value1，否则返回 value2</td></tr><tr><td>case when [val1] then [res1] … else [default] end</td><td>如果 val1 为 true，返回 res1，… 否则返回 default 默认值</td></tr><tr><td>case [expr] when [val1] then [res1] … else [default] end</td><td>如果 expr 的值等于 val1，返回 res1，… 否则返回 default 默认值</td></tr></tbody></table><p>eg. 查询 emp 表的员工姓名和工作地址（北京/上海 ----&gt; 一线城市，其他 ----&gt; 二线城市）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select name,<br>       (case workaddress<br>            when &#x27;北京&#x27; then &#x27;一线城市&#x27;<br>            when &#x27;上海&#x27; then &#x27;一线城市&#x27;<br>            else<br>                &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;<br>from emp;<br></code></pre></td></tr></table></figure><br><h1 id="约束">约束</h1><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据</p><p>目的：保证数据库中数据的正确、有效性和完整性</p><p>分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>default</td></tr><tr><td>检查约束</td><td>保证字段值满足某一个条件</td><td>check</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致 性和完整性</td><td>foreign key</td></tr></tbody></table><br><p>eg. 根据如下需求，完成表结构的创建：</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230608164232914.png" alt="image-20230608164232914"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE tb_user (<br>    id     int AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;ID唯一标识&#x27;,<br>    name   varchar(10) NOT NULL UNIQUE COMMENT &#x27;姓名&#x27;,<br>    age    int check (age &gt; 0 &amp;&amp; age &lt;= 120) COMMENT &#x27;年龄&#x27;,<br>    status char(1) default &#x27;1&#x27; COMMENT &#x27;状态&#x27;,<br>    gender char(1) COMMENT &#x27;性别&#x27;<br>);<br></code></pre></td></tr></table></figure><p>在为字段添加约束时，我们只需要在字段之后加上约束的关键字即可</p><br><h2 id="外键约束">外键约束</h2><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性</p><br><p>（1）添加外键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名 (<br>字段名 数据类型,<br>...<br>[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)<br>);<br></code></pre></td></tr></table></figure><p><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ;</code></p><br><p>eg. 为 emp 表的 dept_id 字段添加外键约束，关联 dept 表的主键 id</p><p><code>alter table emp add constraint test foreign key (dept_id) references dept (id);</code></p><br><p>（2）删除外键</p><p><code>alter table 表名 drop foreign key 外键名称;</code></p><br><br><p><strong>删除/更新行为：</strong></p><p>添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为</p><p>具体的删除/更新行为有以下几种：</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>no action</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（默认行为）</td></tr><tr><td>restrict</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与 no action 一致）</td></tr><tr><td>cascade</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td></tr><tr><td>set null</td><td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为 null（要求该外键允许取 null）</td></tr><tr><td>set default</td><td>父表有变更时，子表将外键列设置成一个默认的值（Innodb不支持）</td></tr></tbody></table><br><p>语法：</p><p><code>alter table 表名 add constraint 外键名称 foreign key (外键字段) references 主表名 (主表字段名) on update [cascade] on delete [cascade];</code></p><br><h1 id="多表查询">多表查询</h1><p>由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><p>（1）一对多（多对一）</p><ul><li>关系：一个部门对应多个员工，一个员工对应一个部门</li><li>实现：在多的一方建立外键，指向另一方的主键</li></ul><br><p>（2）多对多</p><ul><li>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</li><li>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul><br><p>（3）一对一</p><ul><li>关系：多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另 一张表中，以提升操作效率</li><li>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（unique）</li></ul><br><br><h2 id="多表查询概述">多表查询概述</h2><p>多表查询就是指从多张表中查询数据</p><p>我们要执行多表查询，就只需要使用逗号分隔多张表即可，如：<code>select * from emp , dept ;</code></p><br><p>默认情况下两个表一起查询我们会得到所有的组合情况，这种现象为<strong>笛卡尔积</strong></p><p>笛卡尔积：是指在数学中，集合 A 和集合 B 的所有组合情况</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230608170506180.png" alt="image-20230608170506180"></p><p>在SQL语句中，我们可以给多表查询加上连接查询的条件来去除无效的笛卡尔积</p><br><p><strong>分类：</strong></p><ul><li>连接查询<ul><li>内连接：相当于查询A、B交集部分数据</li><li>外连接：<ul><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ul></li><li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul></li><li>子查询</li></ul><br><h2 id="内连接">内连接</h2><p>内连接查询的是两张表交集部分的数据</p><br><p>（1）隐式内连接</p><p><code>select 字段列表 from 表1, 表2, where 条件 ... ;</code></p><br><p>（2）显示内连接</p><p><code>select 字段列表 from 表1 [ inner ] join 表2 on 连接条件 ... ;</code></p><br><h2 id="外连接">外连接</h2><p>外连接分为两种，分别是：左外连接 和 右外连接</p><br><p>（1）左外连接</p><p><code>select 字段列表 from 表1 left [ outer] join 表2 on 条件 ... ;</code></p><br><p>（2）右外连接</p><p><code>select 字段列表 from 表1 right [ outer ] join 表2 on 条件 ... ;</code></p><br><p>PS：</p><p>左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中表结构的先后顺序就可以了。</p><p>而我们在日常开发使用时，更偏向于左外连接</p><br><h2 id="自连接">自连接</h2><p>自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次</p><br><p>语法：</p><p><code>select 字段列表 from 表1 别名1 join 表1 别名2 on 条件 ... ;</code></p><br><p>在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，是哪一张表的字段</p><br><h2 id="联合查询">联合查询</h2><p>对于 union 查询，就是把多次查询的结果合并起来，形成一个新的查询结果集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表A ...<br>UNION [ ALL ]<br>SELECT 字段列表 FROM 表B ....;<br></code></pre></td></tr></table></figure><ul><li><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致</p></li><li><p>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重</p></li></ul><br><p>eg. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from emp where salary &lt; 5000<br>union all<br>select * from emp where age &gt; 50;<br></code></pre></td></tr></table></figure><br><h2 id="子查询">子查询</h2><p>SQL 语句中嵌套 SELECT 语句，称为嵌套查询，又称子查询</p><p><code>select * from t1 where column1 = ( select column1 from t2 ) ;</code></p><p>子查询外部的语句可以是 insert/ update/ delete/ select 的任何一个</p><br><p>根据子查询结果不同，分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><br><p>根据子查询位置，分为：</p><ul><li>where 之后</li><li>from 之后</li><li>select 之后</li></ul><br><p><strong>标量子查询：</strong></p><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式</p><br><p>eg. 根据 “销售部” 部门 ID，查询员工信息</p><p><code> select * from emp where dept_id = (select id from dept where name = '销售部');</code></p><br><br><p><strong>列子查询：</strong></p><p>子查询返回的结果是一列（可以是多行）</p><p>常用的操作符：IN 、NOT IN、ANY、SOME、ALL</p><br><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与 ANY 等同，使用 SOME 的地方都可以使用 ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><br><p>eg. 查询 “销售部” 和 “市场部” 的所有员工信息</p><p><code>select * from emp where dept_id in (select id from dept where name = '销售部' or name = '市场部');</code></p><br><br><p><strong>行子查询：</strong></p><p>子查询返回的结果是一行（可以是多列）</p><br><p>eg. 查询与 “张无忌” 的薪资及直属领导相同的员工信息</p><p>（1）查询 “张无忌” 的薪资及直属领导</p><p><code>select salary, managerid from emp where name = '张无忌';</code></p><p>（2）查询与 “张无忌” 的薪资及直属领导相同的员工信息</p><p><code>select * from emp where (salary, managerid) = (select salary, managerid from emp where name = '张无忌');</code></p><br><br><p><strong>表子查询：</strong></p><p>子查询返回的结果是多行多列</p><br><p>eg. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><p>（1）查询 “鹿杖客” , “宋远桥” 的职位和薪资</p><p><code>select job, salary from emp where name = '鹿杖客' or name = '宋远桥';</code></p><p>（2）查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><p><code>select * from emp where (job, salary) in ( select job, salary from emp where name = '鹿杖客' or name = '宋远桥' );</code></p><br><h1 id="事务">事务</h1><p>事务是一组操作的集合，它是一个不可分割的工作单位</p><p>事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求</p><p>即这些操作要么同时成功，要么同时失败</p><br><h2 id="事务操作">事务操作</h2><p>（1）查看 / 设置事务提交方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select @@autocommit ;<br>set @@autocommit = 0 ;<br></code></pre></td></tr></table></figure><br><p>（2）提交事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">commit;<br></code></pre></td></tr></table></figure><br><p>（3）回滚事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">rollback;<br></code></pre></td></tr></table></figure><br><p>（4）开始事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction 或 begin ;<br></code></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 开启事务<br>start transaction<br><br><br>-- 1. 查询张三余额<br>select * from account where name = &#x27;张三&#x27;;<br><br>-- 2. 张三的余额减少1000<br>update account set money = money - 1000 where name = &#x27;张三&#x27;;<br><br>-- 3. 李四的余额增加1000<br>update account set money = money + 1000 where name = &#x27;李四&#x27;;<br><br><br>-- 如果正常执行完毕, 则提交事务<br>commit;<br>-- 如果执行过程中报错, 则回滚事务<br>-- rollback;<br></code></pre></td></tr></table></figure><br><h2 id="事务特性">事务特性</h2><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><p>上述就是事务的四大特性，简称ACID</p><br><h2 id="并发事务问题">并发事务问题</h2><p>（1）赃读：一个事务读到另外一个事务还没有提交的数据</p><p>（2）不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同</p><p>（3） 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”</p><br><h2 id="事务隔离">事务隔离</h2><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230608180346966.png" alt="image-20230608180346966"></p><br><p>（1）查看事务隔离级别</p><p><code>select @@TRANSACTION_ISOLATION;</code></p><br><p>（2）设置事务隔离级别</p><p><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123; READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125; ;</code></p><br><p>PS：事务隔离级别越高，数据越安全，但是性能越低</p><br><h1 id="索引">索引</h1><p>索引（index）是帮助 MySQL 高效获取数据的数据结构（有序）</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构</p><p>这些数据结构以某种方式引用（指向）数据</p><p>这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p><br><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库 的IO成本</td><td>索引列也是要占用空间的</td></tr><tr><td>通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消耗</td><td>索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行 INSERT、UPDATE、DELETE时，效率降低</td></tr></tbody></table><br><h2 id="索引结构">索引结构</h2><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</td></tr><tr><td>R-tree</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，使用较少</td></tr><tr><td>Full-text</td><td>是一种通过建立倒排索引，快速匹配文档的方式</td></tr></tbody></table><br><p>我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引</p><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>支持</td><td>支持</td><td>不支持</td></tr></tbody></table><br><h2 id="索引分类">索引分类</h2><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><br><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引</td><td>将数据存储与索引放到了一块，叶子节点保存了行数据</td><td>必须有且只有一个</td></tr><tr><td>二级索引</td><td>将数据与索引分开存储，叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则：</p><p>如果存在主键，主键索引就是聚集索引。</p><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p><p>如果表没有主键，或没有合适的唯一索引，则 InnoDB会 自动生成一个 rowid 作为隐藏的聚集索引</p><br><p>回表查询：先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据</p><br><p>以下两条SQL语句，那个执行效率高？</p><p><code>A. select * from user where id = 10 ;</code></p><p><code>B. select * from user where name = 'Arm' ;</code></p><br><p>A 语句的执行性能要高于B 语句</p><p>因为 A 语句直接走聚集索引，直接返回数据</p><p>而 B 语句需要先查询 name 字段的二级索引， 后再查询聚集索引，也就是需要进行回表查询</p><br><h2 id="索引语法">索引语法</h2><p>（1）创建索引</p><p><code>CREATE [UNIQUE | FULLTEXT] INDEX index_name ON table_name (index_col_name ...);</code></p><p>命名：idx_表名_字段名</p><br> <p>（2）查看索引</p><p><code>SHOW INDEX FROM table_name ;</code></p><br><p>（3）删除索引</p><p><code>DROP INDEX index_name ON table_name ;</code></p><br><h2 id="sql性能分析">SQL性能分析</h2><p>查看当前数据库的 INSERT、UPDATE、DELETE、SELECT 的访问频次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- session 是查看当前会话 ;<br>-- global 是查询全局数据 ;<br>SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;;<br></code></pre></td></tr></table></figure><br><p>通过查询 SQL 的执行频次，我们就能够知道当前数据库到底是增删改为主，还是查询为主</p><p>假设是以查询为主，我们可以借助于慢查询日志对那些查询语句进行优化</p><br><h3 id="慢查询日志">慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数的所有 SQL 语句的日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看慢查询日志是否开启<br>show variables like &#x27;slow_query_log&#x27;;<br><br><br># 如果要开启慢查询日志，需要在 MySQL 的配置文件中配置如下信息：<br># 开启MySQL慢日志查询开关<br>slow_query_log = 1;<br><br># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>long_query_time = 2;<br></code></pre></td></tr></table></figure><br><p>通过慢查询日志，就可以定位出执行效率比较低的 SQL，从而有针对性的进行优化</p><br><h3 id="profile">profile</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看当前 MySQL 是否支持 profile 操作<br>SELECT @@have_profiling ;<br><br># 开启 profiling<br>SET profiling = 1;<br><br># 查看每一条 SQL 的耗时基本情况<br>show profiles;<br><br># 查看指定 query_id 的 SQL 语句各个阶段的耗时情况<br>show profile for query query_id;<br><br># 查看指定 query_id 的 SQL 语句 CPU 的使用情况<br>show profile cpu for query query_id;<br></code></pre></td></tr></table></figure><br><h3 id="explain">explain</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 直接在 select 语句之前加上关键字 explain / desc<br>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;<br></code></pre></td></tr></table></figure><br><p>Explain 执行计划中各个字段的含义：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号</td></tr><tr><td>select_type</td><td>表示 select 的类型</td></tr><tr><td>type</td><td>表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all</td></tr><tr><td>possible_key</td><td>显示可能应用在这张表上的索引，一个或多个</td></tr><tr><td>key</td><td>实际使用的索引，如果为NULL，则没有使用索引</td></tr><tr><td>key_len</td><td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好</td></tr><tr><td>rows</td><td>MySQL认为必须要执行查询的行数，是一个估计值， 可能并不总是准确的</td></tr><tr><td>filtered</td><td>表示返回结果的行数占需读取行数的百分比，值越大越好</td></tr></tbody></table><br><h2 id="索引使用">索引使用</h2><p>如果索引了多列（联合索引），要遵守最左前缀法则。</p><p>最左前缀法则：查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效（后面的字段索引失效）</p><br><p>查询时，最左边的列必须存在（放置的位置不影响结果 ），否则索引全部失效</p><p>而且中间不能跳过某一列，否则该列后面的字段索引将失效</p><br><p>联合索引中，出现范围查询（ &gt;，&lt; ），范围查询右侧的列索引失效</p><p>所以尽可能的使用 &gt;= 或 &lt;= 这类的范围查询</p><br><p><strong>索引失效的情况：</strong></p><ul><li><p>在索引列上进行运算操作， 索引将失效</p></li><li><p>字符串类型字段使用时，不加引号，索引将失效</p></li><li><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效</p></li><li><p>用 or 分割开的条件， 如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到</p></li><li><p>如果 MySQL 评估使用索引比全表更慢，则不使用索引</p></li></ul><br><br><p><strong>SQL提示：</strong></p><p>（1）<code>use index</code>：建议MySQL使用哪一个索引完成此次查询</p><p>（2）<code>ignore index</code>：忽略指定的索引</p><p>（3）<code>force index</code>：强制使用索引</p><br><br><p><strong>覆盖索引：</strong></p><p>尽量使用覆盖索引，减少select *</p><p>覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</p><br><br><p><strong>前缀索引：</strong></p><p>当字段类型为字符串时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO， 影响查询效率</p><p>此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率</p><br><p>语法：</p><p><code>create index idx_xxxx on table_name(column(n)) ;</code></p><p>eg. 为 tb_user 表的 email 字段，建立长度为 5 的前缀索引</p><p><code>create index idx_email_5 on tb_user(email(5));</code></p><br><p>前缀长度：</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值</p><p>索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的</p><br><br><p><strong>单列索引与联合索引</strong></p><p>单列索引：即一个索引只包含单个列</p><p>联合索引：即一个索引包含了多个列</p><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，而非单列索引</p><br><h2 id="索引设计原则">索引设计原则</h2><p>（1）针对于数据量较大，且查询比较频繁的表建立索引</p><p>（2）针对于常作为查询条件、排序、分组操作的字段建立索引</p><p>（3）尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</p><p>（4）如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引</p><p>（5）尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率</p><p>（6）要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</p><p>（7）如果索引列不能存储NULL值，在创建表时使用NOT NULL约束它</p><br><h1 id="sql优化">SQL优化</h1><h2 id="插入数据">插入数据</h2><ul><li>批量插入</li><li>手动提交事务</li><li>主键顺序插入</li></ul><br><h2 id="order-by优化">order by优化</h2><p>MySQL的排序，有两种方式：</p><p>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</p><p>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</p><p>对于以上的两种排序方式，Using index的性能高，我们在优化排序操作时，尽量要优化为 Using index</p><br><p>优化原则：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则</li><li>如果不可避免的出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size</li></ul><p>PS：查看缓冲区大小 <code>show variables like 'sort_budder_size';</code></p><br><h2 id="group-by优化">group by优化</h2><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><br><h2 id="limit优化">limit优化</h2><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低</p><p>优化思路:</p><p>一般分页查询时，通过创建覆盖索 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><br><h2 id="count优化">count优化</h2><p>如果数据量很大，在执行count操作时，是非常耗时的</p><p>主要的优化思路：自己计数</p><br><table><thead><tr><th>count用法</th><th>含义</th></tr></thead><tbody><tr><td>count(主 键)</td><td>会遍历整张表，把每一行的主键值都取出来，返回给服务层。 服务层拿到主键后，直接按行进行累加</td></tr><tr><td>count(字 段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</td></tr><tr><td>count(数 字)</td><td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字 “1” 进去，直接按行进行累加</td></tr><tr><td>count(*)</td><td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</td></tr></tbody></table><p>按照效率排序的话，count (字段) &lt; count (主键 id) &lt; count (1) ≈ count (*)</p><br><h1 id="视图存储过程触发器">视图/存储过程/触发器</h1><h2 id="视图">视图</h2><p>视图（View）是一种虚拟存在的表。</p><p>视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的</p><br><p><strong>语法：</strong></p><p>（1）创建</p><p><code>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ] ;</code></p><p>（2）查询</p><p>查看创建视图语句：<code>SHOW CREATE VIEW 视图名称; </code></p><p>查看视图数据：<code>SELECT * FROM 视图名称 ... ;</code></p><p>（3）修改</p><p><code>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ] ;</code></p><br><p><code>ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ] ;</code></p><p>（4）删除</p><p><code>DROP VIEW [ IF EXISTS ] 视图名称 [ 视图名称 ] ... ;</code></p><br><br><p><strong>检查选项：</strong></p><p>当使用 WITH CHECK OPTION 子句创建视图时，MySQL 会通过视图检查正在更改的每个行</p><p>例如 插入，更新，删除，以使其符合视图的定义</p><p>MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。</p><p>为了确定检查的范围，mysql 提供了两个选项： CASCADED 和 LOCAL ，默认值为 CASCADED</p><br><p>（1）CASCADED 级联</p><p>比如，v2 视图是基于 v1 视图的</p><p>如果在 v2 视图创建的时候指定了检查选项为 cascaded，但是 v1视图创建时未指定检查选项</p><p>则在执行检查时，不仅会检查 v2，还会级联检查 v2 的关联视图 v1</p><br><p>（2）LOCAL 本地</p><p>比如，v2 视图是基于 v1 视图的</p><p>如果在 v2 视图创建的时候指定了检查选项为 local ，但是 v1 视图创建时未指定检查选项</p><p>则在执行检查时，只会检查 v2，不会检查 v2 的关联视图 v1</p><br><br><p><strong>视图的更新：</strong></p><p>如果视图包含以下任何一项，则该视图不可更新：</p><ul><li>聚合函数或窗口函数（ SUM()、 MIN()、 MAX()、 COUNT() 等 ）</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION 或者 UNION ALL</li></ul><br><br><p><strong>视图作用：</strong></p><p>（1）简单</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。</p><p>那些被经常使用的查询可以被定义为视 图，从而使得用户不必为以后的操作每次指定全部的条件</p><p>（2）安全</p><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</p><p>（3）数据独立</p><p>视图可帮助用户屏蔽真实表结构变化带来的影响</p><br><h2 id="存储过程">存储过程</h2><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用</p><br><p><strong>语法：</strong></p><p>（1）创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])<br>BEGIN<br>-- SQL语句<br>END ;<br></code></pre></td></tr></table></figure><p>（2）调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CALL 名称 ([ 参数 ]);<br></code></pre></td></tr></table></figure><p>（3）查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询指定数据库的存储过程及状态信息<br>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#x27;xxx&#x27; ;<br><br>-- 查询某个存储过程的定义<br>SHOW CREATE PROCEDURE 存储过程名称 ;<br></code></pre></td></tr></table></figure><p>（4）删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ;<br></code></pre></td></tr></table></figure><p>PS：在命令行中，执行创建存储过程的 SQL 时，需要通过关键字 delimiter 指定 SQL 语句的 结束符</p><p><code>delimiter $$</code> ——指定 $$ 为结束符（记得换回来）</p><br><br><h3 id="变量">变量</h3><p>在 MySQL 中变量分为三种类型: 系统变量、用户定义变量、局部变量</p><br><p><strong>系统变量：</strong></p><p>不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）</p><p>（1）查看系统变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查看所有系统变量<br>SHOW [ SESSION | GLOBAL ] VARIABLES ;<br><br>-- 可以通过LIKE模糊匹配方式查找变量<br>SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#x27;......&#x27;;<br><br>-- 查看指定变量的值<br>SELECT @@[SESSION | GLOBAL] 系统变量名;<br></code></pre></td></tr></table></figure><p>（2）设置系统变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;<br>SET @@[SESSION | GLOBAL]系统变量名 = 值 ;<br></code></pre></td></tr></table></figure><br><br><p><strong>用户自定义变量：</strong></p><p>用户定义变量 是用户根据需要自己定义的变量</p><p>用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以。其作用域为当前连接</p><br><p>（1）赋值</p><p>方式一：</p><p><code>SET @var_name = expr [, @var_name = expr] ... ;</code></p><p><code>SET @var_name := expr [, @var_name := expr] ... ;</code></p><p>方式二：</p><p><code>SELECT @var_name := expr [, @var_name := expr] ... ;</code></p><br><p>（2）使用</p><p><code>select @var_name ;</code></p><p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL</p><br><br><p><strong>局部变量：</strong></p><p>局部变量是根据需要定义的在局部生效的变量</p><p>访问之前，需要 DECLARE 声明。可用作存储过程内的局部变量和输入参数，范围是在其内声明的BEGIN … END块</p><br><p>（1）声明</p><p><code>DECLARE 变量名 变量类型 [DEFAULT ... ] ;</code></p><br><p>（2）赋值</p><p><code>SET 变量名 = 值 ;</code></p><p><code>SET 变量名 := 值 ;</code></p><p><code>SELECT 字段名 INTO 变量名 FROM 表名 ... ;</code></p><br><h3 id="参数">参数</h3><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>IN</td><td>该类参数作为输入，也就是需要调用时传入值（默认）</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td></tr><tr><td>INOUT</td><td>既可以作为输入参数，也可以作为输出参数</td></tr></tbody></table><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])<br>BEGIN<br>-- SQL语句<br>END ;<br></code></pre></td></tr></table></figure><br><h3 id="常用函数">常用函数</h3><p><strong>if</strong></p><p>if 用于做条件判断，语法结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IF 条件1 THEN<br>.....<br>ELSEIF 条件2 THEN -- 可选<br>.....<br>ELSE -- 可选<br>.....<br>END IF;<br></code></pre></td></tr></table></figure><p>在if条件判断的结构中，ELSE IF 结构 和 ELSE 结构可以有多个，也可以没有</p><br><br><p><strong>case</strong></p><p>语法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CASE case_value<br>WHEN when_value1 THEN statement_list1<br>[ WHEN when_value2 THEN statement_list2] ...<br>[ ELSE statement_list ]<br>END CASE;<br></code></pre></td></tr></table></figure><p>语法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CASE<br>WHEN search_condition1 THEN statement_list1<br>[WHEN search_condition2 THEN statement_list2] ...<br>[ELSE statement_list]<br>END CASE;<br></code></pre></td></tr></table></figure><br><br><p><strong>while</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">WHILE 条件 DO<br>SQL逻辑...<br>END WHILE;<br></code></pre></td></tr></table></figure><br><br><p><strong>repeat</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">REPEAT<br>SQL逻辑...<br>UNTIL 条件<br>END REPEAT;<br></code></pre></td></tr></table></figure><p><br><br></p><p><strong>loop</strong></p><ul><li>LEAVE ：配合循环使用，退出循环</li><li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[begin_label:] LOOP<br>SQL逻辑...<br>END LOOP [end_label];<br></code></pre></td></tr></table></figure><br><h3 id="游标">游标</h3><p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理</p><br><p>（1）声明游标</p><p><code>DECLARE 游标名称 CURSOR FOR 查询语句 ;</code></p><br><p>（2）打开游标</p><p><code>OPEN 游标名称 ;</code></p><br><p>（3）获取游标记录</p><p><code>FETCH 游标名称 INTO 变量 [ 变量 ] ;</code></p><br><p>（4）关闭游标</p><p><code>CLOSE 游标名称 ;</code></p><br><p>eg . 根据传入的参数 uage，来查询用户表 tb_user 中，所有的用户年龄小于等于 uage 的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表 （id, name, profession）中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create procedure p11(in uage int)<br>begin<br>    # 普通变量声明要先于游标声明<br>    declare uname varchar(100);<br>    declare upro varchar(100);<br>    <br>    declare u_cursor cursor for select name, profession<br>                                from tb_user<br>                                where age &lt;=<br>                                      uage;<br>    <br>    drop table if exists tb_user_pro;<br>    create table if not exists tb_user_pro (<br>        id         int primary key auto_increment,<br>        name       varchar(100),<br>        profession varchar(100)<br>    );<br>    <br>    # 开启游标<br>    open u_cursor;<br>    while true<br>        do<br>        # 获取数据<br>            fetch u_cursor into uname,upro;<br>            # 插入新表<br>            insert into tb_user_pro values (null, uname, upro);<br>        end while;<br>    close u_cursor;# 关闭游标<br>end;<br>call p11(30);<br></code></pre></td></tr></table></figure><br><h2 id="存储函数">存储函数</h2><p>存储函数是有返回值的存储过程，存储函数的参数只能是 IN 类型的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE FUNCTION 存储函数名称 ([ 参数列表 ])<br>RETURNS type [characteristic ...]<br>BEGIN<br>-- SQL语句<br>RETURN ...;<br>END ;<br></code></pre></td></tr></table></figure><p>characteristic说明：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</li></ul><p><strong>使用了存储函数的功能实际上都可以用存储过程来代替</strong></p><br><h2 id="触发器">触发器</h2><p>触发器是与表有关的数据库对象</p><p>指在 insert / update / delete 之前（BEFORE）或之后（AFTER），触发并执行触发器中定义的SQL语句集合</p><p>触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作</p><br><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><br><p>（1）创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER trigger_name<br>BEFORE/AFTER INSERT/UPDATE/DELETE<br>ON tbl_name FOR EACH ROW -- 行级触发器<br>BEGIN<br>trigger_stmt ;<br>END;<br></code></pre></td></tr></table></figure><p>（2）查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TRIGGERS ;<br></code></pre></td></tr></table></figure><p>（3）删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 如果没有指定 schema_name，默认为当前数据库<br>DROP TRIGGER [ schema_name ]trigger_name ; <br></code></pre></td></tr></table></figure></font>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】数据结构（非ACM版）</title>
      <link href="/post/79666db.html"/>
      <url>/post/79666db.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p><strong>数据结构：</strong></p><p>数据结构是互相之间存在一种或多种特定关系的数据元素的集合。</p><p>根据数据元素之间关系的不同特性，通常分为四种逻辑结构：</p><p>1）集合</p><p>2）线性结构</p><p>3）树形结构</p><p>4）图状或网状结构</p><br><p><strong>算法和算法分析：</strong></p><p>算法的特性：有穷性，确定性，可行性，输入输出性</p><p>设计算法的要求：正确性，可读性，健壮性，高效性</p><br><h1 id="线性表">线性表</h1><p>线性表就是具有相同特性的数据元素的一个有限序列，是最常用且最简单的一种数据结构。</p><p>线性表的逻辑结构特征：</p><p>（1）有限性：线性表中数据元素的个数是有穷的</p><p>（2）相同性：本章线性表中数据元素的类型是同一的</p><p>（3）顺序性：线性表中相邻的数据元素 $a_i$ 和ai之间存在<strong>序偶关系</strong> $(a_{i-1}, a_i)$，即 $a_{i-1}$ 是 $a_i$ 的前驱， $a_i$ 是 $a_{i-1}$ 的后继；$a_1$ 无前驱，$a_n$ 无后继，其它每个元素有且仅有一个前驱和一个后继</p><br><p>线性表的存储表示有两种，顺序存储和链表存储。</p><br><h2 id="顺序表">顺序表</h2><p>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。</p><p>一般来说，线性表的第i个数据元素 $a_i$ 的存储位置为：</p><p>$$LOC(a_i) = LOC(a_1) + (i-1)*l$$</p><br><p><strong>顺序表的存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 10  <span class="hljs-comment">// 线性表存储空间的初始分配量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LISTINCREMENT 10   <span class="hljs-comment">// 线性表存储空间的分配增量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1               <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0            <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;  <span class="hljs-comment">// ElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-comment">// 顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType* elem;<br>    <span class="hljs-type">int</span> length;    <span class="hljs-comment">// 当前长度</span><br>    <span class="hljs-type">int</span> listsize;  <span class="hljs-comment">// 当前的存储容量</span><br>&#125; SqList;<br></code></pre></td></tr></table></figure><br><p><strong>顺序表的功能实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 线性表L的初始化</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123;<br>    L.elem = (ElemType*)<span class="hljs-built_in">malloc</span>(LIST_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">if</span> (!L.elem)    <span class="hljs-keyword">return</span> ERROR;<br>    L.length = <span class="hljs-number">0</span>;<br>    L.listsize = LIST_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 消除线性表</span><br><span class="hljs-function">Status <span class="hljs-title">DestoryList</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(L.elem);  <span class="hljs-comment">// 释放空间</span><br>    L.elem = <span class="hljs-literal">NULL</span>;<br>    L.length = L.listsize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 获得线性表的长度，记忆保存的元素的个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123; <span class="hljs-keyword">return</span> L.length; &#125;<br><br><span class="hljs-comment">// 判断一个线性表是否为空表</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L.length == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 用e返回L中第i个数据元素的值</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L.length == <span class="hljs-number">0</span> || i &lt; <span class="hljs-number">1</span> || i &gt; L.length) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    e = L.elem[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 查找：在线性表中找到元素e在登记号位置上</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L, ElemType e)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (L.elem[i] == e) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 若未找到，返回0</span><br>&#125;<br><br><span class="hljs-comment">// 插入：在L中的第i个位置之前插入新的数据元素e，L的长度加1</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> i, ElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (L.length &gt;= L.listsize) &#123;<br>        <span class="hljs-comment">// 线性表已满</span><br>        ElemType* newbase = (ElemType*)<span class="hljs-built_in">realloc</span>(<br>            L.elem, (L.listsize + LISTINCREMENT) * <span class="hljs-built_in">sizeof</span>(ElemType));<br><br>        <span class="hljs-keyword">if</span> (!newbase)   <span class="hljs-keyword">return</span> ERROR;<br>        L.elem = newbase;<br>        L.listsize += LISTINCREMENT;<br>    &#125;<br>    <span class="hljs-type">int</span> *p, *q;<br>    q = &amp;(L.elem[i - <span class="hljs-number">1</span>]);  <span class="hljs-comment">// 插入位置</span><br>    <span class="hljs-keyword">for</span> (p = &amp;(L.elem[L.length - <span class="hljs-number">1</span>]); p &gt;= q; --p) &#123;<br>        *(p + <span class="hljs-number">1</span>) = *p;<br>    &#125;<br>    *q = e;<br>    ++L.length;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 删除：删除L的第i个数据元素，并用e返回其值，L的长度减1</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> i, ElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length)  <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-type">int</span> *p, *q;<br>    p = &amp;L.elem[i - <span class="hljs-number">1</span>];<br>    e = *p;<br>    q = &amp;L.elem[L.length - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (++p; p &lt;= q; ++p) &#123;<br>        *(p - <span class="hljs-number">1</span>) = *p;<br>    &#125;<br>    --L.length;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 打印线性表中的所有元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, L.elem[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在顺序存储结构的线性表中插入或删除一个数据元素，平均约移动表中一半元素。</p><p>时间复杂度约为 $O(n)$</p><br><p><strong>优点：</strong></p><p>存储密度大（结点本身所占存储量 / 结点结构所占存储量）</p><p>可以随机存取表中任一元素</p><p><strong>缺点：</strong></p><p>在插入、删除某一元素时， 需要移动大量元素</p><p>浪费存储空间</p><p>属于静态存储形式， 数据元素的个数不能自由扩充</p><br><h2 id="链式表">链式表</h2><p>链表是一种物理存储结构上非连续、非顺序的存储结构</p><p>数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p><br><p>结点：数据元素的存储映像。由数据域和指针域两部分组成</p><p>链表：n个结点由指针链组成一个链表</p><p>头指针：是指向链表中第一个结点的指针</p><p>头结点：要表示一个单链表时，只需声明一个头指针 L ，指向单链表的第一个结点</p><p>首元结点：是指链表中存储第一个数据元素的结点</p><br><p><strong>在链表中设置头结点有什么好处？</strong></p><p>（1）便于首元结点的处理</p><p>首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其它位置一致， 无须进行特殊处理</p><p>（2）便于空表和非空表的统一处理</p><p>无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了</p><br><h3 id="单链表">单链表</h3><p><strong>单链表的存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1               <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0            <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;  <span class="hljs-comment">// ElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-comment">// 链表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> &#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>* next;<br>&#125; LNode, *LinkList;<br></code></pre></td></tr></table></figure><br><p><strong>单链表的功能实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表的初始化</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList&amp; L)</span> </span>&#123;<br>    L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>    <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> ERROR;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 判断单链表是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LinkList L)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L-&gt;next == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 销毁单链表</span><br><span class="hljs-function">Status <span class="hljs-title">DestoryList</span><span class="hljs-params">(LinkList&amp; L)</span> </span>&#123;<br>    LNode* p;<br>    <span class="hljs-keyword">while</span> (L) &#123;<br>        p = L;  L = L-&gt;next;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 清空单链表</span><br><span class="hljs-function">Status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList&amp; L)</span> </span>&#123;<br>    LNode *p = L-&gt;next, *q;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        q = p-&gt;next;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = q;<br>    &#125;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 用e返回L中第i个数据元素的值</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i, ElemType&amp; e)</span> </span>&#123;<br>    LNode* p = L-&gt;next;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i) &#123;<br>        j++;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!p || j &gt; i)    <span class="hljs-keyword">return</span> ERROR;<br>    e = p-&gt;data;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 按值查找，找到就返回其地址</span><br><span class="hljs-function">LNode* <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L, ElemType e)</span> </span>&#123;<br>    LNode* p = L-&gt;next;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;data != e)<br>        p = p-&gt;next;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// 在第i个位置前插入元素e</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> i, ElemType e)</span> </span>&#123;<br>    LNode* p = L;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i - <span class="hljs-number">1</span>) &#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!p || j &gt; i - <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> ERROR;<br><br>    LNode* s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>    s-&gt;data = e;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 删除第i个元素，并由e返回其值</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> i, ElemType e)</span> </span>&#123;<br>    LNode* p = L;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i - <span class="hljs-number">1</span>) &#123;<br>        j++;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!p-&gt;next || j &gt; i - <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> ERROR;<br><br>    LNode* q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    e = q-&gt;data;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 打印线性表中的所有元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(LinkList L)</span> </span>&#123;<br>    LNode* p = L-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 头插法：数据是倒叙插入</span><br>ElemType a[<span class="hljs-number">100</span>], b[<span class="hljs-number">100</span>];<br><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    LNode* s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>        s-&gt;data = a[i];<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><br><span class="hljs-comment">// 尾插法：数据是正序插入</span><br><span class="hljs-function">LinkList <span class="hljs-title">List_TailInsert</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    LNode *s, *r = L;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>        s-&gt;data = b[i];<br>        r-&gt;next = s;<br>        r = s;<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 尾结点指针置空</span><br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="循环链表">循环链表</h3><p>循环链表的特点：</p><p>表中最后一个结点的指针域指向头指针，整个链表形成一个环</p><p>从表中任一结点出发都可以找到其他的结点</p><p>循环链表的操作与单链表基本一致，但由于循环链表中没有NULL指针</p><p>故涉及遍历操作时，其终止条件就不再像非循环链表那样判断 p 或 p-&gt;next 是否为空</p><p>而是判断它们是否等于头指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将两个带尾指针的循环链表合并</span><br><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta, LinkList Tb)</span> </span>&#123;<br>    LNode* p = Ta-&gt;next;<br>    Ta-&gt;next = Tb-&gt;next-&gt;next;<br>    <span class="hljs-keyword">delete</span> Tb-&gt;next;<br>    Tb-&gt;next = p;<br>    <span class="hljs-keyword">return</span> Tb;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="双向链表">双向链表</h3><p>比单链表多一个 <strong>前驱指针prior</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> &#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *next, *prior;<br>&#125; DuLNode, *DuLinkList;<br><br><span class="hljs-comment">// 返回L中第i个数据元素的地址</span><br><span class="hljs-function">DuLNode* <span class="hljs-title">GetElem</span><span class="hljs-params">(DuLinkList L, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    DuLNode* p = L-&gt;next;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i) &#123;<br>        j++;<br>        p = p-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// 在第i个位置之前插入元素e</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(DuLinkList&amp; L, <span class="hljs-type">int</span> i, ElemType e)</span> </span>&#123;<br>    DuLNode *p, *s;<br>    <span class="hljs-keyword">if</span> (!(p = <span class="hljs-built_in">GetElem</span>(L, i)))<br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (!(s = (DuLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DuLNode))))<br>        <span class="hljs-keyword">return</span> ERROR;<br><br>    s-&gt;data = e;<br>    s-&gt;prior = p-&gt;prior;<br>    p-&gt;prior-&gt;next = s;<br>    s-&gt;next = p;<br>    p-&gt;prior = s;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 删除第i个元素</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(DuLinkList&amp; L, <span class="hljs-type">int</span> i, ElemType&amp; e)</span> </span>&#123;<br>    DuLNode *p, *s;<br>    <span class="hljs-keyword">if</span> (!(p = <span class="hljs-built_in">GetElem</span>(L, i)))<br>        <span class="hljs-keyword">return</span> ERROR;<br><br>    e = p-&gt;data;<br>    p-&gt;prior-&gt;next = p-&gt;next;<br>    p-&gt;next-&gt;prior = p-&gt;prior;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="线性表的应用">线性表的应用</h2><p><strong>顺序存储和链式存储的各自特点和应用环境：</strong></p><p>（1）顺序存储</p><p>顺序存储结构的特点是逻辑上相邻的数据元素，物理存储位置也相邻，即地址连续</p><p>并且，顺序表的存储空间需要预先分配</p><p>适用于插入和删除操作较少的情况下</p><p>（2）链式存储</p><p>各个元素存储在任意的地址空间，逻辑相邻的元素在物理内存中没有联系</p><p>适用于需要频繁进行插入和删除操作的情况下</p><br><h3 id="有序表的合并">有序表的合并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">已知顺序线性表La和Lb的元素按值非递减排列</span><br><span class="hljs-comment">归并La和Lb得到新的顺序线性表Lc，Lc的元素也按值非递减排列</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">Status <span class="hljs-title">MergeList</span><span class="hljs-params">(SqList La, SqList Lb, SqList&amp; Lc)</span> </span>&#123;<br>    ElemType *pa, *pb, *pc, *pa_last, *pb_last;<br>    pa = La.elem, pa_last = pa + La.length - <span class="hljs-number">1</span>;<br>    pb = Lb.elem, pb_last = pb + Lb.length - <span class="hljs-number">1</span>;<br>    <br>    Lc.listsize = Lc.length = La.length + Lb.length;<br>    pc = Lc.elem = (ElemType*)<span class="hljs-built_in">malloc</span>(Lc.listsize * <span class="hljs-built_in">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">if</span> (!pc)    <span class="hljs-keyword">return</span> ERROR;<br><br>    <span class="hljs-keyword">while</span> (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123;<br>        <span class="hljs-keyword">if</span> (*pa &lt;= *pb) *pc++ = *pa++;<br>        <span class="hljs-keyword">else</span>    *pc++ = *pb++;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (pa &lt;= pa_last)   *pc++ = *pa++;<br>    <span class="hljs-keyword">while</span> (pb &lt;= pb_last)   *pc++ = *pb++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">// 将两个有序链表合并为一个有序链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList</span><span class="hljs-params">(LinkList&amp; La, LinkList&amp; Lb, LinkList&amp; Lc)</span> </span>&#123;<br>    LNode *pa = La-&gt;next, *pb = Lb-&gt;next, *pc;<br>    Lc = pc = La;<br>    <span class="hljs-keyword">while</span> (pa &amp;&amp; pb) &#123;<br>        <span class="hljs-keyword">if</span> (pa-&gt;data &lt;= pb-&gt;data) &#123;<br>            pc-&gt;next = pa;<br>            pc = pa;<br>            pa = pa-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pc-&gt;next = pb;<br>            pc = pb;<br>            pb = pb-&gt;next;<br>        &#125;<br>    &#125;<br>    pc-&gt;next = pa ? pa : pb;<br>    <span class="hljs-built_in">free</span>(Lb);<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="一元多项式的加法">一元多项式的加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 链表实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1     <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0  <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;  <span class="hljs-comment">// ElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-comment">// 链表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span> &#123;<br>    <span class="hljs-type">int</span> coef;  <span class="hljs-comment">// 系数</span><br>    <span class="hljs-type">int</span> expn;  <span class="hljs-comment">// 指数</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span>* next;<br>&#125; PNode, *LinkList;<br><br><span class="hljs-comment">// 尾插法：数据是正序插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Create</span><span class="hljs-params">(LinkList&amp; p, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    p = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(PNode));<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    PNode* s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(PNode));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;s-&gt;coef, &amp;s-&gt;expn);<br>        PNode *pre = p, *q = p-&gt;next;<br>        <span class="hljs-comment">// 保证指数递增</span><br>        <span class="hljs-keyword">while</span> (q &amp;&amp; q-&gt;expn &lt; s-&gt;expn) &#123;<br>            pre = q;<br>            q = q-&gt;next;<br>        &#125;<br>        s-&gt;next = q;<br>        pre-&gt;next = s;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(LinkList L)</span> </span>&#123;<br>    PNode* p = L-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d  **&quot;</span>, p-&gt;coef, p-&gt;expn);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(LinkList La, LinkList Lb, LinkList&amp; Lc)</span> </span>&#123;<br>    PNode *pa = La-&gt;next, *pb = Lb-&gt;next, *pc, *r;<br><br>    Lc = pc = La;<br>    <span class="hljs-keyword">while</span> (pa &amp;&amp; pb) &#123;<br>        <span class="hljs-keyword">if</span> (pa-&gt;expn &lt; pb-&gt;expn) &#123;<br>            pc-&gt;next = pa;<br>            pc = pa;<br>            pa = pa-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa-&gt;expn &gt; pb-&gt;expn) &#123;<br>            pc-&gt;next = pb;<br>            pc = pb;<br>            pb = pb-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> sum = pa-&gt;coef + pb-&gt;coef;<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                r = pa;<br>                pa = pa-&gt;next;<br>                <span class="hljs-built_in">free</span>(r);<br>                r = pb;<br>                pb = pb-&gt;next;<br>                <span class="hljs-built_in">free</span>(r);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pa-&gt;coef = sum;<br>                pc-&gt;next = pa;<br>                pc = pa;<br>                pa = pa-&gt;next;<br>                r = pb;<br>                pb = pb-&gt;next;<br>                <span class="hljs-built_in">free</span>(r);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    pc-&gt;next = pa ? pa : pb;<br>    <span class="hljs-built_in">free</span>(pb);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    LinkList La, Lb, Lc;<br>    <span class="hljs-built_in">Create</span>(La, n);<br>    <span class="hljs-built_in">Create</span>(Lb, m);<br><br>    <span class="hljs-built_in">Merge</span>(La, Lb, Lc);<br>    <span class="hljs-built_in">OutPut</span>(Lc);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">4 3</span><br><span class="hljs-comment">7 0</span><br><span class="hljs-comment">3 1</span><br><span class="hljs-comment">9 8</span><br><span class="hljs-comment">5 17</span><br><span class="hljs-comment">8 1</span><br><span class="hljs-comment">22 7</span><br><span class="hljs-comment">-9 8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><h1 id="栈和队列">栈和队列</h1><p>栈和队列都是线性表的一种特殊情况</p><p>栈： 是只允许在一端进行插入或删除操作的线性表</p><p>队列：是只允许在一端进行插入，在另一端删除的线性表</p><be><h2 id="栈">栈</h2><p>“先入后出”（FILO）原则</p><p>最先放入栈中元素在栈底，最后放入的元素在栈顶</p><p>而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p><br><p><strong>卡特兰数</strong></p><p>$n$ 个不同的元素进站，出栈元素不同排列的个数有 $\frac{1}{n+1}C_{2n}^n$ 个</p><p>和线性表相似，栈也有两种存储表示方式，顺序栈更加常见</p><br><h3 id="顺序栈">顺序栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_INIT_SIZE 10  <span class="hljs-comment">// 存储空间的初始分配量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACKINCREMENT 10   <span class="hljs-comment">// 存储空间的分配增量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1                <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0             <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SElemType;  <span class="hljs-comment">// SElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    SElemType* base;<br>    SElemType* top;<br>    <span class="hljs-type">int</span> stacksize;  <span class="hljs-comment">// 当前的存储容量</span><br>&#125; SqStack;<br><br><span class="hljs-comment">// base == top 表示栈空</span><br><span class="hljs-comment">// top - base == stacksize 表示栈满</span><br><br><span class="hljs-comment">// 栈的初始化</span><br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack&amp; S)</span> </span>&#123;<br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span> (!S.base) <span class="hljs-keyword">return</span> ERROR;<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 清空栈</span><br><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack&amp; S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.base) S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 销毁栈</span><br><span class="hljs-function">Status <span class="hljs-title">DextoryStack</span><span class="hljs-params">(SqStack&amp; S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.base) &#123;<br>        <span class="hljs-keyword">delete</span> S.base;<br>        S.stacksize = <span class="hljs-number">0</span>;<br>        S.base = S.top = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 用e返回栈顶元素</span><br><span class="hljs-function">Status <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack&amp; S, SElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *(S.top - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 插入新的元素</span><br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack&amp; S, SElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top - S.base == S.stacksize) &#123;<br>        <span class="hljs-comment">// 栈满，追加空间</span><br>        S.base = (SElemType*)<span class="hljs-built_in">realloc</span>(<br>            S.base, (S.stacksize + STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));<br>        <span class="hljs-keyword">if</span> (!S.base) <span class="hljs-keyword">return</span> ERROR;<br><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 弹出栈顶元素</span><br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack&amp; S, SElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *(--S.top);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="链栈">链栈</h3><p>链表的头指针就是栈顶</p><p>不需要头结点</p><p>基本不存在栈满的情况</p><p>空栈相当于头指针指向NULL</p><p>插入和删除仅在栈顶处进行</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230531111630648.png" alt="image-20230531111630648"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1                <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0             <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SElemType;  <span class="hljs-comment">// SElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span> &#123;<br>    SElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span>* next;<br>&#125; StackNode, *LinkStack;<br><br><span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(LinkStack&amp; S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack&amp; S, SElemType e)</span> </span>&#123;<br>    StackNode* p = (StackNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SElemType));<br>    p-&gt;data = e;<br>    p-&gt;next = S;<br>    S = p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 出栈</span><br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack&amp; S, SElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    e = S-&gt;data;<br>    StackNode* p = S;<br>    S = S-&gt;next;<br>    <span class="hljs-built_in">delete</span> (p);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 取栈顶元素</span><br><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkStack&amp; S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S) <span class="hljs-keyword">return</span> S-&gt;data;<br>&#125;<br><br></code></pre></td></tr></table></figure><br><h2 id="队列">队列</h2><p>“先进先出”（FIFO）原则</p><p>是一种特殊的线性结构，它只允许在队列的首部进行删除操作，即“出队”</p><p>在队列的尾部进行插入操作，即“入队”</p><br><p>同样的，栈也有两种存储表示方式，循环顺序队列更加常见</p><br><h3 id="循环顺序队列">循环顺序队列</h3><p>用模运算将存储空间在逻辑上变成了 <strong>“环状”</strong> ，牺牲一个单元来区分队满和队空</p><p>(Q.rear + 1) % MAXQSIZE == Q.front 表示队满</p><p>Q.rear == Q.front  表示队空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100  <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1          <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0       <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> QElemType;  <span class="hljs-comment">// QElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-comment">// 顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span> &#123;<br>    QElemType* base;<br>    <span class="hljs-type">int</span> front, rear;<br>&#125; SqQueue;<br><br><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue&amp; Q)</span> </span>&#123;<br>    Q.base = (QElemType*)<span class="hljs-built_in">malloc</span>(MAXQSIZE * <span class="hljs-built_in">sizeof</span>(QElemType));<br>    <span class="hljs-keyword">if</span> (!Q.base) <span class="hljs-keyword">return</span> ERROR;<br>    Q.front = Q.rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 求队列中的元素个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue&amp; Q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;<br>&#125;<br><br><span class="hljs-comment">// 入队</span><br><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue&amp; Q, QElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE == Q.front) <span class="hljs-keyword">return</span> ERROR;<br>    Q.base[Q.rear] = e;<br>    Q.rear = (Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 出队</span><br><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    e = Q.base[Q.front];<br>    Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXQSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 取队头元素</span><br><span class="hljs-function">QElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue &amp;Q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.front != Q.rear)  <span class="hljs-keyword">return</span> Q.base[Q.front];<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="链队列">链队列</h3><p>当无法估计所用队列的长度时，宜采用链队列</p><p>与链栈不同，链队列有头结点</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230531152133237.png" alt="image-20230531152133237"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1     <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0  <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> QElemType;  <span class="hljs-comment">// QElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span> &#123;<br>    QElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span>* next;<br>&#125; QNode, *QueuePtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    QueuePtr front;<br>    QueuePtr rear;<br>&#125; LinkQueue;<br><br><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue&amp; Q)</span> </span>&#123;<br>    Q.front = Q.rear = (QNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span> (!Q.front) <span class="hljs-keyword">return</span> ERROR;<br>    Q.front-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 销毁</span><br><span class="hljs-function">Status <span class="hljs-title">DestoryQueue</span><span class="hljs-params">(LinkQueue&amp; Q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (Q.front) &#123;<br>        QueuePtr p = Q.front-&gt;next;<br>        <span class="hljs-built_in">free</span>(Q.front);<br>        Q.front = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 入队</span><br><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue&amp; Q, QElemType e)</span> </span>&#123;<br>    QueuePtr p = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> ERROR;<br>    p-&gt;data = e; p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next = p;<br>    Q.rear = p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 出队</span><br><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue&amp; Q, QElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    QueuePtr p = Q.front-&gt;next;<br>    e = p-&gt;data;<br>    Q.front-&gt;next = p-&gt;next;<br>    <span class="hljs-keyword">if</span> (Q.rear == p) Q.rear = Q.front;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 取队头元素</span><br><span class="hljs-function">QElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(LinkQueue &amp;Q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.front != Q.rear) <span class="hljs-keyword">return</span> (Q.front-&gt;next-&gt;data);<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="应用">应用</h2><h3 id="表达式求值">表达式求值</h3><p><strong>表达式的组成：</strong></p><p>操作数；常数、变量</p><p>运算符：算术运算符、关系运算符和逻辑运算符</p><p>界限符：左右括弧和表达式结束符</p><p>任何一个算术表达式都由操作数、算术运算符和界限符组成</p><p>后两者统称为算符</p><p>例如：# 3 * ( 7 - 2 ) #</p><br>为了实现表达式求值。需要设置两个栈<p>一个是算符栈 OPTR，用于寄存运算符</p><p>另一个称为操作数栈 QPND，用于寄存运算数和运算结果</p><p><strong>求值的处理过程：</strong></p><p>是自左至右扫描表达式的每一个字符</p><ul><li><p>当扫描到的是运算数，则将其压入栈OPND</p></li><li><p>当扫描到的是运算符时</p><ul><li>若这个运算符比OPTR栈顶运算符的优先级高，则入栈OPTR，继续向后处理</li><li>若这个运算符比OPTR栈顶运算符优先级低，则从OPND栈中弹出两个运算数，从OPTR中弹出栈顶运算符进行运算，并将运算结果压入栈OPND</li></ul></li><li><p>继续处理当前字符，直到遇到结束符为止。</p></li></ul><br><h1 id="串-数组和广义表">串、数组和广义表</h1><h2 id="串">串</h2><p>即字符串，是由零个或多个字符组成的有限序列。一般记为</p><p>$$s=‘a_1a_2…a_n’$$</p><p>子串：一个串中任意个连续字符组成的子序列（含空串）</p><br><h3 id="模式串匹配-bf">模式串匹配 - BF</h3><p>就是暴力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">char</span> ch[MAXLEN + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> length; <br>&#125; SString;<br><br><br><span class="hljs-comment">// 子串T在主串S的第pos个字符后出现的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_BF</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = pos, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;<br>        <span class="hljs-keyword">if</span> (S.ch[i] == T.ch[j]) i++, j++;<br>        <span class="hljs-keyword">else</span> i = i - j + <span class="hljs-number">2</span>, j = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (j &gt; T.length) <span class="hljs-keyword">return</span> i - T.length;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="模式串匹配-kmp">模式串匹配 - KMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s, t;<br>    cin &gt;&gt; s &gt;&gt; t;  <span class="hljs-comment">// 下标从1开始</span><br>    n = s.<span class="hljs-built_in">size</span>(), m = t.<span class="hljs-built_in">size</span>(), s = <span class="hljs-string">&quot; &quot;</span> + s, t = <span class="hljs-string">&quot; &quot;</span> + t;<br><br>    nx[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br>        nx[i] = nx[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (nx[i] &amp;&amp; t[i] != t[nx[i] + <span class="hljs-number">1</span>])   nx[i] = nx[nx[i]];<br>        nx[i] += (t[i] == t[nx[i] + <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &lt;= n;) &#123;<br>        <span class="hljs-keyword">while</span> (j != <span class="hljs-number">1</span> &amp;&amp; s[i] != t[j])  j = nx[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == t[j])   i++, j++;<br>        <span class="hljs-keyword">else</span>    i++;<br>        <br>        <span class="hljs-keyword">if</span> (j == m + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, i - m);<br>            j = nx[m] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="数组">数组</h2><p>设数组开始存储位置为 $$LOC(0,0)$$，存储每个元素需要 L 个存储单元</p><p>则数组元素 $a[i][j]$ 的存储位置为：</p><p>$$LOC(i,j)=LOC(0,0)+(n*i+j)*L$$</p><br><p><strong>n维数组</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/B5FB0C24CFAF46274BBED7700E72FDAA.jpg" alt="img"></p><br><h2 id="广义表">广义表</h2><p>（1）广义表中的数据元素有相对次序：一个直接前驱和一个直接后继</p><p>（2）广义表的长度定义为最外层所包含元素的个数：</p><p>如：C = (a, ( b, d ) ) 是长度为 2 的广义表</p><p>（3）广义表的深度定义为该广义表展开后所含括号的重数：</p><p>A = ( b, d ) 的深度为 1，B = ( A, d ) 的深度为 2，C = ( f, B, h ) 的深度为 3</p><p>PS：“原子” 的深度为 0;  “空表” 的深度为 1</p><p>（4）表头和表尾：非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</p><br><ul><li>对任意一个非空的广义表，其表头可能是单元素，也可能是广义表</li><li>对任意一个非空的广义表，其表尾一定是广义表</li><li>表尾是由除了表头以外的其余元素组成的广义表，所以，需要在表尾的直接元素外面再加一层括号</li></ul><br><h1 id="树">树</h1><p><strong>树的属性：</strong></p><ul><li><strong>结点的度</strong>（Degree）：结点的子树个数</li><li><strong>树的度</strong>：树的所有结点中最大的度数</li><li><strong>叶子结点</strong>（Leaf）：度为 0 的结点，也叫<strong>终端结点</strong></li><li><strong>结点的层次</strong>（Level）：规定根结点在1层，其他任一结点的层数是其父结点的层数加1</li><li><strong>树的深度</strong>（Depth）：树中所有结点中的最大层次</li></ul><br><p><strong>树的性质：</strong></p><ol><li>树中的结点数 = 总度数 + 1</li><li>度为 m 的树第 i 层 至多 有 $m^{i − 1}$ 个结点</li><li>具有 n 个结点的 m 叉树的最小高度为 $log_m(n(m-1)+1)$</li></ol><br><p><strong>度为m的树、m叉树的区别</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230602094721628.png" alt="image-20230602094721628"></p><br><h2 id="二叉树">二叉树</h2><ul><li><p>第 i 层最多有 $2^{i-1}$ 个结点</p></li><li><p>高度为 h 的二叉树至多有 $2^h-1$ 个结点</p></li><li><p>对任何一课二叉树 T，如果其叶子结点数为 $n_0$，度为 2 的结点数为 $n_2$，则</p><ul><li>$n_0=n_2+1$</li></ul></li><li><p>具有 n 个结点的完全二叉树的深度为 $\lfloor{log_2n}\rfloor+1$</p></li><li><p>如果对一棵有 n 个结点的完全二叉树的结点按层序编号，则对任一结点 i</p><ul><li>如果 i = 1，则结点 i 是二叉树的根；如果 i &gt; 1，则其双亲是结点$\lfloor{i/2}\rfloor$</li><li>如果 2i &gt; n，则结点 i 无左孩子；否则其左孩子是 2i</li><li>如果 2i + 1 &gt; n，则结点之无右孩子；否则其右孩子是 2i + 1</li></ul></li></ul><br><h3 id="二叉树的存储结构">二叉树的存储结构</h3><p>（1）顺序存储</p><p>这种顺序存储方式仅仅适用于完全二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100  <span class="hljs-comment">// 二叉树的最大结点数</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><span class="hljs-keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];<br>SqBiTree bt;<br></code></pre></td></tr></table></figure><br><p>（2）链式存储结构</p><p>在n个结点的二叉链表中，有 $n+1$ 个空指针域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> &#123;<br>    TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lChild, *rChild;<br>&#125; BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><br><h3 id="二叉树的遍历">二叉树的遍历</h3><p>二叉树的遍历，包括先序遍历、中序遍历、后序遍历和层序遍历</p><br><p>由二叉树的先序序列和中序序列，或后序序列和中序序列可以确定唯一一棵二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1     <span class="hljs-comment">// 鎴愬姛</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0  <span class="hljs-comment">// 澶辫触</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> &#123;<br>    TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lChild, *rChild;<br>&#125; BiTNode, *BiTree;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(BiTree &amp;T)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, T-&gt;data);<br>&#125;<br><br><br><span class="hljs-comment">// 创建二叉树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTNode</span><span class="hljs-params">(BiTree &amp;T)</span> </span>&#123;<br>    T = (BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br>    TElemType e;<br>    std::cin &gt;&gt; e;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-number">-1</span>) T = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        T-&gt;data = e;<br>        T-&gt;lChild = <span class="hljs-literal">NULL</span>;<br>        T-&gt;rChild = <span class="hljs-literal">NULL</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;请输入&quot;</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot;的左儿子值（-1代表无左儿子）：&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">CreateBiTNode</span>(T-&gt;lChild);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;请输入&quot;</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot;的右儿子值（-1代表无右儿子）：&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">CreateBiTNode</span>(T-&gt;rChild);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function">Status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree&amp; T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-built_in">visit</span>(T);<br>    <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lChild);<br>    <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rChild);<br>&#125;<br><br><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree&amp; T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lChild);<br>    <span class="hljs-built_in">visit</span>(T);<br>    <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rChild);<br>&#125;<br><br><span class="hljs-comment">// 后序遍历</span><br><span class="hljs-function">Status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree&amp; T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lChild);<br>    <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rChild);<br>    <span class="hljs-built_in">visit</span>(T);<br>&#125;<br><br><span class="hljs-comment">// 层次遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrderTraverse</span><span class="hljs-params">(BiTree T)</span> </span>&#123;<br>    queue&lt;BiTNode*&gt; tree;<br>    tree.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-keyword">while</span> (!tree.<span class="hljs-built_in">empty</span>()) &#123;<br>        BiTNode* p = tree.<span class="hljs-built_in">front</span>();<br>        tree.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (p-&gt;lChild != <span class="hljs-literal">NULL</span>) &#123;<br>            tree.<span class="hljs-built_in">push</span>(p-&gt;lChild);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p-&gt;rChild != <span class="hljs-literal">NULL</span>) &#123;<br>            tree.<span class="hljs-built_in">push</span>(p-&gt;rChild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="线索二叉树">线索二叉树</h2><p>利用二叉链表中的空指针域：</p><p>如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱</p><p>如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继</p><p>这种改变指向的指针称为“线索&quot;，加上了线索的二叉树称为线索二叉树</p><p>对二叉树按某种遍历次序使其变为线索二叉树的过程叫线索化</p><br><p>LTag： 若 LTag=0，lchild域指向左孩子；</p><p>若 LTag=1，lchild域指向其前驱。</p><p>RTag： 若 RTag=0，rchild域指向右孩子；</p><p>若 RTag=1，rchild域指向其后继。</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607092648463.png" alt="image-20230607092648463"></p><br><h2 id="树和森林">树和森林</h2><h3 id="表示方法">表示方法</h3><p>（1）双亲表示法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span> &#123;<br>    TElemType data;<br>    <span class="hljs-type">int</span> parent;<br>&#125; PTNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    PTNode nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> root, n;    <span class="hljs-comment">// 根节点的位置和结点个数</span><br>&#125; PTree;<br></code></pre></td></tr></table></figure><br><p>（2）孩子链表法</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605095002276.png" alt="image-20230605095002276"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><br><span class="hljs-comment">// 孩子结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *next;<br>&#125; *ChildPtr;<br><br><span class="hljs-comment">// 双亲结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    TElemType data;<br>    ChildPtr firstchild;<br>&#125; CTbox;<br><br><span class="hljs-comment">// 树结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    CTbox nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> root, n;<br>&#125; CTree;<br></code></pre></td></tr></table></figure><br><p>（3）孩子兄弟表示法</p><p>用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一 个兄弟结点</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605095929179.png" alt="image-20230605095929179"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> &#123;<br>    TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> *firstchild, *nextsibling;<br>&#125; CSNode, *CSTree;<br></code></pre></td></tr></table></figure><br><h3 id="与二叉树的相互转换">与二叉树的相互转换</h3><p><strong>将树转换成二叉树</strong></p><p>①加线：在兄弟之间加一连线</p><p>②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p><p>③旋转：以树的根结点为轴心，将整树顺时针转45°</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/C687CE919D2723C53A440A1BA7BA80C0.jpg" alt="img"></p><br><p><strong>将二叉树转换成树</strong></p><p>①加线：若p结点是双亲结点的左孩子，则将p沿分支找到的所有右孩子，都与p的双亲用线连起来</p><p>②抹线：抹掉原二叉树中双亲与右孩子之间的连线</p><p>③调整：将结点按层次排列，形成树结构</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/73E2D00D2B89E716C9C6DC0CE63E0765.jpg" alt="img"></p><br><p><strong>将森林转换成二叉树</strong></p><p>先把每棵树变成二叉树</p><p>再把各个根结点相连，再旋转</p><br><p><strong>将二叉树转换成森林</strong></p><p>将二叉树中根结点与其沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树</p><p>再将孤立的二叉树还原成树</p><br><h3 id="遍历">遍历</h3><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605101754867.png" alt="image-20230605101754867"></p><br><p><strong>2. 森林的遍历</strong></p><p>（1）先序遍历</p><p>依次从左到右对森林中的每一棵树进行先根遍历</p><p>（2）中序遍历</p><p>依次从左到右对森林中的每一棵树进行后根遍历</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605102220269.png" alt="image-20230605102220269"></p><br><h2 id="哈夫曼树">哈夫曼树</h2><p>树的路径长度：从树根到每一个结点的路径长度之和</p><p>结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积</p><p>树的带权路径长度：树中所有叶子结点的带权路径长度之和</p><br><p>哈夫曼树：最优树，就是带权路径长度(WPL)最短的树</p><p>PS：&quot;带权路径长度最短”是在度相同的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等</p><br><p><strong>哈夫曼算法：</strong></p><p>（1）根据 n 个给定的权值构成 n 棵二叉树的森林</p><p>（2）在森林中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和</p><p>（3）在森林中删除这两棵树，同时将新得到的二叉树加入森林中</p><p>（4）重复（2）（3）直到森林中只剩下一棵树</p><p>PS：哈夫曼树中共有 $2n-1$ 个结点，且其所有的分支结点的度均不为 1</p><br><p><strong>哈夫曼编码：</strong></p><ol><li>统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）</li><li>利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短</li><li>在哈夫曼树的每个分支上标上0或1 ：<ul><li>结点的左分支标0，右分支标1</li><li>把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码</li></ul></li></ol><br><p><strong>为什么哈夫曼编码能够保证是前缀编码?</strong></p><p>因为没有一片树叶是另一片树叶的祖先， 所以每个叶结点的编码就不可能是其它叶结点编码的前缀</p><p><strong>为什么哈夫曼编码能够保证字符编码总长最短?</strong></p><p>因为哈夫曼树的带权路径长度最短，故字符编码的总长最短</p><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>** HuffmanCode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> parent, lch, rch;<br>&#125; HTNode, *HuffmanTree;<br><br><span class="hljs-comment">// 在HT[1...idx]选择 parent为0 且 weight最小的两个结点，序号为s1, s2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Select</span><span class="hljs-params">(HuffmanTree&amp; HT, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span>&amp; s1, <span class="hljs-type">int</span>&amp; s2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> min1 = INT_MAX, min2 = INT_MAX;<br>    s1 = s2 = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= idx; i++) &#123;<br>        <span class="hljs-keyword">if</span> (HT[i].parent)   <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (HT[i].weight &lt;= min1) &#123;<br>            min2 = min1, min1 = HT[i].weight;<br>            s2 = s1, s1 = i;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (HT[i].weight &lt;= min2) &#123;<br>            min2 = HT[i].weight;<br>            s2 = i;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 构造哈夫曼树和哈夫曼编码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatHuffmanTree</span><span class="hljs-params">(HuffmanTree&amp; HT, HuffmanCode HC, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;<br>    HT = (HTNode*)<span class="hljs-built_in">malloc</span>((m + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(HTNode));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        HT[i].lch = HT[i].rch = HT[i].parent = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        std::cin &gt;&gt; HT[i].parent;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> s1, s2;<br>        <span class="hljs-built_in">Select</span>(HT, i - <span class="hljs-number">1</span>, s1, s2);<br>        HT[s1].parent = HT[s2].parent = i;<br>        HT[i].lch = s1, HT[i].rch = s2;<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>    &#125;<br><br>    <span class="hljs-comment">// 从叶子到根逆向求每个字符的哈夫曼编码</span><br>    HC = (HuffmanCode)<span class="hljs-built_in">malloc</span>((n + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*));<br>    <span class="hljs-type">char</span>* cd = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>    cd[n - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> start = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = i, f = HT[i].parent; f; c = f, f = HT[f].parent) &#123;<br>            <span class="hljs-keyword">if</span> (HT[f].lch == c) cd[--start] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">else</span> cd[--start] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125;<br>        HC[i] = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>((n - start) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>        <span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(cd);<br>&#125;<br></code></pre></td></tr></table></figure><br><h1 id="图">图</h1><p>图的逻辑结构：多对多</p><p><strong>连通、连通图和连通分量：</strong></p><p>在无向图中，若从顶点v 到顶点w 有路径存在，则称v 和w 是连通的。</p><p>若图G 中任意两个顶点都是连通的，则称图G 为连通图，否则称为非连通图。</p><p>无向图中的极大连通子图称为连通分量</p><p><strong>强连通图、强连通分量：</strong></p><p>在有向图中，若从顶点v 到顶点w 和从顶点w 到项点v 之间都有路径，则称这两个顶点是强连通的</p><p>若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量</p><br><h2 id="存图">存图</h2><p>主要有<strong>邻接矩阵</strong>和<strong>邻接表</strong>两种存储结构</p><p><strong>邻接矩阵多用于稠密图，邻接表多用于稀疏图</strong></p><br><h3 id="邻接矩阵">邻接矩阵</h3><p><strong>无向图：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605153253588.png" alt="image-20230605153253588"></p><ol><li>无向图的邻接矩阵一定是一个对称矩阵。因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素</li><li>对于无向图，邻接矩阵的第i 行（或第 i 列）中非零元素的个数正好是第 i 个顶点的度</li><li>求顶点 $v_i$ 的所有邻接点就是将矩阵中第 i 行元素扫描一遍，$ A[i][j]=1$ 就是邻接点</li></ol><br><p><strong>有向图：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605153229053.png" alt="image-20230605153229053"></p><ol><li>主对角线上数值依然为0。但因为是有向图，所以此矩阵并不对称</li><li>有向图中，顶点 $v_i$ 的入度为是第 $v_i$ 列各数之和。出度为第 $v_i$ 行的各数之和</li></ol><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTEX_NUM 20  <span class="hljs-comment">// 最大顶点个数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF INT_MAX</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;  <span class="hljs-comment">// 顶点的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;      <span class="hljs-comment">// 边的数据类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcCell</span> &#123;<br>&#125; ArcCell;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    VerTexType vexs[MAX_VERTEX_NUM];               <span class="hljs-comment">// 顶点表</span><br>    ArcType arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];  <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;  <span class="hljs-comment">// 图当前的点数和边数</span><br>&#125; MGraph;<br><br><span class="hljs-comment">// 找到顶点对应的下标</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(MGraph &amp;G, <span class="hljs-type">char</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (G.vexs[i] == x) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(MGraph&amp; G)</span> </span>&#123;<br>    std::cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<br><br>    <span class="hljs-comment">// 输入点的信息</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>        std::cin &gt;&gt; G.vexs[i];<br>    <br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; G.arcnum; j++)<br>            G.arcs[i][j] = INF;<br>    <br>    <span class="hljs-comment">// 存边</span><br>    <span class="hljs-type">char</span> v1, v2;<br>    <span class="hljs-type">int</span> w;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++) &#123;<br>        std::cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<br>        <span class="hljs-type">int</span> i = <span class="hljs-built_in">LocateVex</span>(G, v1);<br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        G.arcs[i][j] = w;<br>        G.arcs[j][i] = w;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表">邻接表</h3><p><strong>无向图：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605164940709.png" alt="image-20230605164940709"></p><p><strong>有向图：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605165021980.png" alt="image-20230605165021980"></p><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTEX_NUM 20  <span class="hljs-comment">// 最大顶点个数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF INT_MAX</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> VerTexType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> &#123;<br>    <span class="hljs-type">int</span> adjvex;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>* nextarc;<br>&#125; ArcNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span> &#123;<br>    VerTexType data;<br>    ArcNode* firstarc;<br>&#125; VNode, AdjList[MAX_VERTEX_NUM];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    AdjList vertices;<br>    <span class="hljs-type">int</span> vexnum, arcnum;  <span class="hljs-comment">// 当前的顶点数和边数</span><br>&#125; ALGraph;<br><br><span class="hljs-comment">// 找到顶点对应的下标</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(ALGraph&amp; G, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (G.vertices-&gt;data == x)  <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(ALGraph&amp; G)</span> </span>&#123;<br>    std::cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) &#123;<br>        std::cin &gt;&gt; G.vertices[i].data;<br>        G.vertices[i].firstarc = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> v1, v2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++) &#123;<br>        std::cin &gt;&gt; v1 &gt;&gt; v2;<br>        <span class="hljs-type">int</span> i = <span class="hljs-built_in">LocateVex</span>(G, v1);<br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        ArcNode *p1 = (ArcNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ArcNode));<br>        p1-&gt;adjvex = j;<br>        <span class="hljs-comment">// 头插法 v1-&gt;v2</span><br>        p1-&gt;nextarc = G.vertices[i].firstarc;<br>        G.vertices[i].firstarc = p1;<br>        <span class="hljs-comment">// 无向图 v2-&gt;v1（有向图则不需要）</span><br>        ArcNode *p2 = (ArcNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ArcNode));<br>        p1-&gt;adjvex = i;<br>        p2-&gt;nextarc = G.vertices[j].firstarc;<br>        G.vertices[j].firstarc = p2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="十字链表">十字链表</h3><p><strong>十字链表是有向图的一种链式存储结构</strong></p><p>对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。</p><p>十字链表就把邻接表与逆邻接表结合了起来</p><br><p><strong>我们重新定义顶点表结点结构：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605175600623.png" alt="image-20230605175600623"></p><p>其中firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout 表示出边表头指针，指向该顶点的出边表中的第一个结点。</p><p><strong>重新定义的边表结点结构：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605175644659.png" alt="image-20230605175644659"></p><p>其中 tailvex 是指弧起点在顶点表的下标，headvex 是指弧终点在顶点表中的下标</p><p>headlink是指入边表指针域，指向终点相同的下一条边</p><p>taillink是指边表指针域，指向起点相同的下一条边</p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/E1EB73315703F3AEB1178048935994D9.jpg" alt="img"></p><br><h3 id="邻接多重表">邻接多重表</h3><p><strong>邻接多重表是无向图的另一种链式存储结构。</strong></p><p>在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低</p><br><p><strong>重新定义的边表结点结构：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605180134589.png" alt="image-20230605180134589"></p><p>其中 ivex 和 jvex 是与某条边依附的两个顶点在顶点表中下标</p><p>ilink 指向依附顶点 ivex 的下一条边，jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构</p><p><strong>每个顶点也用一一个结点表示，它由如下所示的两个域组成</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605180230425.png" alt="image-20230605180230425"></p><p>其中，data 域存储该顶点的相关信息，firstedge 域指示第一条依附于该顶点的边</p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605180807904.png" alt="image-20230605180807904"></p><br><h2 id="图的遍历">图的遍历</h2><p>对于图的遍历来，通常有两种遍历次序方案：<strong>深度优先遍历</strong>和<strong>广度优先遍历</strong></p><br><p>（1）邻接矩阵存图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    VerTexType vexs[MAX_VERTEX_NUM];<br>    ArcType arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br>    <span class="hljs-type">int</span> vexnum, arcnum;<br>&#125; MGraph;<br><br><br><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(MGraph&amp; G, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    std::cout &lt;&lt; u &lt;&lt; endl;<br>    visited[u] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; G.vexnum; v++) &#123;<br>        <span class="hljs-keyword">if</span> (G.arcs[u][v] &amp;&amp; (!visited[v]))<br>            <span class="hljs-built_in">DFS</span>(G, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>（2）邻接表存图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> &#123;<br>    <span class="hljs-type">int</span> adjvex;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>* nextarc;<br>&#125; ArcNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span> &#123;<br>    VerTexType data;<br>    ArcNode* firstarc;<br>&#125; VNode, AdjList[MAX_VERTEX_NUM];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    AdjList vertices;<br>    <span class="hljs-type">int</span> vexnum, arcnum;  <span class="hljs-comment">// 当前的顶点数和边数</span><br>&#125; ALGraph;<br><br><br><span class="hljs-comment">// 邻接表进行DFS</span><br><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(ALGraph&amp; G, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[u])<br>        <span class="hljs-keyword">return</span>;<br><br>    std::cout &lt;&lt; u &lt;&lt; endl;<br>    visited[u] = <span class="hljs-literal">true</span>;<br><br>    ArcNode* tmp = G.vertices[u].firstarc;<br>    <span class="hljs-keyword">while</span> (tmp) &#123;<br>        <span class="hljs-type">int</span> v = tmp-&gt;adjvex;<br>        <span class="hljs-keyword">if</span> (!visited[v])<br>            <span class="hljs-built_in">DFS</span>(G, u);<br>        tmp = tmp-&gt;nextarc;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 邻接表进行BFS</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(ALGraph&amp; G, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-type">int</span> q[<span class="hljs-number">100</span>], h = <span class="hljs-number">0</span>, t = <span class="hljs-number">-1</span>;<br>    q[++t] = u; visited[u] = <span class="hljs-literal">true</span>;<br>    std::cout &lt;&lt; u &lt;&lt; endl;<br><br>    <span class="hljs-keyword">while</span> (h &lt;= t) &#123;<br>        <span class="hljs-type">int</span> now = q[h++];<br><br>        <span class="hljs-keyword">for</span> (ArcNode* tmp = G.vertices[now].firstarc; tmp; tmp = tmp-&gt;nextarc) &#123;<br>            <span class="hljs-type">int</span> v = tmp-&gt;adjvex;<br>            <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>                std::cout &lt;&lt; v &lt;&lt; endl;<br>                visited[v] = <span class="hljs-literal">true</span>;<br>                q[++t] = v;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="图的应用">图的应用</h2><h3 id="最小生成树">最小生成树</h3><p>一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的 n − 1 条边</p><p>若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路</p><p>其中边的权值之和最小的那棵生成树，称为<strong>最小生成树</strong></p><br><p><strong>最小生成树算法主要有 Prim 算法和 Kruskal 算法</strong></p><br><p><strong>Prim</strong></p><p>从一个顶点出发，在保证不形成回路的前提下，每找到并添加一条最短的边，就把当前形成的连通分量当做一个整体或者一个点看待，然后重复“找最短的边并添加”的操作。</p><br><p><strong>Kruskal</strong></p><p>初始时为只有 n 个顶点而无边的非连通图 T，每个顶点自成一个连通分量</p><p>然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边</p><p>若该边依附的顶点落在T中不同的连通分量上，则将此边加入 T</p><p>否则舍弃此边而选择下一条权值最小的边</p><p>以此类推，直至 T 中所有顶点都在一个连通分量上。</p><br><p>prim算法的时间复杂度$O(n^2)$，Kruskal算法的时间复杂度$O(mlogm)$</p><br><h3 id="最短路">最短路</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p><p>单源最短路 – Dijkstra</p><p>多源最短路 – Floyd</p><br><h2 id="有向无环图及其应用">有向无环图及其应用</h2><p>有向无环图：边有方向、图中无环</p><br><p>用一个有向图表示一个工程的各子工程及其相互制约的关系</p><p>其中以顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网</p><p>简称 AOV 网（Activity On Vertex）</p><p><strong>应用：拓扑排序</strong></p><br><p>用一个有向图表示一个工程的各子工程及其相互制约的关系</p><p>以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网</p><p>简称为 AOE 网（Activity On Edge）</p><p>AOE网具有以下两个性质：</p><ul><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生</li></ul><p><strong>应用：关键路径</strong></p><br><h3 id="拓扑排序">拓扑排序</h3><p>每个 AOV 网都有一个或多个拓扑排序序列</p><p><strong>构造拓扑排序：</strong></p><p>。在有向图中选一个没有前驱的顶点且输出</p><p>。从图中删除该顶点和所有以它为尾的弧</p><p>。重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点</p><br><p>我们可以通过拓扑排序来检测 AOV 网中是否存在环：</p><p>对有向图构造其顶点的拓扑序列，若网中所有顶点都在它的拓扑序列中，则该 AOV 网无环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> indegree[MAX_VERTEX_NUM];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(ALGraph G)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化栈，存储入度为0的顶点</span><br>    <span class="hljs-built_in">InitStack</span>(S);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (indegree[i] == <span class="hljs-number">0</span>) <span class="hljs-built_in">Push</span>(S, i);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">IsEmpty</span>(S)) &#123;<br>        <span class="hljs-built_in">Pop</span>(S, i);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br><br>        count++;<br>        <span class="hljs-keyword">for</span> (ArcNode* p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) &#123;<br>            <span class="hljs-type">int</span> v = p-&gt;adjvex;<br>            <span class="hljs-comment">// 入度为0，则入栈</span><br>            <span class="hljs-keyword">if</span> (!--indegree[v]) <span class="hljs-built_in">Push</span>(S, v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 输出顶点少了，有向图中有环，排序失败</span><br>    <span class="hljs-keyword">if</span> (count &lt; G.vexnum) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 拓扑排序成功</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="关键路径">关键路径</h3><p>关键路径 —— 路径长度最长的路径</p><p>路径长度 —— 路径上各活动持续时间之和</p><br><p>ve(vj) —— 表示事件 vj 的最早发生时间</p><p>vl(vj) —— 表示事件 vj 的最迟发生时间</p><p>e(i) —— 表示活动 ai 的最早开始时间</p><p>l(i) —— 表示活动 ai 的最迟开始时间</p><p>那么，l(i) - e(i) —— 表示完成活动 ai 的时间余量</p><p>时间余量为零的活动称为关键活动（一定在关键路径上）</p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/C3984E6DACA7E5DE073BF00655DEB6F2.jpg" alt="img"></p><br><p><strong>求解关键路径：</strong></p><p>从源点出发，令 ve (源点) = 0，按拓扑排序求其余顶点的最早发生时间 ve( )</p><p>从汇点出发，令 vl (汇点) = v，按逆拓扑排序求其余顶点的最迟发生时间 vl( )</p><p>根据各顶点的 ve() 值求所有弧的最早开始时间 e()</p><p>根据各顶点的 vl() 值求所有弧的最迟开始时间 l()</p><p>求 AOE 网中所有活动的时间余量，为零的活动构成关键路径</p><br><h1 id="查找">查找</h1><p>查找表是由同一类型的数据元素（或记录）构成的集合</p><p>由于&quot;集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构</p><br><p>关键字：用来标识一个数据元素（或记录）的某个数据项的值</p><ul><li>主关键字：可唯一地标识一个记录的关键字</li><li>次关键字：用以识别若干记录的关键字</li></ul><br><p>查找算法的评价指标：关键字的平均比较次数，也称平均查找长度（ASL）</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230606182536166.png" alt="image-20230606182536166"></p><br><h2 id="线性表的查找">线性表的查找</h2><p><strong>查找表的存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> KeyType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    KeyType key;  <span class="hljs-comment">// 关键字域</span><br>&#125; ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType* R;<br>    <span class="hljs-type">int</span> length;<br>&#125; SSTable;<br></code></pre></td></tr></table></figure><br><p><strong>（1）顺序查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable&amp; ST, KeyType key)</span> </span>&#123;<br>    ST.R[<span class="hljs-number">0</span>].key = key;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = ST.length; ST.R[i].key != key; i--) ;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找第 i 个元素需要比较 n - i + 1 次，平均查找长度 $ASL=(n+1)/2$</p><p>时间复杂度 $O(n)$</p><br><p><strong>（2）折半查找（二分查找）</strong></p><p>只适用于有序表，且限于顺序存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable&amp; ST, KeyType key)</span> </span>&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>, high = ST.length;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (ST.R[mid].key == key) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; ST.R[mid].key) high = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>平均查找长度 $ASL=log_2{(n+1)}-1$</p><p>时间复杂度 $O(logn)$</p><br><p><strong>（3）分块查找</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/C4EEC47DC62CD50FD66C6342B284B7D4.jpg" alt="img"></p><br><h2 id="树表的查找">树表的查找</h2><h3 id="二叉排序树"><strong>二叉排序树</strong></h3><p>二叉排序树或是空树，或是满足如下性质的二叉树：</p><ul><li>若其左子树非空，则左子树上所有结点的值均小于根结点的值</li><li>若其右子树非空，则右子树上所有结点的值均大于等于根结点的值</li><li>其左右子树本身又各是一棵二叉排序树</li></ul><br><p>中序遍历二叉排列树得到的是一个非递减序列</p><p><strong>二叉排序树的存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> KeyType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> InfoType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    KeyType key;         <span class="hljs-comment">// 关键字域</span><br>    InfoType otherinfo;  <span class="hljs-comment">// 其他数据域</span><br>&#125; ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span> &#123;<br>    ElemType data;                    <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span> *lchild, *rchild;  <span class="hljs-comment">// 左右孩子指针</span><br>&#125; BSTNode, *BSTree;<br></code></pre></td></tr></table></figure><br><p><strong>查找（递归实现）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BSTree <span class="hljs-title">SearchBST</span><span class="hljs-params">(BSTree&amp; T, KeyType key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((!T) || key == T-&gt;data.key) <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data.key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild, key);<br>&#125;<br></code></pre></td></tr></table></figure><p>含有 n 个结点的二叉排序树的平均查找长度和树的形态有关</p><p>最好情况下：$ASL=log_2{n+ 1}-1$</p><p>最坏情况下退化为顺序查找：$ASL=(n+1)/2$</p><br><p><strong>插入</strong></p><ul><li>若二叉排序树为空，则插入结点作为根结点插入到空树中</li><li>否则，继续在其左、右子树上查找<ul><li>树中已有，不再插入</li><li>树中没有，查找直至某个叶子结点的左子树或右子树为空为止，则插入。结点应为该叶子结点的左孩子或右孩子</li></ul></li></ul><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">在根指针T所指二叉排序树中递归地查找其关键字等于key的数据元素</span><br><span class="hljs-comment">若查找成功，则指针p指向该数据元素结点，并返回TRUE</span><br><span class="hljs-comment">否则指针p指向查找路径上访问的最后一个结点并返回FALSE</span><br><span class="hljs-comment">指针f指向T的双亲，其初始调用值为NULL</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">Status <span class="hljs-title">SearchBST</span><span class="hljs-params">(BSTree T, KeyType key, BSTree f, BSTree&amp; p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!T) &#123;<br>        p = f;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T-&gt;data.key == key) &#123;<br>        p = T;<br>        <span class="hljs-keyword">return</span> TRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data.key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild, key, T, p);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild, key, T, p);<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">InsertBST</span><span class="hljs-params">(BSTree&amp; T, ElemType e)</span> </span>&#123;<br>    BSTree p;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SearchBST</span>(T, e.key, <span class="hljs-literal">NULL</span>, p)) &#123;<br>        BSTNode* s = (BSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BSTNode));<br>        s-&gt;data = e; s-&gt;lchild = s-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (!p) T = s;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.key &lt; p-&gt;data.key) p-&gt;lchild = s;<br>        <span class="hljs-keyword">else</span> p-&gt;rchild = s;<br>        <span class="hljs-keyword">return</span> TRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>删除</strong></p><p>（1）被删除的结点是叶子结点：直接删去该结点</p><p>（2）被删除的结点只有左子树或者只有右子树，直接用其左子树或者右子树替换它</p><p>（3）被删除的结点既有左子树，也有右子树</p><ul><li><p>以其中序前趋值替换之，然后再删除该前趋结点。前趋是左子树中最大的结点</p></li><li><p>也可以用其后继替换之，然后再删除该后继结点。后继是右子树中最小的结点</p></li></ul><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Delete</span><span class="hljs-params">(BSTree&amp; p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!p-&gt;rchild) &#123;<br>        BSTree q = p;<br>        p = p-&gt;lchild;<br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!p-&gt;lchild) &#123;<br>        BSTree q = p;<br>        p = p-&gt;rchild;<br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        BSTree q = p, s = p-&gt;lchild;<br>        <span class="hljs-comment">// 找到左子树中最大的结点</span><br>        <span class="hljs-keyword">while</span> (s-&gt;rchild) &#123;<br>            q = s; s = s-&gt;rchild;<br>        &#125;<br>        p-&gt;data = s-&gt;data;<br>        <span class="hljs-keyword">if</span> (q != p) q-&gt;rchild = s-&gt;lchild;  <span class="hljs-comment">// 重接 *q 的右子树</span><br>        <span class="hljs-keyword">else</span> q-&gt;lchild = s-&gt;lchild;         <span class="hljs-comment">// 重接 *q 的左子树</span><br>        <span class="hljs-built_in">free</span>(s); <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="平衡二叉树">平衡二叉树</h3><p>平衡二叉树（balanced binary tree），又称 AVL 树</p><p>一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：</p><ul><li>左子树与右子树的高度之差的绝对值小于等于 1</li><li>左子树和右子树也是平衡二叉排序树</li></ul><br><p>为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差</p><p>这个数字称为结点的平衡因子（BF）</p><p>平衡因子 = 结点左子树的高度 - 结点右子树的高度</p><p>根据平衡二叉树的定义，平衡二叉树上所有结点的平衡因子只能是 -1、1 或 0</p><br><p><strong>失衡时的调整：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/D41693E82076277C4BE64E23817787EE.jpg" alt="img"></p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/7B2638ABFDCB5C810D588A90EC2920E0.jpg" alt="img"></p><p>实际上就是找出中间的那个数当作根节点，比它大的放在左边，比它小的放在右边</p><br><p><strong>LL型</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/95A506EA1A4EDBD4B3187C64C93FF5B8.jpg" alt="img"></p><br><p><strong>RR型</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/062942B8CDD296464F20B3D73145421E.jpg" alt="img"></p><br><p><strong>LR型</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607095745819.png" alt="image-20230607095745819"></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/B8049C249B744B468E89882F56814FB1.jpg" alt="img"></p><br><p><strong>RL型</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607100339218.png" alt="image-20230607100339218"></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/89611D4C92163372C6A08A7FAEF28418.jpg" alt="img"></p><br><h2 id="散列表的查找">散列表的查找</h2><p>散列存储（哈希）：选取某个函数，依该函数按关键字计算元素的存储位置</p><p>冲突：不同的关键码映射到同一个散列地址</p><br><p><strong>构造好的散列函数：</strong></p><ul><li>所选函数尽可能简单，以便提高转换速度</li><li>所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费</li></ul><br><br><p><strong>构造散列函数考虑的因素：</strong></p><p>执行速度（即计算散列函数所需时间）</p><p>关键字的长度</p><p>散列表的大小</p><p>关键字的分布情况</p><p>查找频率</p><br><br><p><strong>散列表的构造方法：</strong></p><p>（1）直接定址法：$Hash(key)=a*key+b$</p><p>以关键码 key 的某个线性函数为散列地址</p><p>优：不会产生冲突；劣：空间效率低</p><br><p>（2）除留余数法：$Hash(key)=key\space mod\space p$</p><p>p 的选取：小于表长的一个质数</p><br><p>（3）其他方法</p><p>数字分析法、平方取中法、折叠法、随机数法等</p><br><br><p><strong>处理冲突的方法：</strong></p><p>（1）开放寻址法</p><p>有冲突时就去寻找下一个空的散列地址，并将数据元素存入</p><ul><li>线性探测：增量序列为 $1,2,…,q$</li><li>二次探测法：增量序列为 $1^2,-1^2,2^2,-2^2,…,q^2$</li><li>伪随机探测法：增量序列为伪随机数</li></ul><br><p>（2）链地址法（拉链法）</p><p>相同散列地址的记录链成一个单链表，m 个散列地址就设 m 个单链表</p><p>然后用一个数组将 m 个单链表的表头指针存储起来，形成一个动态的结构</p><p>例如：一组关键字为 {19，14，23，1，68，20，84，27，55，11，10，79 }</p><p>散列函数为 Hash（key）= key  mod  13，则如下图所示：</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607113532923.png" alt="image-20230607113532923"></p><p>非同义词不会冲突，链表上结点空间是动态申请的，适用于表长不确定的情况</p><br><p>还有其他的方法比如：</p><ul><li><p>再散列法（双哈希）</p></li><li><p>建立一个公共溢出区</p></li></ul><br><br><p><strong>散列表的查找：</strong></p><p>查找的过程其实就是构造的逆过程</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/E382A2EECC416D91603EF6225C227C49.jpg" alt="img"></p><br><p>使用平均查找长度ASL来衡量查找算法，ASL取决于：</p><p>散列函数、处理冲突的方法、散列表的装填因子（表中记录数 / 表长）</p><ul><li>散列表技术具有很好的平均性能，优于一些传统的技术</li><li>拉链法优于开放寻址法</li><li>除留余数法作散列函数优于其它类型函数</li></ul><br><h1 id="排序">排序</h1><p><strong>排序方法的分类：</strong></p><p>按数据存储介质：内部排序和外部排序</p><p>按比较器个数：串行排序和并行排序</p><p>按主要操作：比较排序和基数排序</p><p>按辅助空间：原地排序和非原地排序</p><p>按稳定性：稳定排序和非稳定排序</p><p>按自然性：自然排序和非自然排序</p><br><h2 id="插入排序">插入排序</h2><p>（1）顺序法：直接插入排序</p><p>（2）二分法：折半插入排序</p><p>（3）缩小增量：希尔排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 20</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> KeyType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> InfoType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    KeyType key;<br>    InfoType otherinfo;<br>&#125; RedType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    RedType r[MAXSIZE + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 0号位置作哨兵</span><br>    <span class="hljs-type">int</span> length;<br>&#125; SqList;<br></code></pre></td></tr></table></figure><br><br><h3 id="直接插入排序">直接插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= L.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (L.r[i].key &lt; L.r[i - <span class="hljs-number">1</span>].key) &#123;<br>            <span class="hljs-comment">// 复制为哨兵</span><br>            L.r[<span class="hljs-number">0</span>] = L.r[i];<br>            <span class="hljs-comment">// 记录后移</span><br>            <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; L.r[j].key &gt; L.r[<span class="hljs-number">0</span>].key; j--)<br>                L.r[j + <span class="hljs-number">1</span>] = L.r[j];<br>            <span class="hljs-comment">// 插入到正确的位置</span><br>            L.r[j] = L.r[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="折半插入排序">折半插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BInsertSort</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= L.length; i++) &#123;<br>        L.r[<span class="hljs-number">0</span>] = L.r[i];    <span class="hljs-comment">// 哨兵</span><br><br>        <span class="hljs-comment">// 二分查找</span><br>        <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>, high = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (L.r[<span class="hljs-number">0</span>].key &lt; L.r[mid].key) high = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 移动元素</span><br>        <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= high + <span class="hljs-number">1</span>; j--)<br>            L.r[j + <span class="hljs-number">1</span>] = L.r[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="希尔排序">希尔排序</h3><p>先将整个待排记录序列分割成若干子序列，分别进行直接插入排序</p><p>待整个序列中的记录&quot;基本有序”时，再对全体记录进行一次直接插入排序</p><p>算法特点：</p><p>1）缩小增量；2）多遍插入排序</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607170034782.png" alt="image-20230607170034782"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 顺序表的希尔排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellInsert</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> dk)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = dk + <span class="hljs-number">1</span>; i &lt;= L.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (L.r[i].key &lt; L.r[i - dk].key) &#123;<br>            L.r[<span class="hljs-number">0</span>] = L.r[i];<br>            <span class="hljs-keyword">for</span> (j = i - dk; j &gt; <span class="hljs-number">0</span> &amp;&amp; (L.r[<span class="hljs-number">0</span>].key &lt; L.r[j].key); j--)<br>                L.r[j + dk].key = L.r[j].key;<br>            L.r[j + dk] = L.r[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// dlta[] 为增量数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> dlta[], <span class="hljs-type">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++)<br>        <span class="hljs-built_in">ShellInsert</span>(L, dlta[i]);<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="交换排序">交换排序</h2><h3 id="冒泡排序">冒泡排序</h3><p>每趟不断将记录两两比较，并按“前小后大”规则交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i, j, flag = <span class="hljs-number">1</span>;<br>    RedType x;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= L.length - <span class="hljs-number">1</span> &amp;&amp; flag; i++) &#123;<br>        flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= L.length - i; j++)<br>            <span class="hljs-keyword">if</span> (L.r[j].key &gt; L.r[j + <span class="hljs-number">1</span>].key) &#123;<br>                flag = <span class="hljs-number">1</span>;<br>                x = L.r[j];<br>                L.r[j] = L.r[j + <span class="hljs-number">1</span>];<br>                L.r[j + <span class="hljs-number">1</span>] = x;<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n^2)$，很拉</p><br><h3 id="快速排序">快速排序</h3><p>通过一趟排序，将待排序记录分割成独立的两部分</p><p>其中一部分记录的关键字均比另一部分记录的关键字小， 则可分别对这两部分记录进行排序，以达到整个序列有序</p><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    L.r[<span class="hljs-number">0</span>] = L.r[low];<br>    <span class="hljs-type">int</span> pivotkey = L.r[low].key;<br><br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey) high--;<br>        L.r[low] = L.r[high];<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey) low++;<br>        L.r[high] = L.r[low];<br>    &#125;<br>    L.r[low] = L.r[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QSort</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivotloc = <span class="hljs-built_in">Partition</span>(L, low, high);<br>        <span class="hljs-built_in">QSort</span>(L, low, pivotloc - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">QSort</span>(L, pivotloc + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速排序不适于对原本有序或基本有序的记录序列进行排序。</p><p>所以快排不是自然排序</p><br><h2 id="选择排序">选择排序</h2><h3 id="简单选择排序">简单选择排序</h3><p>在待排序的数据中选出最大（小）的元素放在其最终的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= L.length; i++) &#123;<br>        <span class="hljs-comment">// 找到 L.r[i...L.length] 中最小元素的位置</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">SelectMinKey</span>(L, i);<br>        <span class="hljs-keyword">if</span> (i != j) <span class="hljs-built_in">swap</span>(L.r[i], L.r[j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="堆排序">堆排序</h3><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607181213182.png" alt="image-20230607181213182"></p><p><strong>堆的调整：</strong></p><p>小根堆：</p><ul><li>输出堆顶元素之后，以堆中最后一个元素替代之</li><li>然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换</li><li>重复上述操作，直至叶子结点，将得到新的堆，称这个过程为&quot;筛选&quot;</li></ul><br><p><strong>建堆：</strong></p><p>从一个无序序列建堆的过程就是一个反复“筛选”的过程</p><p>我们从最后一个非叶子结点开始向前调整（即编号为 n/2 的结点开始）</p><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> SqList HeapType; <span class="hljs-comment">// 采用顺序存储表示堆</span><br><br><span class="hljs-comment">// 调整H.r[s...m]为一个大根堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(HeapType&amp; H, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    RedType rc = H.r[s];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * s; j &lt;= m; j *= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// j为较大元素的下标</span><br>        <span class="hljs-keyword">if</span> (j &lt; m &amp;&amp; (H.r[j].key &lt; H.r[j + <span class="hljs-number">1</span>].key)) j++;<br>        <span class="hljs-keyword">if</span> (rc.key &gt;= H.r[j].key) <span class="hljs-keyword">break</span>;<br>        H.r[s] = H.r[j];<br>        s = j;<br>    &#125;<br>    H.r[s] = rc;<br>&#125;<br><br><span class="hljs-comment">// 对 R[1] 到 R[n] 进行堆排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(HeapType&amp; H)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = H.length / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) <span class="hljs-built_in">HeapAdjust</span>(H, i, H.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = H.length; i &gt; <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-built_in">swap</span>(H.r[<span class="hljs-number">1</span>], H.r[i]);<br>        <span class="hljs-built_in">HeapAdjust</span>(H, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="归并排序">归并排序</h2><p>将两个或两个以上的有序子序列“归并”为一个有序序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将有序的 SR[i..m]和SR[m+1..n]合并成有序的TR[i..n]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(RedType SR[], RedType TR[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j, k;<br>    <span class="hljs-keyword">for</span> (j = m + <span class="hljs-number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) &#123;<br>        <span class="hljs-keyword">if</span> (SR[i].key &lt; SR[j].key) TR[k] = SR[i++];<br>        <span class="hljs-keyword">else</span> TR[k] = SR[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= m) TR[k++] = SR[i++];<br>    <span class="hljs-keyword">while</span> (j &lt;= n) TR[k++] = SR[j++];<br>&#125;<br><br><span class="hljs-comment">// 将 SR[s..t] 归并为 TR[s..t]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MSort</span><span class="hljs-params">(RedType SR[], RedType TR[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == t) TR[s] = SR[s];<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> mid = (s + t) / <span class="hljs-number">2</span>;<br>        RedType tmp[MAXSIZE];<br>        <span class="hljs-built_in">MSort</span>(SR, tmp, s, mid);<br>        <span class="hljs-built_in">MSort</span>(SR, tmp, mid + <span class="hljs-number">1</span>, t);<br>        <span class="hljs-built_in">Merge</span>(tmp, TR, s, mid, t);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123;<br>    <span class="hljs-built_in">MSort</span>(L.r, L.r, <span class="hljs-number">1</span>, L.length);<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="基数排序">基数排序</h2><p>也叫桶排序或箱排序：</p><p>设置若干个箱子，将关键字为k的记录放入第k个箱子，然后在按序号将非空的连接</p><p>根据关键字排序，每个关键字进行一趟操作</p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/83D783C73CD2E88C81A8667882BBCD74.jpg" alt="img"></p></be></font>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】Linux</title>
      <link href="/post/e511c25d.html"/>
      <url>/post/e511c25d.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-网络连接三种模式">1 网络连接三种模式</h1><ul><li>桥接模式</li></ul><p>虚拟主机的 ip 和本地主机 ip 可以互相访问，虚拟机也可以访问互联网，虚拟机相当于互联网中的一台主机，在桥接模式下，虚拟机 ip 地址需要与主机在同一个网段，如果需要联网，则网关与 DNS 需要与主机网卡一致</p><p>虚拟系统可以和外部系统相互通讯，但是容易造成 IP 冲突</p> <br><ul><li>NAP模式</li></ul><p>虚拟机可以访问互联网和本地（物理）主机，但本地主机不可以访问虚拟机。</p><p>网络地址转换模式。虚拟系统可以和外部（间接）联系，不会造成 IP 冲突</p> <br><ul><li>主机模式</li></ul><p>独立系统，不与外部发生联系</p><p>虚拟机不可以访问本地主机互联网，发现虚拟机和本地（物理）主机网络是隔离的</p><br><h1 id="2-linux目录结构">2 Linux目录结构</h1><p>linux 的文件系统是采用级层式的树状目录结构，在此结构的最上层是根目录 “/”，然后再此目录下创建其他的目录</p><p><strong>可以说，Linux 中的一切都是文件，具体的目录结构有：</strong></p><ul><li>/bin</li></ul><p>是 Binary 的缩写，这个目录存放着最经常使用的命令</p><ul><li>/sbin</li></ul><p>s就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序</p><ul><li>/home</li></ul><p>存放普通用户的主目录，在 Linux 中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名</p><ul><li>/root</li></ul><p>该目录为系统管理员，也称作超级权限者的用户主目录</p><ul><li>/etc</li></ul><p>所有的系统管理所需要的配置文件和子目录</p><ul><li>/usr</li></ul><p>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows 下的 program files 目录</p><ul><li>/boot</li></ul><p>存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件</p><ul><li>/proc</li></ul><p>这个目录是一个虛拟的目录，它是系统内存的映射，访问这个目录来获取系统信息</p><ul><li>/srv</li></ul><p>service 缩写，该目录存放一些服务启动之后需要提取的数据</p><ul><li>/sys</li></ul><p>这是 linux2.6 内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统 sysfs</p><ul><li>/tmp</li></ul><p>这个目录是用来存放一些临时文件的</p><ul><li>/ dev</li></ul><p>类似于 windows 的设备管理器，把所有的硬件用文件的形式存储</p><ul><li>/media</li></ul><p>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下</p><ul><li>/mnt</li></ul><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在 /mnt/ 上，然后进入该目录就可以查看里的内容了</p><ul><li>/opt</li></ul><p>这是给主机额外安装软件所摆放的目录，如安装 ORACLE 数据库就可放到该目录下。默认为空</p><ul><li>/lib</li></ul><p>系统开机所需要最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库</p><ul><li>/lost + found</li></ul><p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</p><ul><li>/usr/local</li></ul><p>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序</p><ul><li>/var</li></ul><p>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件<br><br></p><h1 id="3-vim-vi">3 vim / vi</h1><p>Linux 系统会内置 vi 文本编辑器<br>Vim 具有程序编辑的能力，可以看做是 Vi 的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用</p><br><h3 id="常用的三种模式">常用的三种模式</h3><ol><li>正常模式</li></ol><p>以 vim 打开一个档案就直接进入一般模式（默认模式）。在这个模式中，可以使用 [上下左右] 按键来移动光标，可以使用 [删除字符] 或 [删除整行] 来处理档案内容，也可以使用复制、粘贴来处理文件数据</p><ol start="2"><li>插入模式</li></ol><p>按下 i，I，o，O，a，A，r，R 等任何一个字母之后才会进入编辑模式，一般来说按 i 即可</p><ol start="3"><li>命令行模式</li></ol><p>先 esc 再输入 : 就进入命令行模式。在这个模式当中，可以提供你相关指令。完成读取、存盘、替换、离开 vim、显示行号等的动作则是在此模式中达成的</p><br><p>命令行模式下的常用指令有</p><p>:wq         – 保存并退出</p><p>:q            – 退出</p><p>:q!           – 强制退出不保存</p><br><table><thead><tr><th>常用的快捷键</th></tr></thead><tbody><tr><td>1.  拷贝当前行 yy，拷贝当前行向下的5行 5yy，并粘贴（输入 p ）</td></tr><tr><td>2.  删除当前行 dd，删除当前行向下的5行 5dd</td></tr><tr><td>3.  在文件中查找某个单词 [命令行模式下  /  关键字，回车查找，输入 n 就是查找下一个]</td></tr><tr><td>4.  设置文件的行号，取消文件的行号 [命令行模式下  :et  nu  和  :set  nonu]</td></tr><tr><td>5.  编辑 /etc/profile 文件，使用快捷键到该文档的最末行 [G] 和最首行 [gg]</td></tr><tr><td>6.  在一个文件中输入 “hello” 然后又撤销这个动作[u]</td></tr></tbody></table><br><h1 id="4-基本指令">4 基本指令</h1><h2 id="41-关机-amp-重启">4.1 关机 &amp; 重启</h2><p>shutdown  -h  now           立即关机</p><p>shutdown  -h  1                 一分钟后关机</p><p>shutdown  -r  now            立即重启</p><p>halt                 关机</p><p>reboot            重启</p><p>sync                把内存的数据同步到磁盘</p><br><p>PS：</p><ol><li>不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中</li><li>目前的 shutdown  /  reboot  /  halt 等命令均已经在关机前进行了 sync，但建议谨慎</li></ol><br><h2 id="42-切换用户">4.2 切换用户</h2><ul><li>登录时尽量少用 root 帐号登录，因为它是系统管理员，有最大的权限，避免操作失误</li><li>可以利用普通用户登录，登录后再用 “su  -  用户名” 命令来切换成系统管理员身份</li><li>输入 logout 即可注销用户</li></ul><br><ul><li>logout 注销指令在 图形运行级别 无效，在 运行级别3 下才有效</li></ul><p>如果以普通用户 tom 登陆，再切换为 root。此时 logout 会切换为 tom，再次 logout 则直接登出</p><br><h2 id="43-管理用户">4.3 管理用户</h2><p>Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><br><h3 id="添加用户">添加用户</h3><p>基本语法：useradd   用户名<br>PS：</p><ul><li>当创建用户成功后，会自动的创建和用户同名的家目录</li><li>也可以通过 useradd  -d 指定目录新的用户名，给新创建的用户指定家目录</li></ul><p>eg.  在创建家目录时直接指定家目录useradd   -d   /home/test   king</p><br><h3 id="指定-修改密码">指定 / 修改密码</h3><p>基本语法：passwd   用户名</p><br><h3 id="删除用户">删除用户</h3><p>基本语法：userdel   用户名</p><ul><li><p>删除用户 milan，但是保留家目录            userdel  milan</p></li><li><p>删除用户及其家目录                                   userdel  -r  milan</p></li></ul><p>PS：一般情况下家目录都不删，慎重删除</p><br><h3 id="查询用户信息">查询用户信息</h3><p>基本语法：id   用户名</p><br><br><h3 id="切换用户">切换用户</h3><p>基本语法：su   -   切换用户名</p><p>在操作 Linux 中，如果当前用户的权限不够，可以通过 su  -  指令，切换到高权限用户，比如 root</p><p>PS：</p><ul><li>从权限高的用户切换到权限低的用户，不需要输入密码，反之需要</li><li>当需要返回到原来用户时，使用 exit / logout 指令</li></ul><br><h3 id="查看当前用户">查看当前用户</h3><p>基本语法：whoami</p><br><h2 id="44-管理用户组">4.4 管理用户组</h2><p>类似于角色，系统可以对有共性的多个用户进行统一的管理</p><ul><li><p>新增组           groupadd   组名</p></li><li><p>删除组           groupdel     组名</p></li><li><p>增加用户时直接加上组                 useradd   -g   用户组   用户名</p></li></ul><p>当添加一个用户但是没有指定他的组时，会默认的创建一个与它同名的组，将该用户添加到这个组内</p><br><p>也可以在添加用户时直接指定组</p><p>eg. 增加一个用户 zwj，直接将他指定到 wudang</p><ol><li>groupadd   wudang</li><li>useradd   -g   wudang   zwj</li></ol><br><p>修改用户的组</p><p>基本语法：usermod   -g   [新组名]   [用户名]</p><p>eg.  把 zwh 再转移到 mojiao中</p><ol><li>groupadd   mojiao</li><li>usermod   -g   mojiao   zwj</li></ol><br><p>用户组的相关文件</p><p>（1）/etc/passwd 文件</p><p>用户（user）的配置文件，记录用户的各种信息</p><p>每行的含义</p><p>用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shell</p><br><p>（2）/etc/shadow 文件</p><p>口令的配置文件</p><p>每行的含义</p><p>登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p><br><p>（3）/etc/group 文件</p><p>组（group）的配置文件，记录 Linux 包含的组的信息</p><p>每行含义</p><p>组名：口令：组标识号：组内用户列表</p><br><h1 id="5-实用指令">5 实用指令</h1><h2 id="51-找回root密码">5.1 找回root密码</h2><p>如何找回root密码？</p><p>（1）首先，启动系统，进入开机界面，在界面中按 ‘e’ 进入编辑界面（要快</p><p>（2）进入编辑界面，使用键盘上的上下键把光标往下移动，找到以 “linux16” 开头内容所在的行数，在行的最后输入：init=/bin/sh</p><p>（3）输入完成后直接快捷键 ctrl+x，进入单用户模式</p><p>（4）接着在光标闪烁的位置输入：mount   -o   remount,rw/  再按回车确定</p><p>（5）在新的一行后面输入：passwd，完成后回车，输入密码后再次确认密码即可，修改密码后，会出现passwd… 的格式，则说明密码修改成功</p><p>（6）再在鼠标闪烁的位置输入：exec   /sbin/init 完成后按回车等待系统修改密码（时间较长），接着系统重启新密码生效</p><br><h2 id="52-帮助指令">5.2 帮助指令</h2><h3 id="man-获得帮助信息">man – 获得帮助信息</h3><p>基本语法：man   [命令或者配置文件]</p><p>按小写 q 退出</p><p>eg.  查看 ls 命令的帮助信息                 man   ls</p><p>ls 的常用选项：</p><p>-a    列出所有文件，包括以 ‘.’ 开头的隐含文件</p><p>-l    表示单列输出</p><ul><li><p>各选项可以混合使用，没有顺序要求      ls   -a   -l 表示单列显示所有文件</p></li><li><p>也可以指定要操作的目录                         ls   /root   -a   -l</p></li></ul> <br><h3 id="help-获得shell内置命令的帮助信息">help – 获得shell内置命令的帮助信息</h3><p>基本语法：help  [命令]</p><p>eg.  查询 cd 命令的帮助信息               help   cd</p><br><h2 id="53-文件目录">5.3 文件目录</h2><h3 id="pwd-指令-显示当前工作目录的绝对路径">pwd 指令 – 显示当前工作目录的绝对路径</h3><br><br><h3 id="cd-指令-切换到指定的目录下">cd 指令 – 切换到指定的目录下</h3><p>cd  ~ 或者 cd     回到当前登录用户的家目录</p><p>cd  …                   回到当前目录的上一级</p> <br> <br><h3 id="mkdir-创建目录">mkdir – 创建目录</h3><p>基本语法：mkdir   [选项]</p><p>-p    表示创建多级目录</p><p>eg.</p><ol><li>创建一个目录     mkdir   /home/tiger</li><li>创建多级目录     mkdir   -p   /home/animal/tiger</li></ol><br><br><h3 id="rmdir-删除空目录">rmdir – 删除空目录</h3><p>基本语法：rmdir   [选项]</p><p>PS:</p><ol><li>rmdir 删除的是空目录，如果目录下有内容是不可删除</li><li>如果想要删除非空目录，则需要使用 rm  -rf 删除 (谨慎</li></ol><p>eg.  删除一个目录               rmdir   /home/dog</p> <br> <br><h3 id="touch-创建一个空文件">touch – 创建一个空文件</h3><p>基本语法：touch   [文件名称]</p><p>eg.  在 /home 目录下，创建一个空文件 hello.txt                touch   /home   hello.txt</p> <br><br><h3 id="cp-拷贝文件到指定的目录下">cp – 拷贝文件到指定的目录下</h3><p>基本语法：cp   [选项]   source   dest</p><p>常用选项：</p><p>-r    递归复制整个文件夹</p><p>eg.</p><ol><li><p>将 /home/hello.txt 拷贝到 /home/bbb 目录下</p><ul><li>cp   /home/hello.txt   /home/bbb</li></ul></li><li><p>将 /home/bbb 整个文件夹拷贝到 /opt</p><ul><li>cp   -r   /home/bbb   /opt</li></ul></li></ol><p>PS：强制覆盖不提醒 \cp   -r   /home/bbb   /opt</p><br> <br><h3 id="rm-移除文件或者目录">rm – 移除文件或者目录</h3><p>基本语法：rm   [选项]</p><p>常用选项：</p><p>-r    递归删除整个文件夹</p><p>-f    强制删除不提示</p> <br> <br><h3 id="mv-移动文件与目录或者重命名">mv –  移动文件与目录或者重命名</h3><p>基本语法：</p><ul><li>mv   [文件或目录]   [文件或目录]               移动文件</li><li>mv   oldNameFile   newNameFile            重命名</li></ul> <br> <br><h3 id="cat-查看文件内容">cat – 查看文件内容</h3><p>基本语法：cat   [选项]   要查看的文件</p><p>常用选项：</p><p>-n    显示行号</p><p>eg.  查看 hello.txt 并显示行号              cat   -n   hello.txt</p><p>PS：cat 只能浏览文件并不能修改，为了方便一般会带上管道命令  |  more</p><p>（管道命令：将处理的结果交给下一个命令，即一种组合使用）</p> <br> <br><h3 id="more-以全屏的方式按页显示文本的内容">more – 以全屏的方式按页显示文本的内容</h3><p>是一个基于 VI 编辑器 的文本过滤器，内置了若干的快捷键</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>空格</td><td>向下翻一页</td></tr><tr><td>Enter</td><td>向下翻一行</td></tr><tr><td>q</td><td>离开，不再显示内容</td></tr><tr><td>Ctrl + F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl + B</td><td>返回上一屏</td></tr><tr><td>=</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行的行号</td></tr></tbody></table><br><br><h3 id="less-分屏查看文件内容">less – 分屏查看文件内容</h3><p>它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端</p><p>less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><p>基本语法：less   [要查看的文件]</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>空格</td><td>向下翻动一页</td></tr><tr><td>[pagedown]</td><td>向下翻动一页</td></tr><tr><td>[pageup]</td><td>向上翻动一页</td></tr><tr><td>/  字串</td><td>向下搜寻[字串]     n  -  向下查找  N  -  向上查找</td></tr><tr><td>?  字串</td><td>向下搜寻[字串]     n  -  向上查找  N  -  向下查找</td></tr><tr><td>q</td><td>离开less这个程序</td></tr></tbody></table><br><br><h3 id="echo-输出内容到控制台">echo – 输出内容到控制台</h3><p>基本：echo   [选项]   [输出内容]</p><p>$PATH                     环境变量</p><p>$POSTNAME          主机名</p><p>…</p><p>eg.</p><ol><li>使用 echo 指令输出环境变量                   echo $PATH</li><li>使用 echo 指令输出 hello,world!             echo “hello,world!”</li></ol> <br> <br><h3 id="head-显示文件的开头部分">head – 显示文件的开头部分</h3><p>默认情况下 head 指令显示文件的前10 行内容</p><p>基本语法：</p><p>head   [文件]</p><p>head   -n   x   [文件]        表示显示文件前 x 行，x可以是任何的数字</p> <br> <br><h3 id="tail-显示文件的开头部分">tail – 显示文件的开头部分</h3><p>默认情况下 tail 指令显示文件的最后10 行内容</p><p>基本语法：</p><p>head   [文件]</p><p>head   -n   x   [文件]        表示显示文件最后x行，x可以是任何的数字</p><p>head   -f   [文件]              表示实时追踪该文档的所有更新</p> <br> <br><h3 id="gt和-gtgt-输出重定向和追加">&gt;和 &gt;&gt;   – 输出重定向和追加</h3><p>基本语法：</p><p>Is   -l   &gt;   文件                         列表的内容写入文件a.txt中(覆盖写)</p><p>ls   -al   &gt;&gt;   文件                     列表的内容追加到文件aa.txt的末尾</p><p>cat   文件1   &gt;   文件2             将文件1的内容覆盖到文件2</p><p>echo   “内容”   &gt;&gt;   文件         将字符串内容追加到指定文件中</p><p>eg.</p><ol><li><p>将 /home 目录下的文件列表写入到 /home/info.txt 中，覆盖写入</p><ul><li>ls   -l   /home   &gt;   /home/info.txt[若无info.txt，则会创建]</li></ul></li><li><p>将当前日历信息追加到 /home/mycal 文件中</p><ul><li>cal   &gt;&gt;   /home/mycal （cal – 显示当前日历信息）</li></ul></li></ol> <br> <br><h3 id="ln-软链接">ln   –  软链接</h3><p>也称为符号链接，类似于 windows 里的快捷方式，主要存放了连接其他文件的路径</p><p>基本语法：ln   -s   [原文件或目录]   [软连接名]               给原文件创建了一个软链接</p><p>eg.</p><ol><li>在 /home目录下创建一个软连接 myroot，连接到 /root<ul><li>ln   -s   /root /home/myroot</li></ul></li><li>删除软连接 myroot<ul><li>rm   /home/myroot</li></ul></li></ol><p>PS：当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在目录</p> <br> <br><h3 id="history-查看已经执行过的历史命令">history – 查看已经执行过的历史命令</h3><p>也可以执行历史命令</p><p>基本语法：history</p><p>eg.</p><ol><li>显示所有的历史命令                     history</li><li>显示最近使用过的10 个指令        history 10</li><li>执行历史编号为5的指令                !5</li></ol><br><h2 id="54-时间日期">5.4 时间日期</h2><h3 id="date-显示当前的日期">date – 显示当前的日期</h3><p>基本语法：</p><p>date                  显示当前时间</p><p>date  +%Y        显示当前年份</p><p>date  +%m       显示当前月份</p><p>date  +%d        显示当前是哪一天</p><p>date  “+%Y-%m-%d  %H:%M:%S”             显示年月日时分秒</p> <br> <br><h3 id="date-设置日期">date – 设置日期</h3><p>基本语法：date   -s   字符串表示的时间</p><p>eg.  将系统的当前时间设置为 2020-11-03  20:02:10            date   -s   “2020-11-03   20:02:10”</p> <br><br><h3 id="cal-查看当前的日历信息">cal – 查看当前的日历信息</h3><p>基本语法：cal   [选项]           不加选项的话就默认显示本月的日历</p><p>eg.  显示2020年日历             cal   2020</p><br><h2 id="55-搜索查找">5.5 搜索查找</h2><h3 id="find-查找文件目录">find – 查找文件/目录</h3><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端</p><p>基本语法：find   [搜索范围]   [选项]</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-name&lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td></tr><tr><td>-user&lt;用户名&gt;</td><td>查找属于指定用户名所有的文件</td></tr><tr><td>-size&lt;文件大小&gt;</td><td>按照指定的文件大小查找文件</td></tr></tbody></table><p>eg.  查找整个 linux 系统下所有大于 200M 的文件           find   /   -size   +200M</p><p>PS：+n大于    -n小于    n等于，单位有 k，M，G</p><br><br><h3 id="locate-快速定位文件的路径">locate – 快速定位文件的路径</h3><p>locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件</p><p>Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。</p><p>基本语法：locate   [文件]</p><p>PS：由于 locate 指令基于数据库进行查找（速度很快），所以第一次运行之前，必须使用 updatedb 指令创建 locate 数据库</p><p>eg. 请使用 locate 指令快速定位 hello.txt 文件的位置</p><ul><li>updatedb</li><li>locate   hello.txt</li></ul><br><br><h3 id="which-可以查看某个指令在哪个目录下">which – 可以查看某个指令在哪个目录下</h3><p>基本语法：which   [指令]</p><p>eg.  查看 ls 指令在哪个文件下           which   ls</p> <br><br><h3 id="grep-和">grep 和 |</h3><p>grep 过滤查找，常常与 ‘|’ 一起使用，‘|’ 为管道符，表示将前一个命令的处理结果输出传送给后面的指令处理。</p><p>基本语法：grep   [选项]   查找内容   源文件</p><p>常用选项：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-v</td><td>反向匹配，只选择不匹配的行</td></tr><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-i</td><td>忽略字母大小写</td></tr></tbody></table><p>eg.</p><ol><li>在 shan.java 文件中查找 “main”，并显示其行号<ul><li>grep   -n   “main”   /home/shan.java</li><li>cat   /home/shan.java   |   grep   -n   “main”</li></ul></li><li>在 shan.java 文件中查找 “main”，显示其行号并且不区分大小写<ul><li>grep   -n   -i   “main”   /home/shan.java</li><li>cat   shan.java   |   grep   -n   -i   “main”</li></ul></li><li>在 abc 中不选择 a<ul><li>grep   -v   “a”</li></ul></li></ol><p>PS：-n  -i  可以缩写为  -ni  或者  -in</p><br><h3 id="gzip-压缩文件-gunzip-解压">gzip – 压缩文件 gunzip – 解压</h3><p>基本语法：</p><p>gzip   [文件]                     压缩文件，只能将文件压缩为*.gz文件</p><p>gunzip   [文件.gz]           解压缩文件</p><p>eg.</p><ol><li><p>gzip 压缩,将 /home 下的 shan.java 文件进行压缩</p><ul><li>gzip   /home/shan.java</li></ul></li><li><p>gunzip 解压，将 /home 下的 shan.java.gz 文件进行解压缩</p><ul><li>gunzip   /home/shan.java.gz</li></ul></li></ol><br><br><h3 id="zip-压缩文件-unzip-解压">zip – 压缩文件 unzip – 解压</h3><p>这个指令在项目打包发布时很常用</p><p>基本语法：</p><p>zip   [选项]   要压缩的内容</p><p>unzip   [选项]   要解压的内容</p><ul><li>zip 常用选项</li></ul><p>​-r    递归压缩，即压缩目录</p><ul><li>unzip的常用选项</li></ul><p>​-d  [目录]    指定解压后文件的存放目录</p><p>eg.</p><ol><li><p>将 /home/bbb 下的所有文件/文件夹进行压缩成 myhome.zip</p><ul><li>zip   -r   myhome.zip   /home/bbb/</li></ul></li><li><p>将 mybbb.zip 解压到 /opt/tmp 目录下</p><ul><li>mkdir   /opt/tmp</li><li>unzip   -d   /opt/tmp   /home/mybbb.zip</li></ul></li></ol><br><br><h3 id="tar-打包">tar – 打包</h3><p>可以压缩可以解压，根据选项而定，最后打包的文件是 .tar.gz 的文件</p><p>基本语法： tar   [选项]   XXX.tar.gz   打包的内容</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-C</td><td>解压到指定位置</td></tr><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr></tbody></table><p>eg.</p><ol><li><p>压缩个文件，将 /home/pig.txt  和 /home/cat.txt 压缩成 pc.tar.gz</p><ul><li>tar   -zcvf   pc.tar.gz   /home/pig.txt   /home/cat.txt</li></ul></li><li><p>将 /home 的文件夹压缩成 myhome.tar.gz</p><ul><li>tar   -zcvf   myhome.tar.gz   /home/</li></ul></li><li><p>将 pc.tar.gz 解压到当前目录</p><ul><li>tar   -zxvf   pc.tar.gz</li></ul></li><li><p>将 myhome.tar.gz 解压到 /opt/tmp2 目录下</p><ul><li>mkdir   /opt/tmp2</li><li>tar   -zxvf   /home/myhome.tar.gz   -C   /opt/tmp2</li></ul></li></ol><br><h1 id="6-组管理和权限管理">6 组管理和权限管理</h1><h2 id="61-组的介绍">6.1 组的介绍</h2><p>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</p><br><p><strong>（1）文件/目录 的所有者</strong></p><p>一般为文件的创建者，谁创建了该文件，就自然的成为该文件的所有者</p><br><p><strong>（2）文件/目录 的所在组</strong></p><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组（默认）</p><br><p><strong>（3）文件/目录 的其他组</strong></p><p>除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</p><br><h3 id="用户-的所在组">用户 的所在组</h3><p>在添加用户时，可以指定将该用户添加到哪个组中，同样的用 root 的管理权限可以改变某个用户所在的组</p><p><strong>改变用户所在组</strong></p><p>usermod   -g   [新组名]   [用户名]</p><p>usermod   -d   [目录名]   [用户名]          改变用户登录的初始目录</p><br><h2 id="62-权限的介绍">6.2 权限的介绍</h2><p>ls   -l 中显示的内容如下:</p><p>-rwxrw-r--    1    root    root    1213    Feb  2  09:39    abc</p><p>0 - 9 位：</p><p>第 0 位确定文件类型（d，l，c，b）</p><p>​    l 是链接，相当于 windows 的快捷方式</p><p>​    d 是目录，相当于 windows 的文件夹</p><p>​    c 是字符设备文件，鼠标，键盘</p><p>​    b 是块设备，比如硬盘</p><p>第 1 - 3 位确定该文件的所有者拥有的权限                   – User</p><p>第 4 - 6 位确定该文件的所在组拥有的权限                   – Group</p><p>第 7 - 9 位确定其他用户拥有该文件的权限                   – Other</p><br><p>1            文件：硬链接数            目录：子目录数</p><p>root      所有者</p><p>root      所在组</p><p>1213     文件大小（单位是字节，为目录时显示4096）</p><p>Feb  2  09:39     文件的最后修改日期</p><p>abc       文件名</p><br><p><strong>rwx 作用到文件</strong></p><p>[ r ] 代表可读（read）： 可以读取，查看</p><p>[ w ] 代表可写（write）： 可以修改，但是不可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写的权限</p><p>[ x ] 代表可执行（execute）：可以被执行</p><br><p><strong>rwx 作用到目录</strong></p><p>[ r ] 代表可读（read）： 可以读取，ls 查看目录内容</p><p>[ w ] 代表可写（write）： 可以修改，对目录下的内容 创建 / 删除 / 重命名</p><p>[ x ] 代表可执行（execute）：可以进入该目录，比如 cd 指令</p><br><h3 id="chmod-修改权限">chmod – 修改权限</h3><p><strong>第一种方式：通过 +、-、= 变更权限</strong></p><p>u：所有者      g：所在组     o：其他人     a：所有的人</p><p>chmod    u=rwx,g=rx,o=x    文件/目录名</p><br><p><strong>第二种方式：通过数字变更权限</strong></p><p>权限可以用数字来表示，r = 4，w = 2，x = 1</p><p>所以      chmod    u=rwx,g=rx,o=x    文件/目录名</p><p>相当于  chmod    751    文件/目录名</p><br><h3 id="chown-修改文件所有者">chown – 修改文件所有者</h3><p>修改所有者：chown   newowner   文件/目录</p><p>修改所有者和所在组：chown   newowner:newgroup   文件/目录</p><p>-R    如果是目录，则使其下所有子文件或目录递归生效</p><br><h3 id="chgrp-修改文件所在组">chgrp – 修改文件所在组</h3><p>修改文件/目录 的所在组：chgrp   [组名]   [文件名]</p><p>eg. 使用 root 用户创建文件 orange.txt，然后将这个文件的所在组修改到 fruit 组</p><ul><li>groupadd   fruit</li><li>touch   orange.txt</li><li>chgrp   fruit   orange.txt</li></ul><br><p>PS：</p><p>当我们要对文件夹内的文件进行操作，则必须先拥有对该文件夹的相应操作</p><br><h1 id="7-定时任务调度">7 定时任务调度</h1><p>任务调度：是指系统在某个时间执行的特定的命令或程序</p><p>任务调度分类：</p><p>系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</p><p>个别用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份</p><br><h2 id="71-crontab-进行定时任务的设置">7.1 crontab – 进行定时任务的设置</h2><p>基本语法：crontab   [选项]</p><table><thead><tr><th>常见选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>编辑 crontab 定时任务</td></tr><tr><td>-l</td><td>查询 crontab 任务</td></tr><tr><td>-r</td><td>删除当前用户所有的 crontab 任务</td></tr></tbody></table><br><p>快速入门</p><p>执行 crontab   -e 命令</p><p>接着输入任务到调度文件</p><p>如：* / * * * *   ls   -l   /etc/   &gt;   /tmp/to.txt</p><p>即：每小时的每分钟执行一次 ls  -l  /etc/  &gt;  /tmp/to.txt 命令</p><p><strong>五个占位符的说明</strong></p><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个 ‘*’</td><td>一小时中的第几分钟</td><td>0 - 59</td></tr><tr><td>第二个 ‘*’</td><td>一天中的第几小时</td><td>0 - 23</td></tr><tr><td>第三个 ‘*’</td><td>一个月中的第几天</td><td>1 - 31</td></tr><tr><td>第四个 ‘*’</td><td>一年中的第几个月</td><td>1 - 12</td></tr><tr><td>第五个 ‘*’</td><td>一周当中的星期几</td><td>0 - 7</td></tr></tbody></table><br><p><strong>特殊符号的说明</strong></p><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任何时间。比如第一个 ‘*’ 就代表一小时中每分钟都执行次的意思</td></tr><tr><td>，</td><td>代表不连续的时间</td></tr><tr><td>-</td><td>代表连续的时间范围</td></tr><tr><td>*/n</td><td>代表每隔多久执行一次</td></tr></tbody></table><p>比如：</p><p>&quot;0  8,12,16  *  *  *”    代表在每天的8点0分, 12点0分, 16点0分都执行命令</p><p>“0  5  *  *  1-6”           代表在周一到周六的5点0分执行命令</p><p>“*/10  *  *  *  *”         代表每隔10分钟就执行遍命令</p><br><p>案例1：每隔 1 分钟，就将当前的日期信息，追加到 /tmp/mydate 文件中</p><p>（1）crontab   -e</p><p>（2）*/1   *   *   *   *   date   &gt;&gt;   /tmp/mydate</p><p>案例2：每隔 1 分钟，将当前日期和日历都追加到 /home/mycal 文件中</p><p>（1）vim   /home/my.sh    写入内容：date   &gt;&gt;   /home/mycal   和   cal   &gt;&gt; /home/mycal</p><p>（2）给 <a href="http://my.sh">my.sh</a> 增加执行权限：chmod   u+x   /home/my.sh</p><p>（3）crontab   -e   增加   */1   *   *   *   *   /home/my.sh</p><br><p><strong>crond 相关指令</strong></p><p>crontab   -r        终止任务调度</p><p>crontab   -l        列出当前有哪些任务调度</p><p>service   crond   restart        重启任务调度</p><br><h2 id="72-at-定时任务">7.2 at –  定时任务</h2><p>at 命令是一次性定时计划任务，at 的守护进程 atd 会以后台模式运行，检查作业队列来运行。</p><p>默认情况下，atd 守护进程每 60 秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，运行此作业</p><p>at 命令是一次性定时计划任务，执行完一个任务后不再执行此任务了</p><p>在使用 at 命令的时候，一定要保证 atd 进程的启动，可以使用相关指令来查看</p><p>ps   -ef   |   grep   atd            可以检测 atd 是否在运行</p><br><p>基本语法：at   [选项]   [时间]</p><p>Ctrl + D        结束 at 命令的输入（输入两次）</p><p>atq               查看系统中没有执行的工作任务</p><p>atrm            删除已经设置的任务</p><p>artm  4       表示删除编号为 4 的任务</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-m</td><td>当指定的任务被完成后，将给用户发送邮件，即使没有标准输出</td></tr><tr><td>-I</td><td>atq 的别名</td></tr><tr><td>-d</td><td>atrm 的别名</td></tr><tr><td>-v</td><td>显示任务将被执行的时间</td></tr><tr><td>-c</td><td>打印任务的内容到标准输出</td></tr><tr><td>-V</td><td>显示版本信息</td></tr><tr><td>-q &lt;队列&gt;</td><td>使用指定的队列</td></tr><tr><td>-f &lt;文件&gt;</td><td>从指定文件读入任务而不是从标准输入读入</td></tr><tr><td>-t &lt;时间参数&gt;</td><td>以时间参数的形式提交要运行的任务</td></tr></tbody></table><p><strong>关于指定时间的说明</strong></p><p>接受在当天的 hh:mm 式的时间指定。假如该时间已过去，那么就放在第二天执行</p><p>使用 midnight (深夜)，noon (中午)，teatime (饮茶时间，一般是下午4点) 等比较模糊的词语来指定时间</p><p>采用12小时计时制，即在时间后面加上AM (上午) 或 PM (下午) 来说明是上午还是下午</p><p>指定命令执行的具体日期，指定格式为 month day 或 mm/dd/yy 或 dd.mm.yy，指定的日期必须跟在指定时间的后面。例如: 04:00 2021-03-1</p><p>使用相对计时法。指定格式为：now + count time-units，now 就是当前时间，time-units 是时间单位，这里能够是 minutes、hours、days、weeks。count 是时间的数量，几天，几小时。例如: now + 5 minutes</p><p>直接使用 today、tomorrow来指定完成命令的时间</p><br><p>eg. 2 天后的下午 5 点执行 /bin/ls   /home</p><p>at   5pm   +   2   days     [回车]</p><p>/bin/ls   /home               [两次 Ctrl + D]</p><br><h1 id="8-磁盘分区-挂载">8 磁盘分区、挂载</h1><h2 id="81-linux-分区">8.1 Linux 分区</h2><p>Linux 来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux 中每个分区都是用来组成整个文件系统的一部分</p><p>Linux 采用了一种叫 “载入” 的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得</p><br><p><strong>硬盘说明</strong></p><p>Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘</p><br><p>对于 IDE 硬盘，驱动器标识符为 “hdx~”，其中 “hd” 表明分区所在设备的类型，这里是指 IDE 硬盘了。</p><p>“x” 为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）</p><p>“~” 代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。</p><p>例，hda3 表示为第一个 IDE 硬盘上的第三个主分区 或 扩展分区</p><p>hdb2 表示为第二个 IDE 硬盘上的第二个主分区 或 扩展分区</p><br><p>对于 SCSI 硬盘则标识为 “sdx~”，SCSI 硬盘是用 “sd” 来表示分区所在设备的类型的，其余则和IDE 硬盘的表示方法一样</p><br><h3 id="查看所有设备的挂载情况">查看所有设备的挂载情况</h3><p>指令：lsblk     或者     lsblk   -f</p><br><h2 id="82-挂载的案例">8.2 挂载的案例</h2><p><strong>如何增加一块硬盘？</strong></p><p>1）虚拟机添加硬盘</p><p>2）分区</p><p>3）格式化</p><p>4）挂载</p><p>5）设置可以自动挂载</p><h3 id="增加一块硬盘">增加一块硬盘</h3><p>1）</p><p>在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统</p><p>2）</p><p>分区命令：fdisk    /dev/sdb         开始对 /sdb 分区</p><p>m       显示命令列表</p><p>P        显示磁盘分区    同    fdisk   -l</p><p>n        新增分区</p><p>d        删除分区</p><p>w       写入并退出</p><p>q        不保存直接退出</p><p>PS：开始分区后输入 n，新增分区，然后选择p，分区类型为主分区。两次回车默认剩余全部空间。最后输入 w 写入分区并退出，若不保存退出输入 q</p><p>3）</p><p>格式化磁盘</p><p>分区命令：mkfs   -t   ext4   /dev/sdb1</p><p>其中 ext4 是分区类型</p><p>4）</p><p>挂载：将一个分区与一个目录联系起来</p><p>mount   [设备名称]   [挂载目录]</p><p>eg. mount    /dev/sdb1    /newdisk</p><p>卸载：将一个分区与一个目录断连</p><p>umount   [设备名称]  或者  [挂载目录]</p><p>eg. umount    /dev/sdb1  或者  umount    /newdisk</p><p>PS：用命令行挂载，重启后会失效</p><p>5）</p><p>永久挂载：通过修改 /etc/fstab 实现挂载</p><p>添加完成后执行 mount  -a 即刻生效</p><h2 id="83-磁盘情况查询">8.3 磁盘情况查询</h2><h3 id="查询系统整体磁盘的使用情况">查询系统整体磁盘的使用情况</h3><p>基本语法：df   -h</p><br><h3 id="查询指定目录的磁盘占用情况">查询指定目录的磁盘占用情况</h3><p>基本语法：du -h</p><p>查询指定目录的磁盘占用情况，默认为当前目录</p><p>-s    指定目录占用大小汇总.</p><p>-h    带计量单位</p><p>-a    含文件</p><p>–max-depth=1    子目录深度</p><p>-c    列出明细的同时，增加汇总值</p><p>eg. 查询 /opt 目录的磁盘占用情况，深度为1</p><p>du   -hac   --max-depth=1   /opt</p><br><h2 id="84-工作实用指令">8.4 工作实用指令</h2><p>统计 /opt 文件夹下文件的个数         ls   -l   /opt   |   grep   “^-”   |   wc   -l</p><p>统计 /opt 文件夹下目录的个数         ls   -l   /opt   |   grep   “^d”   |   wc   -l</p><p>统计 /opt 文件夹下文件的个数，包括子文件夹里的               ls   -lR   /opt   |   grep   “^-”   |   wc   -l</p><p>统计 /opt 文件夹下目录的个数，包括子文件夹里的               ls   -lR   /opt   |   grep   “^d”   |   wc   -l</p><p>以树状显示目录结构 tree 目录     tree   [目录名]</p><p>PS：如果没有tree，则使用 yum install tree 安装</p><br><h1 id="9-网络配置">9 网络配置</h1><h2 id="91-nat-网络原理">9.1 NAT 网络原理</h2><p>查看 windows 环境的中 VMnet8 网络配置：ipconfig</p><p>查看 linux 环境中的网络配置：ifconfig</p><br><h3 id="ping-测试主机之间网络连通性">ping – 测试主机之间网络连通性</h3><p>基本语法：ping   [目的主机]</p><p>eg. 测试当前服务器是否可以连接百度           ping   <a href="http://www.baidu.com">www.baidu.com</a></p><br><h2 id="92-linux-网络环境配置">9.2 linux 网络环境配置</h2><p><strong>第一种方法（自动获取）</strong></p><p>登陆后，通过界面的来设置自动获取 ip</p><p>特点： linux 启动后会自动获取 IP，优点是方便，缺点是每次自动获取的 ip 地址可能不一样</p><p><strong>第二种方法（指定 ip）</strong><br>直接修改配置文件来指定 IP，并可以连接到外网</p><p>vim   /etc/sysconfig/network-scripts/ifcfg-ens33</p><p><strong>ifcfg-ens33   文件说明：</strong></p><p>DEVICE=eth0                                            #接口名（设备，网卡）</p><p>HWADDR=00:0C:2x:6x:0x:xx                 #MAC 地址</p><p>TYPE=Ethernet                                        #网络类型（通常是 Ethemet）</p><p>UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44                  #随机 id</p><p>#系统启动的时候网络接口是否有效（yes / no）</p><p>ONBOOT=yes</p><p>IP 的配置方法[nonelstatic|bootp|dhcp] （引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议）</p><br><p>要求：将 ip 地址配置的静态的，比如：ip 地址为 192.168.200.130</p><p>（1）BOOTPROTO=static（网络连接方式为指定 ip 地址）</p><p>（2）指定 ip 地址、网关、域名解释器</p><p>​        #IP地址</p><p>​        IPADDR=192.168.200.130</p><p>​        #网关</p><p>​        GATEWAY=192.168.200.2</p><p>​        #域名解析器</p><p>​        DNS1=192.1 68.200.2</p><p>（3）在虚拟器设置中修改 VMnet8 的子网 ip</p><p>（4）重启网络服务或者重启系统生效           service   network   restart  或者 reboot</p><br><h2 id="93-设置主机名和-hosts-映射">9.3 设置主机名和 hosts 映射</h2><p>为了方便记忆，可以给 linux 系统设置主机名，也可以根据需要修改主机名</p><p>基本语法：hostname   查看主机名</p><p>修改文件在 /etc/hostname 指定。修改后，重启生效</p><br><p><strong>设置 hosts 映射</strong></p><p>思考：如何通过主机名能够找到（比如ping）某个linux系统？</p><p>windows 环境下：</p><p>在 C:\Windows\System32\drivers\etc\hosts 文件指定即可</p><p>案例：192.168.200.128   firtree01</p><p>linux 环境下：</p><p>在 /etc/hosts 文件指定</p><p>案例：192.168.200.1   LAPTOP-HTKFCLVA</p><br>**Hosts** <p>一个文本文件，用来记录 IP 和 Hostname（主机名）的映射关系</p><p><strong>DNS</strong></p><p>就是 Domain Name System 的缩写，即域名系统。是互联网上作为域名和 IP 地址相互映射的一个分布式数据库</p><br><p>应用实例：用户在浏览器输入了 www. <a href="http://baidu.com">baidu.com</a></p><p>1）浏览器先检查浏览器缓存中有没有该域名解析 IP 地址，有就先调用这个 IP 完成解析。如果没有，就检查 DNS 解析器缓存，如果有直接返回 IP 完成解析。这两个缓存，可以理解为本地解析器缓存</p><p>2）一般来说，当电脑第一次成功访问某一个网站后，在一定时间内，浏览器或操作系统会缓存他的 IP 地址（DNS解析记录）如在 cmd 窗口中输入</p><p>​    ipconfig   /displaydns      // DNS 域名解析缓存<br>​    ipconfig   /flushdns         // 手动清理 DNS 缓存</p><p>3）如果本地解析器缓存没有找到对应映射，检查系统中 hosts 文件中有没有配置对应的域名 IP 映射，如果有，则完成解析并返回</p><p>4）如果本地 DNS 解析器缓存和 hosts 文件中均没有找到对应的 IP，则到域名服务 DNS 进行解析</p><br><h1 id="10-进程管理">10 进程管理</h1><p><strong>基本介绍</strong></p><p>在LINUX中，每个执行的程序都称为一个进程。每一个进程都分配一个ID号（pid，进程号）</p><p>每个进程都可能以两种方式存在。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但屏幕上无法看到</p><p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</p><br><h3 id="ps-显示系统执行的进程">ps – 显示系统执行的进程</h3><p>基本语法：ps</p><p>ps 命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数</p><p><strong>ps显示的信息选项：</strong></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>PID</td><td>进程识别号</td></tr><tr><td>TTY</td><td>终端机号</td></tr><tr><td>TIME</td><td>此进程消耗CPU时间</td></tr><tr><td>CMD</td><td>正在执行的命令或者进程名</td></tr></tbody></table><p><strong>ps 可选参数：</strong></p><p>ps   -a     显示当前终端的所有进程信息</p><p>ps   -u     以用户的格式显示进程信息</p><p>ps   -x     显示后台进程运行的参数</p><p>ps   -e     显示当前的所有进程</p><p>ps   -f      全格式</p><p><strong>ps 详解</strong></p><p>指令：ps   -aux|grep   xxx</p><p>说明：</p><p>USER：用户名称</p><p>PID：进程号</p><p>%CPU：进程占用 CPU 的百分比</p><p>%MEM：进程占用物理内存的百分比</p><p>VSZ：进程占用的虚拟内存大小（单位: KB）</p><p>RSS：进程占用的物理内存大小（单位: KB）</p><p>TT：终端名称，缩写</p><p>STAT：进程状态，其中 S - 睡眠，s - 表示该进程是会话的先导进程，N - 表示进程拥有比普通优先级更低的优先级，R - 正在运行，D - 短期等待，Z - 僵死进程，T - 被跟踪或者被停止等</p><p>STARTED：进程的启动时间</p><p>TIME：CPU 时间，即进程使用CPU的总时间</p><p>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</p><br><p><strong>ps   -ef  则表示以全格式显示当前的所有进程</strong></p><p>UID：用户ID</p><p>PID：进程ID</p><p>PPID：父进程ID</p><p>C：CPU用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高</p><p>STIME：进程启动的时间</p><p>TTY：完整的终端名称</p><p>TIME： CPU 时间</p><p>CMD：启动进程所用的命令和参数</p><br><h3 id="终止进程">终止进程</h3><p>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务</p><p><strong>基本语法：</strong></p><p>kill   [选项]   [进程号]      通过进程号杀死/终止进程</p><p>killall   [进程名称]           通过进程名杀死/终止进程，此时该进程的子进程也会被终止，也支持通配符，系统负载很大时较为有用</p><p><strong>常用选项：</strong></p><p>-9    表示强迫进程立即停止</p><p>eg. 踢掉某个非法用户</p><ul><li>ps  -aux  |  grep  sshd            得到用户登录的进程号</li><li>kill   [得到的进程号]                 终止进程</li></ul><br><h3 id="pstree-查看进程树">pstree – 查看进程树</h3><p>基本语法：pstree   [选项]         可以更加直观的查看进程信息</p><p>常用选项：</p><p>-p    显示进程的 PID</p><p>-u    显示进程的所属用户</p><br><h1 id="11-服务管理">11 服务管理</h1><p>服务本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求</p><p>比如（mysqld，sshd，防火墙等）因此我们又称为守护进程，是Linux中非常重要的知识点</p><br><h2 id="111-service-服务管理指令">11.1 service 服务管理指令</h2><p>（1）service   服务名   [start | stop | restart | reload I status]</p><p>（2）在 CentOS7.0 后很多服务不再使用 service，而是 systemctl</p><p>（3）service 指令管理的服务在 /etc/init.d 查看</p><br><h3 id="查看服务名">查看服务名</h3><p>方式一：使用 setup 查看系统服务</p><p>方式二：在 /etc/init.d 下可以看到 service 指令管理的服务</p><br><h2 id="112-服务的运行级别">11.2 服务的运行级别</h2><p>Linux 有 7 种运行级别，常用的级别是 3 和 5</p><p>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</p><p>运行级别1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆</p><p>运行级别2：多用户状态（没有NFS）不支持网络</p><p>运行级别3：完全的多用户状态（有NFS）无界面，登陆后进入控制台命令行模式</p><p>运行级别4：系统未使用，保留</p><p>运行级别5： X11 控制台，登陆后进入图形 GUI 模式</p><p>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</p><br><h3 id="默认的运行级别">默认的运行级别</h3><p>在 centos7 以前，存储在 /etc/inittab 文件中</p><p>之后做了简化：</p><p>multi-user.target:ansalogous   to   runlevel   3</p><p>grapjical.target:ansalogous   to   runlevel   5</p> <br><ul><li><p>查看当前的运行级别         systemctl   get-default</p></li><li><p>设置默认的运行级别         systemctl   set-default   TARGET.target</p></li></ul><br><h3 id="chkconfig-指令">chkconfig 指令</h3><p>通过 chkconfig 命令可以给服务的各个运行级别设置自启动/关闭</p><p>chkconfig 指令管理的服务在 /etc/init.d 查看</p><p>注意：Centos7.0 后，很多服务使用 systemctl 管理</p><br><p>chkconfig 基本语法：</p><p>（1）查看服务    chkconfig    --list  [|  grep  xxx]</p><p>（2）chkconfig    服务名    --list</p><p>（3）chkconfig    --level    5    服务名    on/off</p><p>PS：chkconfig 重新设置服务后自启动或关闭，需要重启机器reboot生效</p><br><h3 id="systemctl-指令">systemctl 指令</h3><p>基本语法：systemctl    [start I stop | restart I status]    服务名<br>systemctl 指令管理的服务在 /usr/lib/systemd/system 查看</p><br><p><strong>systemctl 设置服务的自启动状态</strong></p><p>systemctl   list-unit-files   [| grep   服务名]       查看服务开机启动状态，grep进行过滤</p><p>systemctl   enable   服务名                                  设置服务开机启动</p><p>systemctl   disable   服务名                                  关闭服务开机启动</p><p>systemctl   is-enabled   服务名                            查询某个服务是否是自启动的</p><p>eg. 查看防火墙服务的开机启动状态     systemctl   list-unit-files  |  grep   firewalld</p> <br><p>关闭或者启用防火墙后，立即生效</p><p>但这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置</p><p>如果希望设置某个服务自启动或关闭永久生效，要使用systemctl   [enable/disable]   服务名</p><br><h2 id="113-打开关闭端口">11.3 打开/关闭端口</h2><p>在真正的生产环境，往往需要将防火墙打开，但如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。比如80、22、8080 等。</p><h3 id="firewall-指令">firewall 指令</h3><p>（1）打开端口：firewall-cmd   --permanent   --add-port=端口号/协议</p><p>（2）关闭端口：firewall-cmd   --permanent   --remove-port=端口号/协议</p><p>（3）重新载入，才能生效：firewall-cmd   --reload</p><p>（4）查询端口是否开放：firewall-cmd   --query-port=端口号/协议</p><p>PS：可以通过 netstat   -anp  |  more 查看端口号/协议</p><br><h2 id="114-动态监控进程">11.4 动态监控进程</h2><p>top 与 ps 命令很相似。它们都用来显示正在执行的进程。</p><p>top 与 ps 最大的不同之处，在于 top 在执行段时间可以更新正在运行的的进程</p><p>基本语法：top   [选项]</p><p>常用选项：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d  秒数</td><td>指定 top 命令每几秒更新，默认是 3 秒</td></tr><tr><td>-i</td><td>使 top 不显示任何闲置或者僵死进程</td></tr><tr><td>-p</td><td>通过指定监控进程ID来仅仅监控某个进程的状态</td></tr></tbody></table><br><p>交互操作说明：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以CPU使用率排序，默认就是此选项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出top</td></tr></tbody></table><br><p>（1）监视特定用户，比如 tom 用户</p><ul><li>top   进入查看进程页面</li><li>u    再输入要查看的用户</li></ul><p>（2）终止指定的进程</p><ul><li>top   进入查看进程页面</li><li>k     再输入要结束的进程 ID 号</li></ul><br><h2 id="115-监控网络信息">11.5 监控网络信息</h2><h3 id="netastat-查看系统网络状态">netastat – 查看系统网络状态</h3><p>基本语法：netstat   [选项]</p><p>常用选项：</p><p>-an   按一定顺序排列输出</p><p>-p      显示哪一个进程在调用</p><p>eg. 请查看服务名为 sshd 的服务的信息              netstat   -anp  |  grep   sshd</p><br><h1 id="12-rpm-和-yum">12 RPM 和 YUM</h1><h2 id="121-rpm-包">12.1 rpm 包</h2><p>rpm 用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有.RPM扩展名的文件</p><p>RPM是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似 windows 的setup.exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的</p><p>Linux 的分发版本都有采用（suse，redhat，centos等）可以算是公认的行业标准了</p><br><h3 id="rpm-包的简单查询指令">rpm 包的简单查询指令</h3><p>基本语法：rpm   -qa  l  grep   XX                 查询已安装的 rpm 列表</p><p>eg. 查看当前系统是否安装了firefox             rpm   -qa  |  grep   firefox</p><br><h3 id="rpm-包名基本格式">rpm 包名基本格式</h3><p>一个 rpm 包名：firefox-68.10.0-1.el7.centos.x86_64</p><p>名称：firefox</p><p>版本号：68.10.0-1</p><p>适用操作系统：el7.centos.x86_64</p><p>表示 centos7.x 的 64 位系统</p><p>i686、i386 表示 32 位系统，noarch 表示通用</p><br><h3 id="rpm-包的其他查询指令">rpm 包的其他查询指令</h3><p>rpm   -qa：查询所安装的所有 rpm 软件包</p><p>rpm   -qa  |  more<br>rpm   -qa  |  grep   XXX</p><br><p>rpm   -q    软件包名：查询软件包是否安装</p><p>rpm   -qi   软件包名：查询软件包信息</p><p>rpm   -ql   软件包名：查询软件包中的文件</p><p>rpm   -qf   文件全路径名：查询文件所属的软件包</p><br><h3 id="卸载-rpm-包">卸载 rpm 包</h3><p>基本语法：rpm   -e   RPM   [包的名称]</p><p>eg. 删除 firefox 软件包           rpm   -e   firefox</p><p><strong>PS：</strong></p><p>（1）如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息</p><p>（2）如果我们就是要删除 foo 这个 rpm 包，可以增加参数  --nodeps，就可以强制删除，但是一般不推荐这样做， 因为依赖于该软件包的程序可能无法运行</p><br><h3 id="安装-rpm-包">安装 rpm 包</h3><p>基本语法：rpm   -ivh   [RPM包路径名称]</p><p>说明：</p><p>i = intall         安装</p><p>v = verbose   提示</p><p>h = hash        进度条</p><br><h2 id="122-yum-包">12.2 yum 包</h2><p>Yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动<br>下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包</p><br><h3 id="yum-基本指令">yum 基本指令</h3><p>yum   list  |  grep   xx   [软件列表]          查询 yum 服务器是否有需要安装的软件</p><p>yum   install   XXX                 下载安装指定的 yum 包</p><p>eg. 下载并安装 firefox</p><p>rpm   -e   firefox</p><p>yum   list  |  grep   firefox</p><p>yum   install   firefox</p><br><h1 id="12-shell">12 Shell</h1><h2 id="121-shell-脚本">12.1 shell 脚本</h2><p>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以 用 Shell 来启动、挂起、停止甚至是编写一些程序</p><br><p><strong>脚本格式要求</strong></p><p>（1）脚本以 #!/bin/bash 开头</p><p>（2）脚本需要有可执行权限</p><br><p><strong>编写第一个 Shell 脚本</strong></p><p>需求说明：创建一个 Shell 脚本，输出 hello world!</p><p>vim   <a href="http://hello.sh">hello.sh</a></p><p>#!/bin/bash</p><p>echo   “hello,world~”</p><br><p><strong>脚本的常用执行方式</strong></p><p>方式一：(输入脚本的绝对路径或相对路径)</p><p>说明：首先要赋予 <a href="http://helloworld.sh">helloworld.sh</a> 脚本的 +x 权限， 再执行脚本</p><p>比如 ./hello.sh 或者使用绝对路径 /root/shcode/hello.sh</p><p>方式二：(sh + 脚本)</p><p>说明：不用赋予脚本+x 权限，直接执行即可</p><p>比如 sh   <a href="http://hello.sh">hello.sh</a>，也可以使用绝对路径</p><br><h2 id="122-shell-变量">12.2 shell 变量</h2><p><strong>Shell 变量介绍</strong></p><p>（1）Linux Shell 中的变量分为，系统变量和用户自定义变量</p><p>（2）系统变量：$HOME、$PWD、$SHELL、$USER 等等，比如：echo   $HOME 等</p><p>（3）显示当前 shell 中所有变量：set</p><br><p><strong>shell 变量的定义</strong></p><p>基本语法</p><p>（1）定义变量：变量名=值</p><p>（2）撤销变量：unset   变量</p><p>（3）声明静态变量：readonly   变量（此时不能 unset）</p><p><strong>PS：shell 里不要打空格</strong></p><br><p><strong>shell 定义变量的规则</strong></p><p>（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头</p><p>（2）等号两侧不能有空格</p><p>（3）变量名称一般习惯为大写， 这是一个规范，我们遵守即可</p><br><p><strong>将命令的返回值赋给变量</strong></p><p>（1） A=`date`反引号，运行里面的命令，并把结果返回给变量 A</p><p>（2）A=$(date)    等价于反引</p><br><h2 id="123-设置环境变量">12.3 设置环境变量</h2><p><strong>基本步骤：</strong></p><p>（1）export   变量名=变量值 （功能描述：将 shell 变量输出为环境变量/全局变量）</p><p>（2）source   配置文件           （功能描述：让修改后的配置信息立即生效）</p><p>（3）echo   $变量名                （功能描述：查询环境变量的值）</p><br><p>eg.</p><p>（1）在 /etc/profile 文件中定义 TOMCAT_HOME 环境变量</p><ul><li><p>vim   /etc/profile</p></li><li><p>在文件最后加上 export   TOMCAT_HOME=/etc/tomcat</p></li><li><p>source   /etc/profile               刷新</p></li><li><p>echo   $TOMCAT_HOME       测试</p></li></ul><br><p><strong>shell 语法里的注释</strong></p><p>#                    （单行注释）</p><p>:&lt;&lt;!  内容  !   （多行注释）</p><br><h2 id="124-位置参数变量">12.4 位置参数变量</h2><p>当我们执行一个 shell 脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量</p><p><strong>基本语法：</strong></p><p>$n （n 为数字）</p><p>$0 代表命令本身，$1 - $9 代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}）</p><p>$* （这个变量代表命令行中所有的参数，$* 把所有的参数看成一个整体）</p><p>$@（这个变量也代表命令行中所有的参数，但是 $@ 把每个参数区分对待）</p><p>$#（这个变量代表命令行中所有参数的个数）</p><br><h2 id="125-预定义变量">12.5 预定义变量</h2><p>就是 shell 设计者事先已经定义好的变量，可以直接在 shell 脚本中使用</p><br><p>$$ （当前进程的进程号（PID））</p><p>$! （后台运行的最后一个进程的进程号（PID））</p><p>$?（最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；否则，证明上一个命令执行不正确）</p><br><h2 id="126-运算符">12.6 运算符</h2><p>（1） “$((运算式))”  或  “$[运算式]”  或  expr  m + n</p><p>（2）注意 expr 运算符间要有空格，如果希望将 expr 的结果赋给某个变量，使用 ``</p><p>（3）expr  m - n</p><p>（4）expr    \*， /，% 乘，除，取余</p><br><p><em><em>一、计算（2+4）</em> 3</em>*</p><p>方式一：RES1=$(((2+4)*3))</p><p>方式二：RES2=$[(2+4)*3]</p><p>方式三：</p><p>TMP=`expr   2  +  4`</p><p>RES3=`expr   $TMP    \*  3`</p><p><strong>二、计算命令行的两个参数之和</strong></p><p>SUM=$(($1+$2))</p><p>echo “SUM=”$SUM</p><br><h1 id="13-shell流程控制">13 shell流程控制</h1><h2 id="131-条件判断">13.1 条件判断</h2><p>基本语法</p><p>[ condition ]（注意 condition 前后要有空格）</p><p>非空返回 true，可使用 $? 验证（0 为 true，非0 为 false）</p><p>[ condition ]   &amp;&amp;   echo   OK   ||   echo   notok          条件满足就执行后面的语句</p><br><p><strong>常用的判断条件：</strong></p><p>（1） = 字符串比较</p><p>（2）两个整数的比较</p><p>-lt     小于</p><p>-le    小于等于     little equal</p><p>-eq   等于</p><p>-gt    大于</p><p>-ge   大于等于</p><p>-ne   不等于</p><p>（3）按照文件权限进行判断</p><p>-r   有读的权限</p><p>-w   有写的权限</p><p>-x   有执行的权限</p><p>（4）按照文件类型进行判断</p><p>-f    文件存在并且是一个常规的文件</p><p>-e   文件存在</p><p>-d   文件存在并是一个目录</p><br><h2 id="132-if-语句">13.2 if 语句</h2><p><strong>基本语法：</strong></p><p>if   [ 条件判断式 ]</p><p>then 代码</p><p>fi</p><p><strong>多分支语法：</strong></p><p>if   [ 条件判断式 ]</p><p>then</p><p>代码</p><p>elif   [条件判断式]</p><p>then</p><p>代码</p><p>fi</p><br><h2 id="133-case-语句">13.3 case 语句</h2><p><strong>基本语法：</strong></p><p>case   $变量名   in</p><p>“值 1”)</p><p>如果变量的值等于值 1，则执行程序 1</p><p>;;</p><p>“值 2”)</p><p>如果变量的值等于值 2，则执行程序 2</p><p>;;</p><p>…省略其他分支…</p><p>*)</p><p>如果变量的值都不是以上的值，则执行此程序</p><p>;;</p><p>esac</p><br><h2 id="134-for-循环">13.4 for 循环</h2><p><strong>基本语法1：</strong></p><p>for   变量   in   值1   值2   值3…</p><p>do</p><p>程序/代码</p><p>done</p><p>eg.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;now = &quot;</span><span class="hljs-variable">$i</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><br><p><strong>基本语法2：</strong></p><p>for   (( 初始值；循环控制条件；变量变化 ))</p><p>do</p><p>程序/代码</p><p>done</p><p><strong>eg. 求 1 - 100 的和</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>SUM=0<br><span class="hljs-keyword">for</span> (( i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">100</span>; i++ ))<br><span class="hljs-keyword">do</span><br>        SUM=$[<span class="hljs-variable">$SUM</span>+<span class="hljs-variable">$i</span>]<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;SUM = &quot;</span><span class="hljs-variable">$SUM</span>                 <br></code></pre></td></tr></table></figure><br><h2 id="135-while-循环">13.5 while 循环</h2><p><strong>基本语法：</strong></p><p>while   [ 条件判断式 ]</p><p>do</p><p>程序/代码</p><p>done</p><p><strong>eg. 求 1 - 输入值 的和</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>SUM=0<br>i=0<br><br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$i</span> -le <span class="hljs-variable">$1</span> ]<br><span class="hljs-keyword">do</span><br>        SUM=$[<span class="hljs-variable">$SUM</span>+<span class="hljs-variable">$i</span>]<br>        i=$[<span class="hljs-variable">$i</span>+1]<br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;SUM = &quot;</span><span class="hljs-variable">$SUM</span><br><br></code></pre></td></tr></table></figure><br><h2 id="136-read-读取控制台输入">13.6 read 读取控制台输入</h2><p>read（选项）（参数）</p><p>选项：</p><p>-p       指定读取值时的提示符</p><p>-t        指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了</p><p>参数</p><p>变量：指定读取值的变量名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#案例 1：读取控制台输入一个 NUM1 值</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入一个数 NUM1=&quot;</span> NUM1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的 NUM1=<span class="hljs-variable">$NUM1</span>&quot;</span> <br><br><span class="hljs-comment">#案例 2：读取控制台输入一个 NUM2 值，在 10 秒内输入</span><br><span class="hljs-built_in">read</span> -t 10 -p <span class="hljs-string">&quot;请输入一个数 NUM2=&quot;</span> NUM2<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;你输入的 NUM2=<span class="hljs-variable">$NUM2</span>&quot;</span><br></code></pre></td></tr></table></figure><br><h1 id="14-shell-函数">14 shell 函数</h1><p>shell 编程和其它编程语言一样，有系统函数，也可以自定义函数</p><h2 id="141-系统函数">14.1 系统函数</h2><p>basename   – 返回完整路径最后 / 的后面部分，常用于获取文件名</p><p>基本语法：</p><p>basename   [pathname]   [suffix]</p><p>basename   [string]   [suffix]</p><p>功能描述：basename 命令会删掉所有的前缀包括最后一个 “ / ” 字符，然后将字符串显示出来</p><p>选项：</p><p>suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉</p><br><p>dirname   – 返回完整路径最后 / 的前面的部分，常用于返回路径</p><p>基本语法：</p><p>dirname   文件绝对路径</p><p>功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下部分</p><br><h2 id="142-自定义函数">14.2 自定义函数</h2><p>基本语法：</p><p>[ function ]   funname[()]</p><p>{</p><p>​        Action;</p><p>​        [return int;]</p><p>}</p><p>调用函数        funname [值]</p><p>eg. 计算输入的两个数之和   getSum</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment">#定义函数 getSum</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">getSum</span></span>() &#123;<br>    SUM=$[<span class="hljs-variable">$n1</span>+<span class="hljs-variable">$n2</span>]<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;和是=<span class="hljs-variable">$SUM</span>&quot;</span> <br>&#125;<br><br><span class="hljs-comment">#输入两个值</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入一个数 n1=&quot;</span> n1<br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;请输入一个数 n2=&quot;</span> n2<br><br><span class="hljs-comment">#调用自定义函数</span><br>getSum <span class="hljs-variable">$n1</span> <span class="hljs-variable">$n2</span><br></code></pre></td></tr></table></figure><br><h2 id="143-综合案例">14.3 综合案例</h2><p>（1）每天凌晨 2:30 备份数据库 hspedu 到 /data/backup/db</p><p>（2）备份开始和备份结束能够给出相应的提示信息</p><p>（3）备份后的文件要求以备份时间为文件名，并打包成 .tar.gz 的形式</p><p>（4）在备份的同时，检查是否有 10 天前备份的数据库文件，如果有就将其删除</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#！/bin/bash</span><br><br><span class="hljs-comment">#备份目录</span><br><span class="hljs-attribute">BACKUP</span>=/data/backup/db<br><br><span class="hljs-comment">#当前时间</span><br><span class="hljs-attribute">DATETIME</span>=$(date +%Y-%m-%d_%H%M%S)<br>echo <span class="hljs-variable">$DATETIME</span><br><br><span class="hljs-comment">#数据库的地址</span><br><span class="hljs-attribute">HOST</span>=localhost<br><br><span class="hljs-comment">#数据库用户名</span><br><span class="hljs-attribute">DB_USER</span>=root<br><br><span class="hljs-comment">#数据库密码</span><br><span class="hljs-attribute">DB_PW</span>=hspedu100<br><br><span class="hljs-comment">#备份的数据库名</span><br><span class="hljs-attribute">DATABASE</span>=hspedu<br><br><span class="hljs-comment">#创建备份目录, 如果不存在，就创建</span><br>[ ! -d <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>&quot;</span> ] &amp;&amp; mkdir -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>&quot;</span><br><br><span class="hljs-comment">#备份数据库</span><br>mysqldump -u<span class="hljs-variable">$&#123;DB_USER&#125;</span> -p<span class="hljs-variable">$&#123;DB_PW&#125;</span> <span class="hljs-attribute">--host</span>=<span class="hljs-variable">$&#123;HOST&#125;</span> -q -R --databases <span class="hljs-variable">$&#123;DATABASE&#125;</span> | gzip &gt;<br><span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>/<span class="hljs-variable">$DATETIME</span>.sql.gz<br><br><span class="hljs-comment">#将文件处理成 tar.gz</span><br>cd <span class="hljs-variable">$&#123;BACKUP&#125;</span><br>tar -zcvf <span class="hljs-variable">$DATETIME</span>.tar.gz <span class="hljs-variable">$&#123;DATETIME&#125;</span><br><br><span class="hljs-comment">#删除对应的备份目录</span><br>rm -rf <span class="hljs-variable">$&#123;BACKUP&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span><br><br><span class="hljs-comment">#删除 10 天前的备份文件</span><br><span class="hljs-built_in">find</span> <span class="hljs-variable">$&#123;BACKUP&#125;</span> -atime +10 -name <span class="hljs-string">&quot;*.tar.gz&quot;</span> -exec rm -rf &#123;&#125; \;<br>echo <span class="hljs-string">&quot;备份数据库<span class="hljs-variable">$&#123;DATABASE&#125;</span> 成功~</span><br></code></pre></td></tr></table></figure><br><p># 每天两点半执行脚本</p><p>crontab  -e</p><p>30   2   *   *   *   /usr/sbin/mysql_db_backup.sh</p><br><br><h1 id="15-日志管理">15 日志管理</h1><p><strong>基本介绍：</strong></p><p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统 的安全信息、邮件相关信息、各种服务相关信息等</p><p>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击 时攻击者留下的痕迹</p><p>可以这样理解 日志是用来记录重大事件的工具</p><br><h2 id="151-系统常用的日志">15.1 系统常用的日志</h2><p>/var/log/    目录就是系统日志文件的保存位置</p><table><thead><tr><th>日志文件</th><th>说明</th></tr></thead><tbody><tr><td>/var/log/boot.log</td><td>系统启动日志</td></tr><tr><td>/var/log/cron</td><td>记录与系统定时任务相关的日志</td></tr><tr><td>/var/log/cups/</td><td>记录打印信息的日志</td></tr><tr><td>/var/log/dmesg</td><td>记录了系统在开机时内核自检的信总。也可以使用 dmesg 命令直接查看内核自检信息</td></tr><tr><td>/var/log/btmp</td><td>记录错误登陆的日志。这个文件是二进制文件，不能直接用 Vi 查看，而要使用 lastb 命令查看。[root@localhost  log]#lastb</td></tr><tr><td>/var/log/lastlog</td><td>记录系统中所有用户最后一次的登录时间的日志。这个文件也是二进制文件。要使用 lastlog 命令查看</td></tr><tr><td>/var/log/maillog</td><td>记录邮件信息的日志</td></tr><tr><td>/var/log/message</td><td>记录系统重要消息的日志，这个日志文件中会记录 Linux 系统的绝大多数重要信息。如果系统出现问题，首先要检查的应该就是这个日志文件</td></tr><tr><td>/var/log/secure</td><td>记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录，比如系统的登录、ssh的登录、su切换用户甚至添加用户和修改用户密码都会记录在这个日志文件中</td></tr><tr><td>/var/log/wtmp</td><td>永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。是二进制文件。要使用 last 命令查看</td></tr><tr><td>/var/run/ulmp</td><td>记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。这个文件不能用 Vi 查看，要使用w、who、users等命令查看</td></tr></tbody></table><br><h2 id="152-日志管理服务-rsyslogd">15.2 日志管理服务 rsyslogd</h2><p>CentOS7.6 日志服务是 rsyslogd ， CentOS6.x 日志服务是 syslogd</p><p>rsyslogd 功能更强大。rsyslogd 的使用、日志 文件的格式，和 syslogd 服务是兼容的</p><br><p><strong>查询 Linux 中的 rsyslogd 服务是否启动</strong></p><p>ps   aux   |   grep   “rsyslog”   |   grep   -v   “grep”</p><p><strong>查询 rsyslogd 服务的自启动状态</strong></p><p>systemctl   list-unit-files   |   grep   rsyslog</p><p><strong>配置文件：/etc/rsyslog.conf</strong></p><p>编辑文件时的格式为：* .*        存放日志文件</p><p>其中第一个 * 代表日志类型，第二个 * 代表日志级别</p><br><p><strong>（1）日志类型分为：</strong></p><p>auth               ##pam 产生的日志</p><p>authpriv        ##ssh、ftp 等登录信息的验证信息</p><p>corn               ##时间任务相关</p><p>kern               ##内核</p><p>lpr                  ##打印</p><p>mail               ##邮件</p><p>mark(syslog)-rsyslog          ##服务内部的信息，时间标识</p><p>news             ##新闻组</p><p>user              ##用户程序产生的相关信息</p><p>uucp             ##unix   to   nuix   copy 主机之间相关的通信</p><p>local   1-7     ##自定义的日志设备</p><p><strong>（2）日志级别分为：</strong></p><p>debug           ##有调试信息的，日志通信最多</p><p>info               ##一般信息日志，最常用</p><p>notice           ##最具有重要性的普通条件的信息</p><p>warning       ##警告级别</p><p>err                ##错误级别，阻止某个功能或者模块不能正常工作的信息</p><p>crit                ##严重级别，阻止整个系统或者整个软件不能正常工作的信息</p><p>alert             ##需要立刻修改的信息</p><p>emerg          ##内核崩溃等重要信息</p><p>none             ##什么都不记录</p><p>注意：从上到下，级别从低到高，记录信息越来越少</p><br><p>由日志服务 rsyslogd 记录的日志文件，日志文件的格式包含以下 4 列</p><p>（1）事件产生的时间</p><p>（2）产生事件的服务器的主机名</p><p>（3）产生事件的服务名或程序名</p><p>（4）事件的具体信息（事件的描述）</p><br><p><strong>想要创建一个自定义日志</strong></p><p>（1）在配置文件 /etc/rsyslog.conf 中添加描述</p><p>​           *.*                                  /var/log/shan.log</p><p>（2）新键 /var/log/shan.log 文件</p><p>（3）重启</p><br><h2 id="153-日志轮换">15.3 日志轮换</h2><p>日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除</p><br><p><strong>日志轮替文件命名</strong></p><p>（1）centos7 使用 logrotate 进行日志轮替管理，要想改变日志轮替文件名字，通过 /etc/logrotate.conf 配置文件中 “dateext” 参数</p><p>（2）如果配置文件中有 “dateext” 参数，那么日志会用日期来作为日志文件的后缀，例如 “secure-20201010”。这样日志文件名不会重叠，也就不需要日志文件的改名， 只需要指定保存日志个数，删除多余的日志文件即可</p><p>（3）如果配置文件中没有 “dateext” 参数，日志文件就需要进行改名了。</p><p>当第一次进行日志轮替时，当前的 “secure” 日志会自动改名为 “secure.1”，然后新建 “secure” 日志，用来保存新的日志。</p><p>当第二次进行日志轮替时，“secure.1” 会自动改名为 “secure.2”， 当前的 “secure” 日志会自动改名为 “secure.1”，然后也会新建 “secure” 日志，用来 保存新的日志，以此类推</p><br><h2 id="154-logrotate-配置文件">15.4 logrotate 配置文件</h2><p>/etc/logrotate.conf  配置文件说明：</p><p># rotate log files weekly，每周对日志文件进行一次轮替</p><p>weekly</p><p># keep 4 weeks worth of backlogs，共保存 4 份日志文件，当建立新的日志文件时，旧的将会被删除</p><p>rotate 4</p><p># create new (empty) log files after rotating old ones，创建新的空的日志文件，在日志轮替后</p><p>create</p><p># use date as a suffix of the rotated file，使用日期作为日志轮替文件的后缀</p><p>dateext</p><p># uncomment this if you want your log files compressed, 日志文件是否压缩。如果取消注释，则日志会在转储的同时进行压缩</p><p>#compress</p><p>#RPM packages drop log rotation information into this directory</p><p># 包含 /etc/logrotate.d/ 目录中所有的子配置文件。也就是说会把这个目录中所有子配置文件读取进来</p><p>include /etc/logrotate.d</p><p><strong>#下面是单独设置，优先级更高</strong></p><p># no packages own wtmp and btmp – we’ll rotate them here</p><p>/var/log/wtmp {</p><p>​        monthly # 每月对日志文件进行一次轮替</p><p>​        create 0664 root utmp # 建立的新日志文件，权限是 0664 ，所有者是 root ，所属组是 utmp 组</p><p>​        minsize 1M   # 日志文件最小轮替大小是 1MB 。也就是日志一定要超过 1MB 才会轮替，否则就算时间达到 一个月，也不进行日志转储</p><p>​        rotate 1         # 仅保留一个日志备份。也就是只有 wtmp 和 wtmp.1 日志保留而已</p><p>}</p><p>/var/log/btmp {</p><p>​        missingok    # 如果日志不存在，则忽略该日志的警告信息</p><p>​        monthly</p><p>​        create 0600 root utmp</p><p>​        rotate 1</p><p>}</p><br><p><strong>参数说明</strong></p><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>daily</td><td>日志的轮替周期是每天</td></tr><tr><td>weekly</td><td>日志的轮替周期是每周</td></tr><tr><td>monthly</td><td>日志的轮替周期是每月</td></tr><tr><td>rotate 数字</td><td>保留的日志文件的个数。0 指没有备份</td></tr><tr><td>compress</td><td>日志轮替时，旧的日志进行压缩</td></tr><tr><td>create mode owner group</td><td>建立新日志，同时指定新日志的权限与所有者和所属组</td></tr><tr><td>mail address</td><td>当日志轮替时，输出内容通过邮件发送到指定的邮件地址</td></tr><tr><td>missingok</td><td>如果日志不存在，则忽略该日志的警告信息</td></tr><tr><td>notifempty</td><td>如果日志为空文件，则不进行日志轮替</td></tr><tr><td>minsize 大小</td><td>日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替</td></tr><tr><td>size 大小</td><td>日志只有大于指定大小才进行日志轮替，而不是按照时间轮替</td></tr><tr><td>dateext</td><td>使用日期作为日志轮替文件的后缀</td></tr><tr><td>sharedscripts</td><td>在此关键字之后的脚本只执行一次</td></tr><tr><td>prerotate/endscript</td><td>在日志轮替之前执行脚本命令</td></tr><tr><td>postrotate/endscript</td><td>在日志轮替之后执行脚本命令</td></tr></tbody></table><p><strong>把自己的日志加入日志轮替</strong></p><p>第一种方法是直接在 /etc/logrotate.conf 配置文件中写入该日志的轮替策略</p><p>第二种方法是在 /etc/logrotate.d/ 目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被 “include” 到主配置文件中，所以也可以把日志加入轮替</p><p>推荐使用第二种方法，因为系统中需要轮替的日志非常多，如果全都直接写入/etc/logrotate.conf 配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护</p><br><p>比如要想给 shan 这个日志以第二种方式配置，就在 /etc/logrotate.d/ 目录下创建文件 shan</p><p>/var/log/shan.log</p><p>{</p><p>​        missingok</p><p>​        daily</p><p>​        copytruncate</p><p>​        rotate 7</p><p>​        notifempty</p><p>}</p><p><strong>日志轮替机制原理</strong></p><p>日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在 /etc/cron.daily/ 目录，就会发现这个目录中有 logrotate 文件（可执行），logrotate 通过这个文件依赖定时任务执行的</p><br><h2 id="155-查看日志内存">15.5 查看日志内存</h2><p>journalctl   –  可以查看内存日志</p><p><strong>常用指令：</strong></p><p>journalctl                                                                ##查看全部</p><p>journalctl   -n   3                                                    ##查看最新 3 条</p><p>journalctl   --since   19:00   --until   19:10:10    ##查看起始时间到结束时间的日志</p><p>journalctl   -p   err                                                 ##报错日志</p><p>journalctl   -o   verbose                                        ##日志详细内容</p><p>journalctl_PID=1245    _COMM=sshd                ##查看包含这些参数的日志（在详细日志查看）</p><p>或者 journalctl   |   grep ssh</p><br><p>PS：journalctl 查看的是内存日志，重启清空</p><br><h1 id="16-备份与恢复">16 备份与恢复</h1><p>实体机无法做快照，如果系统出现异常或者数据损坏，后果严重， 要重做系统，还会造成数据丢失。</p><p>所以我们可以使用备份和恢复技术</p><p>linux 的备份和恢复很简单，有两种方式：</p><p>（1）把需要的文件（或者分区）用 TAR 打包就行，下次需要恢复的时候，再解压开覆盖即可</p><p>（2）使用 dump 和 restore 命令</p><br><p><strong>安装 dump 和 restore</strong></p><p>如果 linux 上没有 dump 和 restore 指令，需要先按照</p><p>yum   -y   install   dump</p><p>yum   -y   install   restore</p><br><h2 id="161-使用dump-完成备份">16.1 使用dump 完成备份</h2><p>dump 支持分卷和增量备份（所谓增量备份是指备份上次备份后 修改/增加过的文件，也称差异备份）</p><p><strong>基本语法：</strong></p><p>dump    [ -cu]    [-123456789]    [ -f &lt;备份后文件名&gt;]    [-T &lt;日期&gt;]    [ 目录或文件系统]</p><p>dump    []-wW</p><p>-c ：创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头</p><p>-0123456789 ：备份的层级。0 为最完整备份，会备份所有文件。若指定 0 以上的层级，则备份至上一次备份以来 修改或新增的文件，到 9 后，可以再次轮替</p><p>-f   &lt;备份后文件名&gt; ：指定备份后文件名</p><p>-j ：调用 bzlib 库压缩备份文件，也就是将备份后的文件压缩成 bz2 格式，让文件更小</p><p>-T   &lt;日期&gt; ：指定开始备份的时间与日期</p><p>-u ：备份完毕后，在/etc/dumpdares 中记录备份的文件系统，层级，日期与时间等</p><p>-t ：指定文件名，若该文件已存在备份文件中，则列出名称</p><p>-W ：显示需要备份的文件及其最后一次备份的层级，时间 ，日期</p><p>-w ：与-W 类似，但仅显示需要备份的文件</p><br><p><strong>举例：</strong></p><p>（1）将 /boot 分区所有内容备份到 /opt/boot.bak0.bz2 文件中，备份层级为 “0”</p><p>​        dump    -0uj    -f    /opt/boot.bak0.bz2    /boot</p><p>（2）在 /boot 目录下增加新文件，备份层级为 “1”（只备份上次使用层次 “0” 备份后发生过改变的数据）</p><p>​        dump    -1uj    -f    /opt/boot.bak1.bz2    /boot</p><p>​        PS：通过 dump 命令在配合 crontab 可以实现无人值守备份</p><br><p><strong>查看备份时间文件</strong></p><p>cat   /etc/dumpdates</p><br><p><strong>备份文件或者目录</strong></p><p>我们在备份分区时，是可以支持增量备份的</p><p>但是如果备份文件或者目录，不再支持增量备份，即只能使用 0 级别备份</p><p>前面的 -u 指令也不支持，因为不支持层级备份的话，也没有必要记录层级信息</p><br><p>eg. 使用 dump 备份 /etc 整个目录</p><p>​    dump   -0j   -f   /opt/etc.bak.bz2   /etc/</p><p># 下面这条语句会报错，提示 DUMP: Only level 0 dumps are allowed on a subdirectory</p><p>​    dump   -1j   -f   /opt/etc.bak.bz2   /etc/</p><p>PS：如果是重要的备份文件， 比如数据区，建议将文件上传到其它服务器保存</p><br><h2 id="162-使用-restore-完成恢复">16.2 使用 restore 完成恢复</h2><p>restore 命令用来恢复已备份的文件，可以从 dump 生成的备份文件中恢复原文件</p><p><strong>基本语法：</strong></p><p>restore   [模式选项]   [选项]</p><p>模式有四个， 不能混用，在一次命令中， 只能指定一种</p><p>-C ：使用对比模式，将备份的文件与已存在的文件相互对比</p><p>-i ：使用交互模式，在进行还原操作时，restors 指令将依序询问用户</p><p>-r ：进行还原模式</p><p>-t ：查看模式，看备份文件有哪些文件</p><br><p>选项</p><p>-f   &lt;备份设备&gt;：从指定的文件中读取备份数据，进行还原操作</p><br><h1 id="例题">例题</h1><p>（一）</p><p>分析日志 t.log（访问量），将各个 ip 地址截取，并统计出现次数,并按从大到小排序</p><p>http://<span></span>192.168.200.10/index1.html</p><p>http://<span></span>192.168.200.10/index2.html</p><p>http://<span></span>192.168.200.20/index1.html</p><p>http://<span></span>192.168.200.30/index1.html</p><p>http://<span></span>192.168.200.40/index1.html</p><p>http://<span></span>192.168.200.30/order.html</p><p>http://<span></span>192.168.200.10/order.html</p><br><p>先创建文件 t.txt，再将内容复制到文件中</p><p>cat   t.txt   |   cut   -d   ‘/’   -f   3   |   sort   |   uniq   -c   |  sort   -nr</p><p>PS：uniq  -c 是统计相邻行的重复情况，所以要先排序，将相同的 ip 排在一起</p><br><p>（二）</p><p>统计连接到服务器的各个 ip 情况，并按连接数从大到小排序</p><p>netstat  -an  |  grep  ESTABLISHED  |  awk  -F  &quot; &quot;   ‘{print  $5}’  |  cut  -d  “:”  -f  1 | sort | uniq  -c | sort  -nr</p><br><p>（三）</p><p>统计 ip 访问情况，要求分析 nginx 访问日志（access.log），找出访问页面数量在前 2 位的 ip</p><p>cat   access.log | awk   -F   &quot; &quot;   ‘{print $1}’  | sort | uniq   -c | sort   -nr | head  -2</p><br><p>（四）忘记了 mysql5.7 数据库的 ROOT 用户的密码，如何找回？</p><p>​        vim   /etc/my.cnf</p><p>​        添加一句话  skip-grant-tables</p><p>​        service   mysqld   restart</p><p>​        mysql   -u   root   -p    然后输入空密码即可进入</p><p>​        show   databases</p><p>​        use   mysql</p><p>​        update   user   set   authentication_sring=password(“shan”)   where   user=‘root’</p><p>​        flush   privileges;    刷新</p><p>​        exit</p><p>​        再把之前添加在 /etc/my.cnf 中的一句话注销，再重启 mysqld 即可</p><br><p>（五）</p><p>使用 tcpdump 监听本机，将来自 ip 192.168.200.1，tcp 端口为 22 的数据，保存输出到 tcpdump.log , 用做将来数据分析</p><p>​    tcpdump   -i   ens33   host   192.168.200.1   and   port   22   &gt;&gt;   /home/tcpdump.log</p><br><p>（六）常用的 Nginx 模块，用来做什么</p><p>rewrite 模块：实现重写功能</p><p>access 模块：来源控制</p><p>ssl 模块：安全加密</p><p>ngx_http_gzip_module：网络传输压缩模块</p><p>ngx_http_proxy_module 模块实现代理</p><p>ngx_http_upstream_module 模块实现定义后端服务器列表</p><p>ngx_cache_purge 实现缓存清除功</p><br><p>（七）如果你是系统管理员，在进行 Linux 系统权限划分时，应考虑哪些因素</p><p>1）首先阐述 Linux 权限的主要对象</p><p>2）根据自己实际经验谈考虑因素</p><p>​    注意权限分离，比如：工作中，Linux 系统权限和数据库权限不要在同一个部门</p><p>​    权限最小原则（即：在满足使用的情况下最少优先）</p><p>​    减少使用 root 用户，尽量用普通用户 + sudo 提权进行日常操作</p><p>​    重要的系统文件，日常建议使用 chattr（change attribute）锁定, 需要操作时再打开</p><p>​    使用 SUID，SGID，Sticky 设置特殊权</p><p>​    可以利用工具，比如 chkrootkit/rootkit  hunter 检测 rootkit 脚本</p><p>​    利用工具 Tripwire 检测文件系统完整性</p><br><p>（八）列举 Linux 高级命令，至少 6 个</p><p>​    netstat  //网络状态监控               top //系统运行状态        lsblk //查看硬盘分区</p><p>​    find  ps  -aux  //查看运行进程     chkconfig //查看服务启动状态     systemctl //管理系统服务</p><br><p>（九）Linux 查看内存、io 读写、磁盘存储、端口占用、进程查看命令是什么</p><p>​    top、iotop、df  -  lh、netstat  -  tunlp、ps  -  aux  |  grep</p><p>​    yum   install   iotop       有的指令默认是没有的，需要先安装</p><br><p>（十）使用 Linux 命令计算 t2.txt 第二列的和并输出</p><p>​    张三 40</p><p>​    李四 50</p><p>​    王五 60</p><p>​    cat   t2.txt   |   awk   -F   &quot; &quot;   ‘{sum+=$2}   END    {print   sum}’</p><br><p>（十一）脚本里如何检查一个文件是否存在？并给出提示</p><p>​    if   [ -f   文件名 ]   then   echo   “存在”   else   echo   “不存在”   fi</p><br><p>（十二）用 shell 写一个脚本，对文本 t3.txt 中无序的一列数字排序, 并将总和输出</p><p>​    sort   -nr   t3.txt  |  awk  '{sum+=$0;  print $0}  END  {print   &quot;和=&quot;sum}</p><br><p>（十三）请用指令写出查找当前文件夹（/home）下所有的文本文件内容中包含有字符 “ cat” 的文件名称</p><p>​    grep   -r   “cat”   /home  |  cut  -d   “:”   -f   1</p><br><p>（十四）统计/home 目录下所有文件个数和所有文件总行数的指令</p><p>​    find   /home/test   -name   “*.*”  |  wc   -l</p><p>​    find   /home/test   -name   “*.*”  |  xargs   wc  -l</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】CF558_E</title>
      <link href="/post/511433eb.html"/>
      <url>/post/511433eb.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p><strong>题目链接：</strong></p><p><a href="https://codeforces.com/contest/558/problem/E">https://codeforces.com/contest/558/problem/E</a></p><br><h2 id="题目大意">题目大意</h2><p>给定一个长度为 $n$ 的字符串（由小写英文字母组成），和 $q$ 个操作</p><p><strong>( 1 &lt;= n &lt;= 1e5、0 &lt;= q &lt;= 5e4 )</strong></p><p>每个操作 L R K 表示给区间 [L，R] 的字符串排序，K = 1为升序，K = 0为降序</p><p>要求输出最终的字符串 $s$</p><br><h2 id="分析">分析</h2><p><strong>举个例子</strong></p><p>假设区间需要从小到大排序，那么先从 a 开始，找到 a 的数量 cnta</p><p>然后把该区间内的原有 a 都删掉，然后从区间左端开始平铺 cnta 个 a</p><p>接着找到 b 的数量 cntb，清空所有的 b，再将 cntb 个 b 平铺在 a 的右边</p><p>重复平铺所有26个字母</p><p>从大到小同理，我们从右边开始平铺就好了。</p><p>差不多就是下图这样</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230105002011918.png" alt="image-20230105002011918"></p><br><p>所以我们可以用 <strong>26 棵线段树</strong> 维护区间中 <strong>每个字母</strong> 的个数</p><p>对于每个操作，我们只要把这段区间里的字母按 a − z 的顺序依次加入即可</p><ul><li><p>如果是升序，就不停更新加入左端点，右端点即为左端点加这个字母的数量</p></li><li><p>如果是降序，就不停更新加入右端点，左端点即为右端点减这个字母的数量</p></li></ul><p><strong>最后遍历所有线段树输出答案即可</strong></p><br><h2 id="code">Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">110</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-comment">// int e[M], ne[M], h[N], w[M], idx;</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> ans[N];    <span class="hljs-comment">// 记录最后的答案</span><br>string s;       <span class="hljs-comment">// 开始时的字符串</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, cnt, tag;<br>&#125; tr[<span class="hljs-number">26</span>][N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    tr[op][p].cnt = tr[op][p &lt;&lt; <span class="hljs-number">1</span>].cnt + tr[op][p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node &amp;c, node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c.tag != <span class="hljs-number">-1</span>) &#123;<br>        a.tag = b.tag = c.tag;<br>        a.cnt = a.tag * (a.r - a.l + <span class="hljs-number">1</span>);<br>        b.cnt = b.tag * (b.r - b.l + <span class="hljs-number">1</span>);<br>        c.tag = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-built_in">pushdown</span>(tr[op][p], tr[op][p &lt;&lt; <span class="hljs-number">1</span>], tr[op][p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    tr[op][p].l = l, tr[op][p].r = r, tr[op][p].tag = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        tr[op][p] = &#123;l, r, (s[l] == op + <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, op);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, op);<br>    <br>    <span class="hljs-built_in">pushup</span>(p, op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l &gt;= l &amp;&amp; tr[op][p].r &lt;= r) &#123;<br>        tr[op][p].tag = v;<br>        tr[op][p].cnt = (tr[op][p].r - tr[op][p].l + <span class="hljs-number">1</span>) * v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-type">int</span> mid = (tr[op][p].l + tr[op][p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, v, op);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, v, op);<br>    <span class="hljs-built_in">pushup</span>(p, op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l &gt;= l &amp;&amp; tr[op][p].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[op][p].cnt;<br>    <br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-type">int</span> mid = (tr[op][p].l + tr[op][p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, op);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, op);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-comment">// 遍历线段树</span><br><span class="hljs-comment">// 如果该点的权值为1，则答案中该位置为 op + &#x27;a&#x27;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">final</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l == tr[op][p].r) &#123;<br>        <span class="hljs-keyword">if</span> (tr[op][p].cnt == <span class="hljs-number">1</span>)<br>            ans[tr[op][p].l] = op + <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-built_in">final</span>(p &lt;&lt; <span class="hljs-number">1</span>, op);<br>    <span class="hljs-built_in">final</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br>    s = <span class="hljs-string">&quot; &quot;</span> + s;<br><br>    <span class="hljs-comment">// 建立26棵线段树</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, i);<br>    &#125;<br><br>    <span class="hljs-type">int</span> l, r, op;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; op;<br><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 升序</span><br>            <span class="hljs-type">int</span> idx = l, len;<br><br>            <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                len = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r, i);<br><br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)   <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 没出现该字符，跳过</span><br>                <br>                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">0</span>, i);                  <span class="hljs-comment">// 清空</span><br>                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, idx, idx + len - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, i);    <span class="hljs-comment">// 向右平铺</span><br>                idx += len;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 降序</span><br>            <span class="hljs-type">int</span> idx = r, len;<br>            <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                len = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r, i);<br><br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)   <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 没出现该字符，跳过</span><br><br>                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">0</span>, i);                  <span class="hljs-comment">// 清空</span><br>                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, idx - len + <span class="hljs-number">1</span>, idx, <span class="hljs-number">1</span>, i);    <span class="hljs-comment">// 向左平铺 </span><br>                idx -= len;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) <span class="hljs-comment">// 遍历所有线段树</span><br>        <span class="hljs-built_in">final</span>(<span class="hljs-number">1</span>, i);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">// 输出答案</span><br>        cout &lt;&lt; ans[i];<br>    <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="双倍经验">双倍经验</h2><p>CF240_F - TorCoder</p><p><strong>题目链接：</strong></p><p><a href="https://codeforces.com/contest/240/problem/F">https://codeforces.com/contest/240/problem/F</a></p><br><h3 id="题目大意">题目大意</h3><p>给定一个长为 n 的由 <strong>小写字母</strong> 组成的字符串，有 m 次操作</p><p>每次操作将 [L，R] 这些位置的字符进行重排，使得到字典序最小的回文字符串</p><p>如果无法操作就不进行</p><p>求 m 次操作后的字符串 $s$</p><br><h3 id="分析">分析</h3><p>跟上面的题目非常像，我们依然用 <strong>26 棵线段树</strong> 维护区间中 <strong>每个字母</strong> 的个数</p><p>不同的是，本题要求我们按照 <strong>字典序最小的回文串</strong> 排序</p><p>首先，我们很容易发现如果区间可以重排为一个回文串则意味下面的任意一种情况：</p><ol><li>所有字母出现的次数都是偶数</li><li>只有一个字母出现的次数是奇数，其余全是偶数</li></ol><p><strong>那么我们怎么保证排列后的回文串是字典序最小的呢？</strong></p><ul><li>只需要把字典序小的字母 放在前面就好了</li></ul><p>具体地说，</p><p>我们先将区间 “清空”</p><p>如果有一个字母出现的是奇数次，将它放到中间</p><p>然后从 ‘a’ 到 ‘z’，每个字母 在区间的两端各放一半，从两边向中间平铺即可，如下图</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230105201433450.png" alt="image-20230105201433450"></p><p><strong>最后遍历所有线段树输出答案</strong></p><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 线段树部分 与上题一样的</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">110</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-comment">// int e[M], ne[M], h[N], w[M], idx;</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> ans[N];    <span class="hljs-comment">// 记录最后的答案</span><br>string s;       <span class="hljs-comment">// 开始时的字符串</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, cnt, tag;<br>&#125; tr[<span class="hljs-number">26</span>][N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    tr[op][p].cnt = tr[op][p &lt;&lt; <span class="hljs-number">1</span>].cnt + tr[op][p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node &amp;c, node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c.tag != <span class="hljs-number">-1</span>) &#123;<br>        a.tag = b.tag = c.tag;<br>        a.cnt = a.tag * (a.r - a.l + <span class="hljs-number">1</span>);<br>        b.cnt = b.tag * (b.r - b.l + <span class="hljs-number">1</span>);<br>        c.tag = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-built_in">pushdown</span>(tr[op][p], tr[op][p &lt;&lt; <span class="hljs-number">1</span>], tr[op][p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    tr[op][p].l = l, tr[op][p].r = r, tr[op][p].tag = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        tr[op][p] = &#123;l, r, (s[l] == op + <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, op);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, op);<br>    <br>    <span class="hljs-built_in">pushup</span>(p, op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l &gt;= l &amp;&amp; tr[op][p].r &lt;= r) &#123;<br>        tr[op][p].tag = v;<br>        tr[op][p].cnt = (tr[op][p].r - tr[op][p].l + <span class="hljs-number">1</span>) * v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-type">int</span> mid = (tr[op][p].l + tr[op][p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, v, op);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, v, op);<br>    <span class="hljs-built_in">pushup</span>(p, op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l &gt;= l &amp;&amp; tr[op][p].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[op][p].cnt;<br>    <br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-type">int</span> mid = (tr[op][p].l + tr[op][p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, op);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, op);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">final</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l == tr[op][p].r) &#123;<br>        <span class="hljs-keyword">if</span> (tr[op][p].cnt == <span class="hljs-number">1</span>)<br>            ans[tr[op][p].l] = op + <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-built_in">final</span>(p &lt;&lt; <span class="hljs-number">1</span>, op);<br>    <span class="hljs-built_in">final</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, op);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br>    s = <span class="hljs-string">&quot; &quot;</span> + s;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, i);<br><br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) mp[i] = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r, i);<br><br>        <span class="hljs-type">int</span> odd = <span class="hljs-number">0</span>, idx;<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[i] &amp; <span class="hljs-number">1</span>)  odd++, idx = i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (odd &gt; <span class="hljs-number">1</span>)    <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 出现奇数次的字母只能有一个</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">0</span>, i);  <span class="hljs-comment">// 清空</span><br><br>        <span class="hljs-keyword">if</span> (odd) &#123;                  <span class="hljs-comment">// 先将出现奇数次的字母放一个到正中间</span><br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            mp[idx]--, <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, mid, mid, <span class="hljs-number">1</span>, idx);<br>        &#125;<br><br>        <span class="hljs-type">int</span> nl = l, nr = r;         <span class="hljs-comment">// 从两边向中间放，一边放一半</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, nl, nl + mp[i] / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, i);<br>            nl += mp[i] / <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, nr - mp[i] / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, nr, <span class="hljs-number">1</span>, i);<br>            nr -= mp[i] / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) <span class="hljs-comment">// 遍历所有线段树</span><br>        <span class="hljs-built_in">final</span>(<span class="hljs-number">1</span>, i);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">// 输出答案</span><br>        cout &lt;&lt; ans[i];<br>    <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>PS:</strong></p><p>这题要求从文件 <code>input.txt</code> 中读入数据，输出到文件 <code>output.txt</code> 中</p><p>main函数加段代码就行了，具体不懂~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ONLINE_JUDGE</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】ABC280_F</title>
      <link href="/post/50a3438f.html"/>
      <url>/post/50a3438f.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p><strong>题目链接：</strong></p><p><a href="https://atcoder.jp/contests/abc280/tasks/abc280_f">https://atcoder.jp/contests/abc280/tasks/abc280_f</a></p><br><h2 id="题目大意">题目大意</h2><p>对于 n 个点，m 条边的有向图 G</p><p>有 a → b 的长为 c (c ≥ 0) 的边，且有 b → a 的长为 −c 的边</p><p>对于 q 次询问，每次询问两点之间的最长距离</p><p>如果不可能到达输出 “nan”，如果距离无限大输出 “inf”</p><p>$$n,m,k&lt;=10^5$$</p><br><h2 id="分析">分析</h2><p><strong>（1）对于不可能到达的情况</strong></p><p>我们可以直接用并查集维护连通性</p><p>若两个点不在同一个连通分量，则说明他们不连通，输出 “nan”</p><br><p><strong>（2）对于距离无限大的情况</strong></p><p>显然，当连通块内存在正环时，连通块内的任何两个点之间的距离都是无穷大</p><p>（绕着正环一直走）</p><p><strong>寻找正环的方式：</strong></p><p>我们从连通块中任意选择一个点开始 bfs，</p><p>若到达某一点的距离不唯一，则说明存在正权环，输出“inf”</p><p><strong>为什么距离不唯一就存在正环？</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230102221748726.png" alt="image-20230102221748726"></p><p>如上图，从节点1开始 bfs，到达节点 4 的距离有两个</p><ul><li>dis1 = w1 + w2</li><li>dis2 = w3 + w4</li></ul><p>我们假设dis1 &gt; dis2，即 w1 + w2 &gt; w3 + w4</p><p>则按照题意，节点1 -&gt; 节点2 -&gt; 节点4 -&gt; 节点3 -&gt; 节点1</p><p>= w1 + w2 - w4 - w3</p><p>= dis1 - dis2&gt; 0</p><p>即存在正环</p><br><p><strong>（3）对于距离有限的情况</strong></p><p>如果以上两种情况都不是，则连通分量内的任意两点联通且距离唯一。</p><p>我们随意找到连通块内的一个点 rt，预处理出所有的点到 rt 的距离，记作 dis[]</p><p>则点 x 和点 y 之间的距离可以表示为 <strong>dis[y] - dis[x]</strong></p><br><p>我们发现（3）中的dis数组可以在 bfs 判断有无正环时得到</p><h2 id="code">Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, k, p[N], dis[N];<br><span class="hljs-type">bool</span> lp[N], vis[N]; <span class="hljs-comment">// lp[i] - 是否存在正环</span><br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)  p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    vis[s] = <span class="hljs-literal">true</span>, dis[s] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (!vis[j]) &#123;<br>                vis[j] = <span class="hljs-literal">true</span>;<br>                dis[j] = dis[t] + w[i];<br>                q.<span class="hljs-built_in">push</span>(j);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (dis[t] + w[i] != dis[j]) &#123;<br>                lp[<span class="hljs-built_in">find</span>(s)] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">10</span>; i++) &#123;<br>        dis[i] = INF;<br>        p[i] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br><br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, -c);<br><br>        <span class="hljs-type">int</span> fa = <span class="hljs-built_in">find</span>(a), fb = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (fa != fb)   p[fa] = fb;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">find</span>(i);<br>        <span class="hljs-keyword">if</span> (vis[tmp])   <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">bfs</span>(tmp);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-type">int</span> x, y;   cin &gt;&gt; x &gt;&gt; y;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(x) != <span class="hljs-built_in">find</span>(y))<br>            cout &lt;&lt; <span class="hljs-string">&quot;nan&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lp[<span class="hljs-built_in">find</span>(x)])<br>            cout &lt;&lt; <span class="hljs-string">&quot;inf&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; dis[y] - dis[x] &lt;&lt; endl; <br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】创建对象时类的调用顺序</title>
      <link href="/post/cc4f59b0.html"/>
      <url>/post/cc4f59b0.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><h2 id="代码块">代码块</h2><p>在Java中，使用 { } 括起来的代码被称为代码块（Code block）</p><br><p>又称作初始化块，属于类中的成员，不需要通过对象名或者类名显式调用，而是在加载类的时候，隐式的被调用。</p><h3 id="分类">分类</h3><p>根据其位置和声明的不同，可以分为：</p><ul><li>普通（局部）代码块</li><li>同步代码块</li><li>静态代码块</li><li>构造（实例）代码块</li></ul><h3 id="普通局部代码块">普通(局部)代码块</h3><p>在类的方法体中出现，可以限定变量生命周期，及早释放，提高内存利用率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 局部代码块</span><br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        &#125;<br>        <span class="hljs-comment">// 局部代码块中声明的变量在代码块外部访问不到！</span><br>        <span class="hljs-comment">// System.out.println(n);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="同步代码块">同步代码块</h3><p>同步代码块指的是被Java中Synchronized关键词修饰的代码块</p><p>在Java中，Synchronized关键词不仅仅可以用来修饰代码块，与此同时也可以用来修饰方法，是一种线程同步机制</p><p>被Synchronized关键词修饰的代码块会被加上内置锁</p><br><h3 id="静态代码块">静态代码块</h3><p>直接放在类下的代码块，由static修饰的就是静态代码块。</p><p><strong><font color="#006eb1">静态代码块只能调用静态成员</font></strong></p><br><h4 id="静态代码块的形式">静态代码块的形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 内容</span><br>        System.out.println(<span class="hljs-string">&quot;执行静态代码块...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="调用时机">调用时机</h4><p><font color="#006eb1">与类的加载一起执行，并且仅执行一次</font></p><p><strong>那么，类在什么时候被加载？</strong></p><ol><li>创建对象实例时</li><li>创建子类对象时，其父类也会被加载</li><li>使用类的静态成员时</li></ol><p><strong>如果一个类中有多个静态代码块，会按照书写顺序依次执行</strong></p><br><h3 id="构造代码块">构造代码块</h3><p>直接放在类下的代码块，不加任何的修饰符</p><p><strong><font color="#006eb1">构造代码块可以调用任意成员</font></strong></p><br><h4 id="构造代码块的形式">构造代码块的形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    &#123;<br>        <span class="hljs-comment">// 内容</span><br>        System.out.println(<span class="hljs-string">&quot;执行构造代码块...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="调用时机">调用时机</h4><p>与对象初始化一起加载，每次调用构造方法（即创建对象）都会执行，<strong>且优先度高于构造方法</strong></p><p>我们可以把它理解为另一种构造器或者说是对构造器的补充。</p><p>比如，当多个构造器都有相同的部分时，我们可以把相同的部分抽取到代码块中。</p><br><p>需要注意的是：</p><p><strong>如果仅使用类的静态成员，构造代码块是不会执行的</strong></p><p>因为构造代码块必须在创建对象时被调用，而使用类的静态成员并不需要创建对象</p><br><h2 id="执行顺序">执行顺序</h2><p>根据是否加修饰符【static】可以把类下的代码块分为<strong>静态代码块和构造代码块</strong></p><br><p>在Java中</p><p><font color="#006db0">静态代码块、构造代码块和构造函数的执行顺序是一个笔试的考点</font></p><p>这篇文章主要就是来介绍它们之间的执行顺序</p><h2 id="在单纯的一个类中">在单纯的一个类中</h2><p><strong>创建一个对象时的调用顺序：</strong></p><ol><li>调用静态代码块和静态属性初始化（优先级一样，存在多个时按定义顺序调用）</li><li>调用构造代码块和普通属性初始化（优先级一样，存在多个时按定义顺序调用）</li><li>调用构造方法（构造器）</li></ol><br><p><strong>简而言之：</strong></p><p><font color="#006db0">静态代码块 &gt; 构造代码块 &gt; 构造器</font></p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1_1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// 静态属性的初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> getNum1();<br><br>    <span class="hljs-comment">// 静态代码块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行静态代码块1....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行静态代码块2....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 普通属性的初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> getNum2();<br><br>    <span class="hljs-comment">// 构造代码块</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行构造代码块2....&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行构造代码块1....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;A() 构造器被调用...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNum1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行静态属性的初始化....&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNum2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行普通属性的初始化....&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序的执行结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">执行静态属性的初始化....</span><br><span class="hljs-comment">执行静态代码块1....</span><br><span class="hljs-comment">执行静态代码块2....</span><br><span class="hljs-comment">执行普通属性的初始化....</span><br><span class="hljs-comment">执行构造代码块2....</span><br><span class="hljs-comment">执行构造代码块1....</span><br><span class="hljs-comment">A() 构造器被调用...</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><h2 id="在有继承关系的类中">在有继承关系的类中</h2><p><strong>先不考虑静态构造器和静态属性初始化</strong></p><p>我们可以把子类的构造函数看作是</p><ul><li>supper()– 调用父类的构造器</li><li>调用本类的构造代码块</li><li>执行构造器</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1_1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行父类的构造代码块....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-comment">// 调用构造代码块</span><br>        System.out.println(<span class="hljs-string">&quot;父类的 A() 构造器被调用....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行子类的构造代码块....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-comment">// 调用构造代码块</span><br>        System.out.println(<span class="hljs-string">&quot;子类的 B() 构造器被调用...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序的执行结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">执行父类的构造代码块....</span><br><span class="hljs-comment">父类的 A() 构造器被调用....</span><br><span class="hljs-comment">执行子类的构造代码块....</span><br><span class="hljs-comment">子类的 B() 构造器被调用...</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><p>如上规律是我们不考虑静态构造器和静态属性初始化</p><p><strong>我们知道在创建一个对象时的步骤是：</strong></p><ol><li>加载类，先加载父类，再加载子类</li><li>创建对象</li></ol><p>所以我们就会先在加载类时执行静态代码块和静态属性初始化（先父类再子类）</p><p><font color="#006eb1">因此静态构造器和静态属性初始化则总是最早发生</font></p><br><p>综上所述</p><p><strong>创建一个带有继承关系的对象时的调用顺序：</strong></p><ol><li>父类的静态代码块和静态属性初始化（优先级一样，按定义顺序调用）</li><li>子类的静态代码块和静态属性初始化（优先级一样，按定义顺序调用）</li><li>父类的构造代码块和普通属性初始化（优先级一样，按定义顺序调用）</li><li>父类的构造器</li><li>子类的构造代码块和普通属性初始化（优先级一样，按定义顺序调用）</li><li>子类的构造器</li></ol><br><p><strong>简而言之：</strong></p><p><font color="#006db0">父静态代码块 &gt; 子静态代码块 &gt; 父构造代码块 &gt; 父构造器 &gt; 子构造代码块 &gt; 子构造器</font></p><p><strong>示例：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221223134333437.png" alt="image-20221223134333437"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序的执行结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">执行父类的静态属性初始化....</span><br><span class="hljs-comment">执行父类的静态代码块....</span><br><span class="hljs-comment">执行子类的静态属性初始化....</span><br><span class="hljs-comment">执行子类的静态代码块....</span><br><span class="hljs-comment">执行父类的普通属性初始化....</span><br><span class="hljs-comment">执行父类的构造代码块....</span><br><span class="hljs-comment">父类的 A() 构造器被调用....</span><br><span class="hljs-comment">执行子类的普通属性初始化....</span><br><span class="hljs-comment">执行子类的构造代码块....</span><br><span class="hljs-comment">子类的 B() 构造器被调用...</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><p><strong>需要注意的是，因为类仅加载一次</strong></p><p><strong><font color="#0089cf">所以当第二次创建该类的对象时，第1 - 2步（即静态代码块和静态属性初始化）就不再进行</font></strong></p><p>如下面的示例，第二次创建的tmp对象就不再执行静态代码块和静态属性初始化</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 若上图的主方法改为</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1_1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        System.out.println(<span class="hljs-string">&quot;===============================&quot;</span>);<br>        <span class="hljs-type">B</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序的执行结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">执行父类的静态属性初始化....</span><br><span class="hljs-comment">执行父类的静态代码块....</span><br><span class="hljs-comment">执行子类的静态属性初始化....</span><br><span class="hljs-comment">执行子类的静态代码块....</span><br><span class="hljs-comment">执行父类的普通属性初始化....</span><br><span class="hljs-comment">执行父类的构造代码块....</span><br><span class="hljs-comment">父类的 A() 构造器被调用....</span><br><span class="hljs-comment">执行子类的普通属性初始化....</span><br><span class="hljs-comment">执行子类的构造代码块....</span><br><span class="hljs-comment">子类的 B() 构造器被调用...</span><br><span class="hljs-comment">===============================</span><br><span class="hljs-comment">执行父类的普通属性初始化....</span><br><span class="hljs-comment">执行父类的构造代码块....</span><br><span class="hljs-comment">父类的 A() 构造器被调用....</span><br><span class="hljs-comment">执行子类的普通属性初始化....</span><br><span class="hljs-comment">执行子类的构造代码块....</span><br><span class="hljs-comment">子类的 B() 构造器被调用...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><h2 id="例题">例题</h2><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221223142852604.png" alt="image-20221223142852604"></p><br><p>输出的结果应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">静态成员sam初始化<br><span class="hljs-keyword">static</span>块被执行<br>sam1成员初始化<br>test1_1的默认无参构造器被调用<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类 </tag>
            
            <tag> 代码块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ACM】网络流-最小割</title>
      <link href="/post/bacb613e.html"/>
      <url>/post/bacb613e.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><h2 id="最小割">最小割</h2><p>最小割与最大流问题具有等价性。</p><p>最大流 - 最小割定理保证最大流的流量与最小割的容量相等。</p><p>利用这一性质，我们可以将最小割问题规约到最大流问题，用 EK 算法或者 Dinic 算法来寻找最小割。</p><br><p><strong>首先定义S-T Cut：</strong></p><ul><li><p>将所有的节点分成两个集合，起点 s 属于集合 S，终点 t 属于集合 T。</p></li><li><p>集合 S 和集合 T 的并集是整个节点</p></li></ul><br><p>下图就是一个 S-T Cut</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230530105236436.png" alt="image-20230530105236436"></p><p>我们可以这样理解割的容量：</p><p>割断从集合 S 流向集合 T 的管道，即上图中的</p><p>$$（v_1-&gt;v_3，v_1-&gt;v_4，v_2-&gt;v_4）$$</p><p>容量就是所有这些管道的容量之和</p><p><strong>上图S-T Cut的容量为 2 + 2 + 2 = 6</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210120417218.png" alt="image-20221210120417218"></p><p>而这个S-T Cut 的容量就是2 + 1 = 3</p><p><strong>最小割就是一个最小容量的 S-T Cut</strong></p><p>也就是我们用最小的成本来截断从集合 S 流向集合 T 的水流。</p><p><strong>注意：最小割不一定唯一，比如下图两种 S-T Cut 的容量都是3。</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210120709846.png" alt="image-20221210120709846"></p><br><h2 id="最大流-最小割定理">最大流 - 最小割定理</h2><p>对于一个网络流问题：</p><p><font size="4" color="#004a97">最大流的流量 = 最小割的容量</font></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210121007819.png" alt="image-20221210121007819"></p><p>将最小割转化成最大流问题：</p><p>1、用任意方式得到最大流问题的残留网络</p><p>2、去掉残留网中的反向边</p><p>3、在最终残留网中，从起点出发，找到所有能达到的点，这些节点作为集合S，剩下的点作为集合T。</p><p>4、此时我们得到了最小割</p><br><h2 id="例题-网络战争">例题-网络战争</h2><h3 id="题目描述">题目描述</h3><p>给出一个带权无向图 G = (V, E)，每条边 <em>e</em> 有一个权 We</p><p>求将点 s 和点 t 分开的一个边割集 C，使得该割集的平均边权最小，即最小化：</p><p>$$\frac{\displaystyle\sum_{e\in C} w_e}{|C|}$$</p><p><strong>注意：</strong></p><p>边割集的定义与最小割中的割边的集合不同</p><p>在本题中，一个边割集是指：将这些边删去之后，s 与 t 不再连通</p><br><h3 id="输入">输入</h3><p>第一行包含四个整数 n，m，s，t，其中 n，m 分别表示无向图的点数、边数</p><p>接下来 m 行，每行包含三个整数 a，b，w，表示点 a 和 b 之间存在一条无向边，边权为 w</p><p>点的编号从 1 到 n</p><h3 id="输出">输出</h3><p>输出一个实数，表示将点 s 和点 t 分开的边割集的最小平均边权</p><p>结果保留两位小数</p><br><h3 id="样例">样例</h3><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">8</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><br><h3 id="分析">分析</h3><p><strong>根据01分数规划，我们可以进行转化：</strong></p><p>$$\frac{\sum W_e}{|C|}\ \ &lt;\ \ \lambda$$</p><p>等价于</p><p>$$\sum W_e\ \ &lt;\ \ \lambda * |C|$$</p><p>等价于</p><p>$$\sum W_e-\lambda * |C|\ \ &lt;\ \ 0$$</p><p>即</p><p>$$\sum(W_e-\lambda)\ \ &lt;\ \ 0$$</p><p>所以</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221215163931649.png" alt="image-20221215163931649"></p><p><font color="#2063c0">这个性质具有二段性，可以二分</font></p><br><p>那么式子的左边该怎么得到呢？</p><p>首先我们可以建一个新图，新图上每条边的边权是原图的$W_e-\lambda$</p><p>即 $W_e’=W_e-\lambda$</p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221215170319645.png" alt="image-20221215170319645"></p><p><strong>我们注意到本题定义的割集并不是最小割中的割集</strong></p><p>如上图所示：</p><ul><li>最小割定义的割集是所有的绿色边</li><li>而本题定义的割集则又额外加了蓝色的边</li></ul><p>因为将绿色边删去之后，s 与 t 已经不再连通，此时再加上蓝色边仍然不连通</p><br><p>所以我们有以下结论：</p><ul><li>当 $W_e’&lt;0$，该边必选</li></ul><p>因为当前的边权小于零，一定会使最后的答案更小（即更优）</p><ul><li><p>对于无向边，添加双向边即可</p></li><li><p>在去掉权值小于零的边以后，就不需要再加额外的边，直接求最小割就是最终的答案</p></li></ul><p>因为额外的边只会令结果更大（而我们要求最小化结果）</p><br><p><strong>综上，本题的思路就是：</strong></p><ol><li>二分</li><li>在当前的 mid 建图</li><li>若边权（$W_e-mid$）小于零，则直接加到答案上</li><li>求最小割</li></ol><p><font color="#1a5cbe"><strong>另外本题的流量并不都是整数，所以需要用double</strong></font></p><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<br><span class="hljs-type">int</span> e[M], ne[M], tw[N], h[N], idx;<br><span class="hljs-type">double</span> w[N];<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, tw[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, tw[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">double</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">double</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">double</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">double</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">double</span> mid)</span> </span>&#123;<br>    <span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i += <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span> (tw[i] &lt;= mid) &#123;<br>            res += tw[i] - mid;      <span class="hljs-comment">// 此时边权 wi - mid &lt; 0，加上更优</span><br>            w[i] = w[i ^ <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    w[i] = w[i ^ <span class="hljs-number">1</span>] = tw[i] - mid;<br>    <br>    <span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<span class="hljs-comment">// 此处存边权</span><br>    &#125;<br><br>    <span class="hljs-comment">// 二分</span><br>    <span class="hljs-type">double</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e7</span>;<br>    <span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dinic</span>(mid) &lt; <span class="hljs-number">0</span>)r = mid;<br>        <span class="hljs-keyword">else</span>l = mid;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, r);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】星际转移问题</title>
      <link href="/post/7e22abfa.html"/>
      <url>/post/7e22abfa.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2754">https://www.luogu.com.cn/problem/P2754</a></p><h2 id="题目描述">题目描述</h2><p>由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。</p><p>现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而太空船的容量是有限的，第 $i$ 艘太空船只可容纳  $r_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如 (1,3,4) 表示该太空船将周期性地停靠太空站 134134134… 每一艘太空船从一个太空站驶往任一太空站耗时均为 1。人们只能在太空船停靠太空站(或月球、地球)时上、下船。</p><p>初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。</p><br><h2 id="分析">分析</h2><p><strong>首先我们判断是否有解：</strong></p><p>其实就是判断地球和月球之间是否连通，用并查集维护即可</p><p>具体地：</p><p>将一艘飞船可以到达的所有星球并查集连起来，最后如果地球和月球无法连接，则无解</p><br><p><strong>若有解：</strong></p><p>枚举答案 + 最大流判定</p><p>因为有距离（天数）的限制，我们使用分层图，第 i 层表示第 i 天</p><p>以站点为点，太空船为边，人为流量</p><br><p><strong>建图：</strong></p><p>每一层图都有包括地球和月球在内的 n + 2 个点</p><p>有三类边：</p><ol><li>源点和汇点<ul><li>从源点向第0层(即第0天) 的0号点(即地球) 连一条容量为 k 的边，表示一开始有 k 个人</li><li>从每一层的 n + 1 号点(即月球) 向 汇点连一条容量为 INF 的边</li></ul></li><li>从第 i 层向第 i + 1 层可达到的点连一条容量为$r_i$ 的边，表示限制太空船的容纳人数</li><li>第 i 层的每个点向第 i + 1 层连一条容量为 INF 的边，表示人们可以在当前太空站停留</li></ol><p>如下图，我们不同的颜色表示三种类型的边</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221214123521342.png" alt="image-20221214123521342"></p><p>所以这题的做法就是：</p><ul><li><p>枚举day</p></li><li><p>求最大流，如果最大流大于等于k，说明我们可以把k个人在day天内移动到月球</p></li></ul><br><p>当然二分 day 也是可以的</p><p><strong>但是我们从小到大枚举 day 会比二分更优：</strong></p><p>因为随着层数的增加，点数和边数会越来越多，越来越复杂</p><p>二分的话需要每次都重新建图</p><p>而枚举只需要在当前的基础上加一些额外的边即可</p><h2 id="code">Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1101</span> * <span class="hljs-number">50</span> + <span class="hljs-number">10</span>, M = (N + <span class="hljs-number">1100</span> + <span class="hljs-number">20</span> * <span class="hljs-number">1101</span>) + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, k, S, T, cur[N], d[N], p[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ship</span> &#123;<br>    <span class="hljs-type">int</span> r;<br>    vector&lt;<span class="hljs-type">int</span>&gt; zz;<br>&#125; ships[<span class="hljs-number">30</span>];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)  p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 得到第i个点在第day天的编号</span><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> day)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> day * (n + <span class="hljs-number">2</span>) + i;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    S = N - <span class="hljs-number">2</span>, T = N - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) p[i] = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-comment">// 存太空船的信息</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;   cin &gt;&gt; a &gt;&gt; b;<br>        ships[i].r = a;<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, x; j &lt; b; j++) &#123;<br>            cin &gt;&gt; x;<br>            <span class="hljs-keyword">if</span> (x == <span class="hljs-number">-1</span>)    x = n + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 是月球</span><br>            ships[i].zz.<span class="hljs-built_in">pb</span>(x);<br>            <span class="hljs-keyword">if</span> (j) &#123;<br>                <span class="hljs-type">int</span> tmp = ships[i].zz[j - <span class="hljs-number">1</span>];<br>                p[<span class="hljs-built_in">find</span>(tmp)] = <span class="hljs-built_in">find</span>(x);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 是否有解</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>) != <span class="hljs-built_in">find</span>(n + <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第一类边</span><br>    <span class="hljs-built_in">add</span>(S, <span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), k);<br>    <span class="hljs-built_in">add</span>(<span class="hljs-built_in">get</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), T, INF);<br><br>    <span class="hljs-comment">// 枚举天数day</span><br>    <span class="hljs-type">int</span> day = <span class="hljs-number">1</span>, now = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 每一层的月球向汇点连一条容量为INF的边</span><br>        <span class="hljs-built_in">add</span>(<span class="hljs-built_in">get</span>(n + <span class="hljs-number">1</span>, day), T, INF);<br>        <br>        <span class="hljs-comment">// 表示在太空站停留的边</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> u = <span class="hljs-built_in">get</span>(i, day - <span class="hljs-number">1</span>), v = <span class="hljs-built_in">get</span>(i, day);<br>            <span class="hljs-built_in">add</span>(u, v, INF);<br>        &#125;<br><br>        <span class="hljs-comment">// 表示从上一层通过太空船到达的边，容量为ri</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-type">int</span> tt = ships[i].zz.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> a = ships[i].zz[(day - <span class="hljs-number">1</span>) % tt], b = ships[i].zz[day % tt];<br>            <span class="hljs-type">int</span> u = <span class="hljs-built_in">get</span>(a, day - <span class="hljs-number">1</span>), v = <span class="hljs-built_in">get</span>(b, day);<br>            <span class="hljs-built_in">add</span>(u, v, ships[i].r);<br>        &#125;<br><br>        now += <span class="hljs-built_in">dinic</span>();<br>        <span class="hljs-keyword">if</span> (now &gt;= k)   <span class="hljs-keyword">break</span>;<br>        day++;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出答案</span><br>    cout &lt;&lt; day &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 网络流24题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ACM】最大流模型(二)</title>
      <link href="/post/9be3e0a3.html"/>
      <url>/post/9be3e0a3.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><h2 id="多源汇最大流">多源汇最大流</h2><p>这种多起点题型很容易就能想到：</p><ul><li><p>建立一个超级源点，从超级源点向所有源点连一条容量是无穷大的边</p></li><li><p>建立一个超级汇点， 所有汇点向超级汇点连一条容量为无穷大的边</p></li></ul><p>在新图跑最大流即可得出原图的最大流。</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221214091959047.png" alt="image-20221214091959047"></p><h3 id="模板题">模板题</h3><h4 id="题目描述">题目描述</h4><p>给定一个包含 n 个点 m 条边的有向图，并给定每条边的容量，边的容量非负。</p><p>其中有 $S_c$ 个源点，$T_c$ 个汇点，图中可能存在重边和自环。</p><p>保证源点集合和汇点集合没有交集，求整个网络的最大流。</p><br><h4 id="输入">输入</h4><p>第一行包含四个整数 n，m，$S_c$，$T_C$</p><p>第二行包含 $S_c$ 个整数，表示所有源点的编号</p><p>第三行包含 $T_c$ 个整数，表示所有汇点的编号</p><p>接下来 m 行，每行三个整数 u，v，c，表示从点 u 到点 v 存在一条有向边，容量为 c</p><p>点的编号从 1 到 n</p><h4 id="输出">输出</h4><p>输出一个整数表示整个网络的最大流</p><br><h4 id="样例">样例</h4><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">70<br></code></pre></td></tr></table></figure><br><h4 id="code">Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><span class="hljs-type">int</span> sc, tc;<br><br><span class="hljs-comment">// dinic()</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; sc &gt;&gt; tc;<br>    S = <span class="hljs-number">0</span>, T = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= sc; i++) &#123;<br>        cin &gt;&gt; x;<br>        <span class="hljs-built_in">add</span>(S, x, INF);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= tc; i++) &#123;<br>        cin &gt;&gt; x;<br>        <span class="hljs-built_in">add</span>(x, T, INF);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">dinic</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="最大流关键边">最大流关键边</h2><p><font color="#008ad0">只给其扩大容量之后整个流网络的最大流能够变大，对于这样的边我们称之为关键边。</font></p><br><p>判断 u-&gt;v 是否为关键边：</p><ul><li><p>在某一个最大可行流中，这条边的流量是满的</p></li><li><p>在当前残留网络中，存在一条 S-&gt;u 和 v-&gt;T 的路径</p></li></ul><br><p>具体地：</p><ol><li><p>我们先对原图做一遍dinic</p></li><li><p>在当前最大流的残留网络上进行搜索</p><ul><li>在其残留网络上沿着容量大于0的边走，所有从源点能够到达的点和所有汇点能够到达的点打上标记</li></ul></li><li><p>当一条边满足：满流（f[i] == 0），并且他的起始点能从 S 点出发搜索到，终止点能够从 T 点出发搜索到，则为关键边。</p></li></ol><br><p><strong>从汇点搜的时候需要用反向边判断，即：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221214101357922.png" alt="image-20221214101357922"></p><p>我们用一号类型的边找到点，再用二号类型的边（即反向边）进行判断</p><br><h3 id="模板题">模板题</h3><h4 id="题目描述">题目描述</h4><p>伊基编写了一个最大流程序，并计算出了当前运输网络的最大运输能力。</p><p>他对运输速度的现状十分不满，并希望能够提高国家的运输能力。</p><p>提高运输能力的方法很简单，伊基将在运输网络中重建一些道路，以使这些道路具有更高的运输能力。</p><p>但是不幸的是，凤凰国的财力有限，道路建设经费只够重建一条道路，伊基想要知道共有多少条道路可以纳入重建道路候选名单，这些道路需要满足，将其重建后，国家的总运输能力能够增加。</p><br><h4 id="输入">输入</h4><p>第一行包含 N 和 M，分别表示城市和道路的数量</p><p>接下来 M 行，每行包含三个整数 a，b，c，表示存在一条道路从城市 a 通往城市 b，且运输能力为 c</p><p>所有道路都是有方向的，城市编号从 0 到 N−1</p><p>生产日常商品的城市为 0 号城市，首都为 N−1 号城市</p><h4 id="输出">输出</h4><p>输出一个整数 K</p><p>表示存在 K 条道路，对其中每条道路进行重建都会增加运输网络的运输能力。</p><br><h4 id="样例">样例</h4><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><br><h4 id="code">Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><span class="hljs-type">bool</span> vis_s[N], <span class="hljs-type">vis_t</span>[N];<br><br><span class="hljs-comment">// dinic（）</span><br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">bool</span> st[], <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = i ^ op, ver = e[i];<br>        <span class="hljs-keyword">if</span> (w[j] &amp;&amp; !st[ver])   <span class="hljs-built_in">dfs</span>(ver, st, op);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    S = <span class="hljs-number">0</span>, T = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <span class="hljs-built_in">dinic</span>();<br><br>    <span class="hljs-built_in">dfs</span>(S, vis_s, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 0 表示不需要用反向边来判断</span><br>    <span class="hljs-built_in">dfs</span>(T, <span class="hljs-type">vis_t</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">// 1 表示需要用反向边来判断</span><br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> u = e[i ^ <span class="hljs-number">1</span>], v = e[i];<br>        <span class="hljs-keyword">if</span> (!w[i] &amp;&amp; vis_s[u] &amp;&amp; <span class="hljs-type">vis_t</span>[v])  ans++;<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br><h2 id="最大流判定">最大流判定</h2><p>直接看题。</p><br><h3 id="秘密挤奶机">秘密挤奶机</h3><p><strong>题目链接：<a href="http://poj.org/problem?id=2455">http://poj.org/problem?id=2455</a></strong></p><h4 id="题目描述">题目描述</h4><p>题目说现在有 n 个点，p 条边</p><p>每条边只能走一次，现在要从 1 号点到 n 号点走 t 次</p><p>求出所有走的边的最大值，使这个最大值最小</p><br><h4 id="输入">输入</h4><p>第一行包含三个整数 N，P，T</p><p>接下来 P 行，每行包含三个整数 a，b，c，表示地标 a 和 b之间存在一条长度为 c 的道路</p><h4 id="输出">输出</h4><p>输出一个整数，表示约翰必须使用的最长的单个道路的最小可能长度</p><br><h4 id="样例">样例</h4><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">9</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><br><p><strong>经典最大值最小化问题，可以直接二分出最大的边权 mid</strong></p><p>看是否存在一个最大流，其中所有边权都小于等于 mid，且流量大于 K</p><p>不断二分下去即可找到答案</p><br><p>那么现在的问题就是如何判断我们能不能只用长度小于 mid 的边，能走 t 次</p><p>也就是如何写我们的check函数，我们可以使用最大流判定</p><br><p>我们可以按照这个图建一个网络流，给每条长度小于 mid 的边流量为 1，说明只能走一次</p><p>大于 mid 的边流量为0，说明不能走</p><p>源点设为 1，汇点设为 n，求一遍源点到汇点的最大流就能得到我们能走多少遍，再判断是否大于等于要求的 t 即可</p><br><p><strong>还有一个问题，就是无向图向有向图的转换</strong></p><p>题目给定的是无向图，而网络流用的是有向图</p><p>我们在建图时，对于一条无向边（u，v），我们建两条有向边 u -&gt; v 和 v -&gt; u 两条有向边</p><p>Q：如下图，原网络中只能走一次，但是我们建了双向边的话就可以来回各走一次，不就不符合容量限制了吗？<br><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221214113132889.png" alt="image-20221214113132889"></p><p><strong>我们可以把正反各走一次看作没有流量经过，所以不影响容量限制</strong></p><br><h4 id="code">code</h4><p>这里我们开始时先存边的长度tw[]，在二分时再修改边的容量w[]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><span class="hljs-type">int</span> k, tw[M];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, tw[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, tw[idx] = c, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-comment">// dinic()</span><br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// 修改容量限制</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++) &#123;<br>        <span class="hljs-keyword">if</span> (tw[i] &gt; x)  w[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span>    w[i] = <span class="hljs-number">1</span>;   <br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">return</span> res &gt;= k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    S = <span class="hljs-number">1</span>, T = n;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-comment">// 建图，记录边的长度tw[]</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br><br>    <span class="hljs-comment">// 二分</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e6</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span>    l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    cout &lt;&lt; l &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ACM】最大流模型(一)</title>
      <link href="/post/a362395a.html"/>
      <url>/post/a362395a.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p>本篇内容大多参考 <a href="https://www.cnblogs.com/liu-runda/p/6262832.html">https://www.cnblogs.com/liu-runda/p/6262832.html</a></p></font><h2 id="无源汇上下界可行流循环流">无源汇上下界可行流(循环流)</h2><font size="3"><p><strong>模型：</strong></p><p>给一个网络，求一个流满足：</p><p>每条边 i 流量在 [low(i), upp(i)] 之间，每个点 u 都要满足流量守恒。</p><br><p><font color="\#004a97">可行流算法的核心是将一个不满足流量守恒的初始流调整成满足流量守恒的流</font></p><br><p>如果存在一个可行流，那么一定满足每条边的流量都大于等于流量的下限。</p><p>因此我们可以令每条边的流量等于流量下限，得到一个初始流。</p><p>然后建出这个流的残量网络。(即：每条边的流量等于这条边的流量上限与流量下限之差)</p><br><p>初始流就是一开始将每条边流量设为low(i)的流，显然这个流不一定满足流量守恒。</p><p>因此我们考虑在残量网络上求出一个另不满足流量守恒的附加流，使得这个附加流和我们的初始流合并之后满足流量守恒。即:</p><ul><li><p>如果某个点在初始流中满足流量守恒，那么这个点在附加流中也满足流量守恒</p></li><li><p>如果某个点在初始流中的流入量比流出量多x，那么这个点在附加流中的流出量比流入量多x</p></li><li><p>如果某个点在初始流中的流入量比流出量少x，那么这个点在附加流中的流出量比流入量少x</p></li></ul><p>X的数值可以枚举x的所有连边求出，比较方便的写法是开一个数组A[]，</p><p><strong>A[i]表示i在初始流中的流入量 - 流出量的值</strong></p><p>那么A[i]的正负表示流入量和流出量的大小关系，下面就用A[i]表示初始流中 i 的流入量 - 流出量</p><br><p>所以在附加流中，让点 u 的流入量 - 流出量 = −A[u]，就能保证流量守恒。</p><ul><li><p>当 A[u] &gt; 0（即 -a[u] &lt; 0），需要让u的流入量增加a[u]。</p><ul><li>这可以通过新建超级源点 SS，并增加 SS→u，容量为 A[u] 的边做到</li></ul></li><li><p>当 A[u] &lt; 0（即 -A[u] &gt; 0），需要让u的流出量增加A[u]。</p><ul><li>这可以通过新建超级汇点 TT，并增加 u→TT，容量为 −A[u] 的边做到</li></ul></li></ul><br><p>如果我们能找到一个流满足新加的边都满流，那这个流在原图上的部分就是我们需要的附加流。</p><p>(根据我们的建图方式，<strong>“新加的边都满流”</strong> 和 ”附加流合并上初始流得到流量平衡的流” 是等价的约束条件)</p><br><p><strong>那么怎样找出一个新加的边都满流的流呢？</strong></p><p>可以发现假如存在这样的方案，这样的流一定是我们所建出的图的 SS-TT 最大流。</p><p><strong>解法：</strong></p><p>跑 SS-TT 的最大流，再判断最大流的大小是否等于 SS 出发的所有边的流量上限之和（此时指向 TT 的边也一定满流，因为这两部分边的流量上限之和相等)。</p><p>最后，每条边在可行流中的流量 = 容量下界 + 附加流中它的流量（即跑完dinic之后所加反向边的权值）</p><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">500</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">200010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N], low[M], upp[M], a[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);<br><br>    S = <span class="hljs-number">0</span>, T = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;u, &amp;v, &amp;low[i], &amp;upp[i]);<br>        a[u] -= low[i], a[v] += low[i]; <span class="hljs-comment">// 构造差</span><br>        <span class="hljs-built_in">add</span>(u, v, upp[i] - low[i]);     <span class="hljs-comment">// 建残留网络</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(S, i, a[i]), tot += a[i];<br>        <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(i, T, -a[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span> (ans != tot) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, w[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] + low[i + <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br></font><h2 id="有源汇上下界可行流">有源汇上下界可行流</h2><font size="3"><p><strong>模型：</strong></p><p>现在的网络有一个源点 s 和汇点 t。求出一个流使得源点的总流出量等于汇点的总流入量。</p><p>其他的点满足流量守恒，而且每条边的流量满足上界和下界限制。</p><br><p>为了使源汇点满足流量守恒，我们需要有边流入源点 s，有边流出汇点 t。</p><p>注意到源点 s 的流出量等于汇点 t 的流入量，我们就可以从汇点 t 向源点 s 连一条下界为0上界为无穷大的边。</p><p>相当于把从源点 s 流出的流量再流回来。</p><p>在这样的图中套用上面的算法求出一个可行的循环流，拆掉从汇点 t 到源点 s 的边就得到一个可行的有源汇流。</p><br><p><strong>这里有一个小问题：最后得到的可行的有源汇流的流量是多少?</strong></p><p>可以发现，循环流中一定满足 s 流出的总流量 = 流入 s 的总流量</p><p>假定原图中没有边流入s，那么s流出的流量就是 t 到 s 的无穷边的流量，也就是 s-t 可行流的流量。</p><p>因此我们最后看一下 t 到 s 的无穷边的流量（即dinic跑完之后反向边的权值）即可知道原图中有源汇可行流的流量。</p><br></font><h2 id="有源汇上下界最大流">有源汇上下界最大流</h2><font size="3"><p><strong>模型：</strong></p><p>现在的网络有一个源点 s 和汇点 t，求出一个流使得源点的总流出量等于汇点的总流入量。</p><p>其他的点满足流量守恒，而且每条边的流量满足上界和下界限制。</p><p>在这些前提下要求<strong>总流量最大</strong></p><br><p>首先套用上面的算法求出一个有源汇有上下界可行流。</p><p>此时的流不一定最大，接下来在残量网络上跑 s-t 最大流即可</p><br><p><strong>最终的最大流流量 = 可行流流量(即 t 到 s 的无穷边上跑出的流量) + 新增广出的 s-t 最大流</strong></p></font><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">520</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">200010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><span class="hljs-type">int</span> a[N], s, t;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, ll, rr;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; ll &gt;&gt; rr;<br>        a[u] -= ll, a[v] += ll;<br>        <span class="hljs-built_in">add</span>(u, v, rr - ll);<br>    &#125;<br><br>    <span class="hljs-comment">// 先利用 虚拟源点S和虚拟汇点T 找到一组可行流</span><br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    S = <span class="hljs-number">0</span>, T = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(S, i, a[i]), tot += a[i];<br>        <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(i, T, -a[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">add</span>(t, s, INF);<br><br>    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span> (tmp != tot) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;No Solution&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 可行流的流量就是t到s的无穷边上跑出的流量</span><br>    <span class="hljs-type">int</span> ans = w[idx - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 然后在当前的残留网络上跑 s-t 的最大流</span><br>    S = s, T = t;<br>    w[idx - <span class="hljs-number">1</span>] = w[idx - <span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; ans + <span class="hljs-built_in">dinic</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="有源汇上下界最小流">有源汇上下界最小流</h2><font size="3"><p><strong>模型：</strong></p><p>现在的网络有一个源点 s 和汇点 t，求出一个流使得源点的总流出量等于汇点的总流入量。</p><p>其他的点满足流量守恒，而且每条边的流量满足上界和下界限制。</p><p>在这些前提下要求<strong>总流量最小</strong></p><br><p>依然是先跑出一个有源汇可行流，这时候的流也不一定是最小的。</p><p>假如我们能在残量网络上找到一条 s-t 的路径使得去掉这条路径上的流量之后仍然满足流量下限，我们就可以得到一个更小的流。但是好像我们并没有什么算法可以”找到尽可能多的能够去除流量的路径”</p><br><p>这时候需要我们再理解一下dinic的反向边：<font color="\#004a97">反向边的流量增加等价于正向边的的流量减少。</font></p><p>因此我们在残量网络上找出 t 到 s 的流就相当于减小了 s 到 t 的流，那么我们在跑出可行流的残量网络上跑 t-s 最大流，用可行流的大小减去这一次 t-s 最大流的大小就是最小流的大小。</p><p><strong>t-s 最大流其实就是尽量缩减 s-t 方向的流</strong></p></font><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e4</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><span class="hljs-type">int</span> s, t, a[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, ll, rr;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; ll &gt;&gt; rr;<br>        a[u] -= ll, a[v] += ll;<br>        <span class="hljs-built_in">add</span>(u, v, rr - ll);<br>    &#125;<br><br>    <span class="hljs-comment">// 先利用 虚拟源点S和虚拟汇点T 找到一组可行流</span><br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    S = <span class="hljs-number">0</span>, T = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(S, i, a[i]), tot += a[i];<br>        <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(i, T, -a[i]);<br>    &#125;<br>    <span class="hljs-built_in">add</span>(t, s, INF);<br><br>    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span> (tmp != tot) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;No Solution&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 可行流的流量就是t到s的无穷边上跑出的流量</span><br>    <span class="hljs-type">int</span> ans = w[idx - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 然后在当前的残留网络上跑 t-s 的最大流</span><br>    S = t, T = s;<br>    w[idx - <span class="hljs-number">1</span>] = w[idx - <span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; ans - <span class="hljs-built_in">dinic</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】最长不下降子序列问题</title>
      <link href="/post/da24e842.html"/>
      <url>/post/da24e842.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2766">https://www.luogu.com.cn/problem/P2766</a></p><h2 id="题目描述">题目描述</h2><p>给定正整数序列</p><p>$${x_1,x_2,x_3…x_n}$$</p><ol><li>计算其最长不下降子序列的长度 $s$。</li><li>计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。</li><li>如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$ ，则从给定序列中最多可取出多少个长度为$s$ 的不下降子序列。</li></ol><br><h2 id="分析">分析</h2><p><font color="\#004a97">最大流拆点模型</font></p><p>我们可以通过容量来限制边</p><p>通过拆点来限制点</p><p>(1) <strong>第一问：</strong> 可以dp求解 maxlen</p><p>dp[i] 表示以 a[i] 结尾的最长不下降子序列长度</p><br><p>(2) <strong>第二问：</strong> 因为每个元素只能被取一次，考虑拆点。</p><p>一个点分为 i 和 i&quot;， 并在他们之间连一条容量为 1 的边。</p><ul><li><p>若 dp[i] == 1，则 S→i 连一条容量为 1 的边</p></li><li><p>若 dp[i] == x，则 i&quot;→T 连一条容量为1 的边</p></li><li><p>若 dp[i] == dp[j] + 1，j &lt; i，a[j] ≤ a[i]，则 j&quot;→i 连一条容量为 1 的边</p></li></ul><p>再跑 S-T 的最大流即可</p><br><p>(3) <strong>第三问：</strong> $x_1$ 和 $x_n$ 可以取出多次。</p><p>那么改变的就是与这两点直接相关的边的流量</p><p>我们在第二问的答案基础上，修改一些边。</p><ul><li>1→1&quot; 连一条容量为 INF 的边</li><li>n→n&quot; 连一条容量为 INF 的边</li><li>S→1 连一条容量为 INF 的边</li><li>若 dp[n] == maxlen，则 n&quot;→T 连一条容量为 1 的边</li></ul><p>再跑 S-T 的最大流即可</p><br><p><strong>特判：</strong></p><p>对于 n == 1 的情况需要特判</p><br><p><strong>那么我们为什么要拆点？</strong></p><p>我们观察序列 {4， 3， 5， 9， 7}</p><p>dp[] = {1, 1, 2, 3, 3}</p><p>如果我们不拆点的话，建图就是下图的样子</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221213215342188.png" alt="image-20221213215342188"></p><p>这个建图方式得到的最大流是2，但是我们很容易得到正确的答案应该是1</p><p>其实我们只需要加上一个虚拟点限制该点的流出量只能为1，即可解决：</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221213215558828.png" alt="image-20221213215558828"></p><p><font color="#004a97"><strong>所以我们把每个点拆分成两个点，连一条容量为 1 的边，限制住只能取一次这个条件</strong></font></p><br><h2 id="code">Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, M = N * N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, a[N], dp[N], ans1;<br><span class="hljs-type">int</span> d[N], cur[N], S, T;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">DP</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )&#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>            <span class="hljs-keyword">if</span> (a[j] &lt;= a[i])<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        ans1 = <span class="hljs-built_in">max</span>(ans1, dp[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-comment">// 特判</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">DP</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans1);<br><br><span class="hljs-comment">/* ====================================== */</span><br>    <br>    S = <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>, T = <span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">add</span>(i, i + n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">1</span>)  <span class="hljs-built_in">add</span>(S, i, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (dp[i] == ans1)  <span class="hljs-built_in">add</span>(i + n, T, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (dp[j] == dp[i] + <span class="hljs-number">1</span> &amp;&amp; a[i] &lt;= a[j])<br>                <span class="hljs-built_in">add</span>(i + n, j, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">int</span> ans2 = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans2);<br><br><span class="hljs-comment">/* ====================================== */</span><br>    <br>    <span class="hljs-comment">// 特殊处理四种边，直接增广</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++) &#123;<br>        <span class="hljs-type">int</span> u = e[i ^ <span class="hljs-number">1</span>], v = e[i];<br>        <span class="hljs-keyword">if</span> (u == S &amp;&amp; v == <span class="hljs-number">1</span>)   w[i] = INF;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">1</span> &amp;&amp; v == n + <span class="hljs-number">1</span>)   w[i] = INF;<br>        <span class="hljs-keyword">if</span> (u == n &amp;&amp; v == n + n)   w[i] = INF;<br>        <span class="hljs-keyword">if</span> (u == n + n &amp;&amp; v == T)   w[i] = INF;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> ans3 = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans2 + ans3);  <span class="hljs-comment">// 加上增广前的最大流</span><br>    <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 网络流24题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】圆桌问题</title>
      <link href="/post/3f3901b7.html"/>
      <url>/post/3f3901b7.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p>题目链接： <a href="https://www.luogu.com.cn/problem/P3254">https://www.luogu.com.cn/problem/P3254</a></p><br><h2 id="题目描述">题目描述</h2><p>有来自 m 个不同单位的代表参加一次国际会议。第 i 个单位派出了 ri 个代表。</p><p>会议的餐厅共有 n 张餐桌，第 i 张餐桌可容纳 ci 个代表就餐。</p><p>为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。</p><p>请给出一个满足要求的代表就餐方案。</p><br><h2 id="分析">分析</h2><font size="4"> <p>与“飞行员配对方案问题”很像</p><p>属于网络流的二分图匹配问题。</p></font><br><p><strong>建图：</strong></p><p>根据流网络的定义，先建立源点S和汇点T。</p><ul><li>源点到每个单位连一条容量为 ri 的边 ，限制每个单位有 ri 个人。</li><li>每个公司到每个桌子连一条容量为1的边 ，限制每桌每个单位只能坐一个人。</li><li>每个桌子到汇点连一条容量为 ci 的边 ，限制每个桌子最多坐 ci 个人。</li></ul><p>可以发现，整个流网络中的可行流满足容量限制和流量守恒。</p><p>所以任意一个可行流都是一个满足题意的解</p><p>如果最大流就是 $∑ri$ 的话，就说明所有的单位里的人都找到一个不同的位置坐。</p><p>也就是可以找到满足题目要求的方案，输出1。</p><br><h2 id="输出方案">输出方案</h2><p>枚举所有左右两个集合之间的边，看哪条边的流量是满的</p><p>流量满则意味着这是一组可行的匹配</p><p>有很多种处理的方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 姿势一</span><br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= m; u++) &#123;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j &gt; m &amp;&amp; j &lt;= m + n &amp;&amp; !w[i])<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, j - m);<span class="hljs-comment">// 映射回去</span><br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 姿势二</span><br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; mp;<br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i += <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-type">int</span> v = e[i], u = e[i ^ <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (v &gt; m &amp;&amp; v &lt;= m + n &amp;&amp; !w[i])<br>        mp[u].<span class="hljs-built_in">pb</span>(v - m);<span class="hljs-comment">// 映射回去</span><br>&#125;<br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : mp[i])<br>        cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="code">Code</h2><p><strong>完整的代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">500</span> + <span class="hljs-number">10</span>, M = (<span class="hljs-number">150</span> * <span class="hljs-number">270</span> +N) * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;m, &amp;n);<br>    S = <span class="hljs-number">0</span>, T = m + n + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-comment">// 建图</span><br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> r;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;r);<br>        <span class="hljs-built_in">add</span>(S, i, r);<br>        tot += r;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> c;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;c);<br>        <span class="hljs-built_in">add</span>(m + i, T, c);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)  <br>            <span class="hljs-built_in">add</span>(i, m + j, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 判断是否可以找到满足题意的方案</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span> (ans != tot) &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 输出方案</span><br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= m; u++) &#123;<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (j &gt; m &amp;&amp; j &lt;= m + n &amp;&amp; !w[i])<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, j - m);<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 网络流24题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】飞行员配对问题</title>
      <link href="/post/85b494b8.html"/>
      <url>/post/85b494b8.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p>题目链接： <a href="https://www.luogu.com.cn/problem/P2756">https://www.luogu.com.cn/problem/P2756</a></p><h2 id="题目描述">题目描述</h2><p>一共有 n 个飞行员，其中有 m 个外籍飞行员和 (n−m) 个英国飞行员</p><p>外籍飞行员从 1 到 m 编号，英国飞行员从 m+1 到 n 编号</p><p>对于给定的外籍飞行员与英国飞行员的配合情况，找出最佳飞行员配对方案。</p><p><strong>一句话：</strong></p><p><strong>m 个外籍和 n-m 个英国飞行员两两配对，问最大匹配数和匹配方案</strong></p><br><h2 id="分析">分析</h2><font size="4"> <p>很明显的二分图最大匹配模型。</p></font><p>对于二分图的最大匹配问题：</p><ul><li><p>匈牙利算法的时间复杂度是$O(nm)$</p></li><li><p>Dinic算法的时间复杂度是$O(m\sqrt{n})$</p></li></ul><p>匈牙利算法是每次只找一条增广路的最大流算法。</p><p><strong>所以匈牙利算法本质上就是 EK算法</strong></p><br><p><strong>建图：</strong></p><p>根据流网络的定义，先建立源点S和汇点T。</p><ul><li>从源点S向所有外籍飞行员建立一条容量为1的边</li><li>从所有外籍飞行员向其可搭档的英国飞行员建立一条容量为1的边</li><li>从所有英国飞行员向汇点T建立一条容量为1的边。</li></ul><p>可以发现，整个流网络中的可行流满足容量限制和流量守恒。</p><p>所以任意一个可行流都是一个满足题意的解</p><p>那么，整个流网络中的最大流便是最大匹配方案</p><br><h2 id="输出方案">输出方案</h2><p>枚举所有左右两个集合之间的边，看哪条边的流量是满的</p><p>流满则意味着这是一组可行的匹配</p><p>有很多种处理的方式，下面是其中一种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 枚举所有的正向边</span><br><span class="hljs-comment">// 因为存图时我们成对存储，所以偶数的边就是正向边</span><br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i += <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// 两个端点</span><br>    <span class="hljs-type">int</span> v = e[i], u = e[i ^ <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 如果两个端点分别在两个集合中 并且这条边的流量已满</span><br>    <span class="hljs-keyword">if</span> (v &gt; m &amp;&amp; v &lt;= n &amp;&amp; !w[i])<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>, u, v);<span class="hljs-comment">// 输出方案</span><br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="code">Code</h2><p><strong>完整的代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">500</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">6000</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;m, &amp;n);<br>    S = <span class="hljs-number">0</span>, T = n + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 建图</span><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-built_in">add</span>(S, i, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = m + <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">add</span>(i, T, <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-type">int</span> a, b;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b), a != <span class="hljs-number">-1</span> &amp;&amp; b != <span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">add</span>(a, b, <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">// 求最大流</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">dinic</span>());<br><br>    <span class="hljs-comment">// 输出方案</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> v = e[i], u = e[i ^ <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (v &gt; m &amp;&amp; v &lt;= n &amp;&amp; !w[i])<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>, u, v); <br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 网络流24题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ACM】网络流-最大流</title>
      <link href="/post/8448711d.html"/>
      <url>/post/8448711d.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>要求：</p><p>给定一个有向带权图，其中有两个特殊的点源S（Sources）和汇T（Sinks）</p><p>每条边有指定的容量（Capacity），求满足条件的从S到T的最大流（MaxFlow）</p><p>本篇内容都基于：<a href="https://www.bilibili.com/video/BV1K64y1C7Do/">https://www.bilibili.com/video/BV1K64y1C7Do/</a></p><h2 id="基本理解">基本理解</h2><p>我们可以这样理解最大流问题：</p><ul><li><p>我们希望把水从起点 S 送到终点 T ，水要通过一些管道来输送，这些管道就是途图中的边。</p></li><li><p>边都有权重，即管道的容量，送水量不能超过管道的容量。</p></li><li><p>给定管道的限制，请问水的最大流量是多少。</p></li></ul><p><font size="4"><strong>我们先了解一种简单但是不能保证正确性的算法</strong></font></p><h2 id="naive-algorithm">Naive Algorithm</h2><p><strong>首先我们先了解什么是增广路径</strong></p><p>增广路就是从起点 S 出发，经过容量大于零的边，到达终点 T 的简单路径（无环）</p><p>我们只考虑基于原图构造的 <strong>Residual Graph</strong>，即边权为空闲量的图（残留网络）</p><p>初始时，由于没有水流经过，残留网络就是原图。</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210104305479.png" alt="image-20221210104305479"></p><p>当可以找到增广路径时我们循环进行以下操作</p><ul><li>先找到一条从起点 S 到终点 T 的增广路</li><li>找到此条路经的最小权重 x</li><li>路径上的边权（空闲量）都减去 x</li></ul><p><strong>但是这种算法会根据选择路径的顺序造成不同的答案，不能保证找到的一定是最大流，只能保证找到一个阻塞流 (Blocking Flow)。</strong></p><p>所以我们需要稍微复杂的算法来解决最大流的问题</p><h2 id="ford-fulkerson-algorithm">Ford-Fulkerson Algorithm</h2><p>Ford-Fulkerson 算法，由 Ford 和 Fulkerson 两人在 1956 年提出，这种算法可以保证找到最大流。</p><p><font color="#004a97">最坏情况下，算法的时间复杂度是 $O(f m)$，$f$ 是最大流的大小，$m$ 是边的数量。</font></p><p>观察发现简单算法的缺陷是算法不能反悔，不能纠错，一旦坏的路径被找到算法就不能找到最大流。</p><p>而Ford-Fulkerson 算法可以”反悔“，将坏的路径撤销。</p><p>依旧是仅考虑 <strong>Residual Graph</strong></p><p>与简单算法很像，当可以找到增广路时我们循环进行以下操作：</p><ul><li><p>在当前的残留网络中找增广路</p></li><li><p>更新当前的残留网络</p><ul><li><p>找到此条路经的最小权重 x</p></li><li><p>路径上的边权（空闲量）都减去 x</p></li><li><p><font color="red">添加一条权重为 x 的反向路径</font></p></li></ul></li></ul><p><strong>过程中，我们可以通过添加反向边来”纠错“。</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210105509117.png" alt="image-20221210105509117"></p><br><h2 id="edmonds-karp-algorithm">Edmonds-Karp Algorithm</h2><p>因为Ford-Fulkerson 算法的复杂度依赖最大流的大小，最坏情况下可能会很大，所以我们常把Ford-Fulkerson 算法叫做<strong>FF方法</strong>，把它当作解决最大流问题的一个核心思路，在此基础上进行不同的实现方法。</p><p>下面我们了解一个新的算法——Edmonds-Karp 算法，由 Edmonds 和 Karp 两人在 1972 年提出。</p><p>我们可以把 EK算法理解为 FF方法的一种具体实现方式，一定能找到最大流。</p><p><font size="4"><strong>核心在于 Edmonds-Karp 算法在寻找简单路径时要使用最短路算法：</strong></font></p><ul><li>寻找最短路的时候，把图当做无权图，也就是边的权重都是1。</li></ul><p><font size="4">可以想到，用基础的bfs就可以解决。</font></p><p><font color="#004a97">最坏情况下，算法的时间复杂度是 $O(nm^2)$</font></p><br><h3 id="如何存图呢">如何存图呢</h3><p>我们发现，算法的实现过程中需要<strong>快速的找到某条边的反向边</strong></p><p>所以在用<strong>链式前向星</strong>加边的时候，我们把正向边和反向边成对连续添加。</p><p>那么第 i 条边的反向边实际就是第 i ^ 1 条边。</p><p>在记录路径时，我们用 pre[] 数组记录当前点的<strong>前驱边</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210220602561.png" alt="image-20221210220602561"></p><p>如上图，假设我们此时找到了点v</p><p>edge1实际就是 pre[i]，反向边edge2就是 pre[i] ^ 1</p><p>而点 u 就是 e[pre[i] ^ 1]。</p><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P3376</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">20010</span>, INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, zz[N][N], d[N], pre[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(st));<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), st[S] = <span class="hljs-literal">true</span>, d[S] = INF;<br>    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (st[j] || !w[i]) <span class="hljs-keyword">continue</span>;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            d[j] = <span class="hljs-built_in">min</span>(d[t], w[i]);<br>            pre[j] = i;<span class="hljs-comment">// 这里记录的实际是前驱边</span><br>            <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">EK</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        ans += d[T];<span class="hljs-comment">// 这里就是我们存图的技巧</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>])<br>            w[pre[i]] -= d[T], w[pre[i] ^ <span class="hljs-number">1</span>] += d[T];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        zz[a][b] += c;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (zz[i][j])   <span class="hljs-built_in">add</span>(i, j, zz[i][j]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">EK</span>());<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="dinic-algorithm">Dinic Algorithm</h2><p>Dinic 算法，它由 Dinitz 在 1970 年提出。</p><p><font color="#004a97">最坏情况下，算法的时间复杂度是 $O(mn^2)$</font></p><p>Ek算法每次在残留网络中找一条增广路，而Dinic算法则是每次找到尽量多的增广路。</p><p>为了防止在找增广路时出现环，我们引入分层图的概念。</p><p>首先了解什么是<strong>Level Graph：</strong></p><p>我们把从起点走x步可以到达的点看作一层，<strong>Level Graph</strong> 就是只保留相邻层之间的边的图，是原图的一个子图，且一点没有环。</p><p>下面左图就是右图（原图）的分层图，使用 bfs 即可做到。</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210113123903.png" alt="image-20221210113123903"></p><p>算法的流程如下：</p><p>1、先构造残留网（边权为空闲量的图）</p><p>2、然后我们进行以下循环：</p><ul><li>构造残留网络的 Leval Graph（bfs）</li><li>在构造的 Leval Graph 中（下面的左图）寻找所有的增广路径</li></ul><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210113843073.png" alt="image-20221210113843073"></p><ul><li>然后我们更新右图，在残留网络中减去 Leval Graph 的流量，再添加反向边</li></ul><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210114211420.png" alt="image-20221210114211420"></p><br><h3 id="当前弧优化">当前弧优化</h3><p>如果某条边在搜索的时候已经满了，那么我们可以跳过这条边，从下一条边开始搜。</p><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P3376</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 判断是否含有增广路</span><br><span class="hljs-comment">// 有则返回true，并且构造分层图</span><br><span class="hljs-comment">// 没有则返回false</span><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T)<span class="hljs-keyword">return</span> limit;<br>    <br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;  <span class="hljs-comment">// 当前弧优化</span><br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow));<br>            <span class="hljs-keyword">if</span> (!t)d[ver] = <span class="hljs-number">-1</span>;<span class="hljs-comment">// 残枝优化</span><br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">dinic</span>());<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="时间复杂度">时间复杂度</h2><p>由于一些奇怪的原因，最大流算法中的时间复杂度上限很宽松</p><p><strong>实际运行速度远比理论上的要好很多。</strong></p><p>所以 EK算法 实际上大致可以解决1000~10000的点</p><p>Dinic算法 则大致可以解决10000~100000的点</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Template-Math</title>
      <link href="/post/ecb77944.html"/>
      <url>/post/ecb77944.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221209135823540.png" alt="image-20221209135823540"></p><p><font size="5" color="#004a97"><strong>数学</strong></font></p><br><h2 id="__int128">__int128</h2><p><strong>从招招那里抄的kuangbin模板。</strong></p><p>范围：$$[-2^{127}, 2^{127}]\space  约10^{38}$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> __int128 <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    __int128 x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>)  f = <span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(__int128 x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        x = -x;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">9</span>)  <span class="hljs-built_in">print</span>(x / <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    __int128 a = <span class="hljs-built_in">read</span>();<br>    __int128 b = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">print</span>(a + b);<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="最大公约数">最大公约数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="最小公倍数">最小公倍数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a / <span class="hljs-built_in">gcd</span>(a, b) * b;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="筛质数">筛质数</h2><h3 id="埃筛">埃筛</h3><p><font color="#004a97">时间复杂度 $O(nloglogn)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> isprime[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>        isprime[i] = <span class="hljs-literal">true</span>;            <span class="hljs-comment">// 先全部置为真</span><br>    isprime[<span class="hljs-number">0</span>] = isprime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 1 0 不是素数</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (isprime[i])<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= n; j += i)<br>                isprime[j] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span> (isprime[i]) &#123;<br>            cnt++;             <span class="hljs-comment">// 素数的个数</span><br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出该素数</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; endl &lt;&lt; cnt;  <span class="hljs-comment">// 输出总个数</span><br></code></pre></td></tr></table></figure><br><h3 id="线性筛">线性筛</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pirme</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>            p[cnt++] = i;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; p[j] &lt;= n / i; j++) &#123;<br>            st[p[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="快速幂">快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)  ans = a * ans % p;<br>        a = a * a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 逆元</span><br><span class="hljs-built_in">test</span>(n, mod - <span class="hljs-number">2</span>, mod)<br></code></pre></td></tr></table></figure><br><h2 id="快速乘">快速乘</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)  ans = (ans + a) % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (a * <span class="hljs-number">2</span>) % mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="欧拉函数">欧拉函数</h2><p><font size="4">1 ~ N 中与 N 互质的数</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i++) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>                x /= i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>)  res = res / x * (x - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-comment">// 筛法欧拉函数</span><br><span class="hljs-comment">// 求 1 - N 中每个数的欧拉函数之和</span><br><span class="hljs-type">int</span> p[N], cnt, e[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function">ll <span class="hljs-title">get_eulars</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    e[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            p[cnt++] = i;<br>            e[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; p[j] &lt;= n / i; j++) &#123;<br>            <span class="hljs-type">int</span> t = p[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) &#123;<br>                e[t] = e[i] * p[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            e[t] = e[i] * (p[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)ans += e[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="组合数">组合数</h2><p>$$C_a^b\ mod\ (1e9+7)$$</p><h3 id="姿势一">姿势一</h3><p>范围：</p><p>$$1≤b≤a≤2000$$</p><p>解法：</p><p>$$C_a^b=C_{a-1}^{b-1}+C_{a-1}^b$$</p><p><font color="#004a97">时间复杂度 $O(n^2)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2022</span>;<br><span class="hljs-type">int</span> n, p = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> C[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)<br>                C[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                C[i][j] = (C[i - <span class="hljs-number">1</span>][j] + C[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % p;<br>        &#125;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        cout &lt;&lt; C[a][b] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="姿势二">姿势二</h3><p>范围：</p><p>$$1≤b≤a≤10^5$$</p><p>解法：</p><p>$$C_a^b=\frac{a!}{b!(a-b)!}$$</p><p><font color="#004a97">时间复杂度 $O(a*log(mod))$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> fact[N], infact[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> mod)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b)&#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)  ans = ans * a % mod;<br>        a = a * a % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)&#123;<br>        fact[i] = fact[i - <span class="hljs-number">1</span>] * i % mod;<br>        infact[i] = infact[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">qmi</span>(i, mod - <span class="hljs-number">2</span>, mod) % mod;<br>    &#125;<br><br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-type">int</span> ans = fact[a] * infact[a - b] % mod * infact[b] % mod;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%intd\n&quot;</span>, ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="姿势三">姿势三</h3><p>范围：</p><p>$$1≤b≤a≤10^{18},\ 1≤p≤10^5$$</p><p>解法：</p><p><strong>卢卡斯定理</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)  res = res * a % p;<br>        a = (<span class="hljs-type">int</span>)a * a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b &gt; a)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = a; i &lt;= b; i++, j--) &#123;<br>        res = (<span class="hljs-type">int</span>)res * j % p;<br>        res = (<span class="hljs-type">int</span>)res * <span class="hljs-built_in">qmi</span>(i, p - <span class="hljs-number">2</span>, p) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a, b, p);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)<span class="hljs-built_in">C</span>(a % p, b % p, p) * <span class="hljs-built_in">lucas</span>(a / p, b / p, p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-type">int</span> a, b, p;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>        cout &lt;&lt; <span class="hljs-built_in">lucas</span>(a, b, p) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>卢卡斯 + 预处理</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, p, a[N], dp[N], sz[N], fact[N], infact[N];<br><br><span class="hljs-function">ll <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    ll res = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)  res = res * a % p;<br>        a = (ll)a * a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> fact[a] * infact[a - b] % p * infact[b] % p;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(ll a, ll b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a, b, p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a % p, b % p, p) * <span class="hljs-built_in">lucas</span>(a / p, b / p, p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; p;<br><br>    fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        fact[i] = fact[i - <span class="hljs-number">1</span>] * i % p;<br>        infact[i] = infact[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">qmi</span>(i, p - <span class="hljs-number">2</span>, p) % p;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        sz[i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">2</span>; i--)<br>        sz[i &gt;&gt; <span class="hljs-number">1</span>] += sz[i];<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = n; i &lt;= <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>; i++)<br>        dp[i] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-type">int</span> a = sz[i] - <span class="hljs-number">1</span>, b = sz[i &lt;&lt; <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">lucas</span>(a, b, p);<br>        dp[i] = num % p * dp[i &lt;&lt; <span class="hljs-number">1</span>] % p * dp[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] % p;<br>    &#125;<br><br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="整除分块">整除分块</h2><p>抄招招的模板<img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221209150128352.png" alt="image-20221209150128352"></p><p>$$\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 下取整</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getdown</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r, len; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>        r = n / (n / l), len = r - l + <span class="hljs-number">1</span>;<br>        ans += len * (n / l);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 上取整</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getup</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r, len; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>        r = n / (n / l), len = r - l + <span class="hljs-number">1</span>;<br>        ans += len * (n / l + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (n % r == <span class="hljs-number">0</span>) ans -= r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="正方形长方形">正方形长方形</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> ta = n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> tb = m * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> all = ta * tb;<br>    <span class="hljs-type">int</span> zh = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">min</span>(n, m); i++) &#123;<br>        zh += (m - i + <span class="hljs-number">1</span>) * (n - i + <span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; zh &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; all - zh &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="博弈论">博弈论</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 巴什博弈</span><br>只有一堆，n个物品，两个人轮流从这堆物品中取物<br>规定每次至少取一个，最多取m个。最后取光者得胜。<br><br>结论：<br>若 n % (m + <span class="hljs-number">1</span>) = <span class="hljs-number">0</span>，则先手必败。<br>否则先手必胜。<br><br><br><br><span class="hljs-comment">// 尼姆博弈</span><br>有n堆各若干个物品，两个人轮流从某一堆取任意多的物品<br>规定每次至少取一个，多者不限，最后取光者得胜。<br><br>结论：<br>若 a1^a2^...^an = <span class="hljs-number">0</span>，则先手必败。<br>否则先手必胜。<br></code></pre></td></tr></table></figure><br><h2 id="矩阵ksm">矩阵ksm</h2><br><h2 id="线性基">线性基</h2><br>]]></content>
      
      
      <categories>
          
          <category> ACM-Template </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Template-Graph</title>
      <link href="/post/70dc2d05.html"/>
      <url>/post/70dc2d05.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221208195445408.png" alt="image-20221208195445408"></p><p><font size="5" color="#004a97"><strong>图论</strong></font></p><br><h2 id="最短路">最短路</h2><h3 id="朴素dijkstra">朴素Dijkstra</h3><p><font color="#004a97">时间复杂度 $O(n^2)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用邻接矩阵储存，适用于稠密图</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n, m;             <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> g[N][N], dis[N];  <span class="hljs-comment">// g表示邻接矩阵，dis表示每个点到起点的距离</span><br><span class="hljs-type">bool</span> used[N];         <span class="hljs-comment">// 记录某个点是否被使用过</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br>    dis[s] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (!used[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dis[t] &gt; dis[j]))   t = j;<br><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">-1</span>)    <span class="hljs-keyword">break</span>;<br><br>        used[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            dis[j] = <span class="hljs-built_in">min</span>(dis[j], dis[t] + g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dis[n] == <span class="hljs-number">0x3f3f3f3f</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> dis[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(g));<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-comment">// 存在重边和自环时，仅需处理最短的边即可</span><br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="堆优化dijkstra">堆优化Dijkstra</h3><p><font color="#004a97">时间复杂度 $O((n+m) logn)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> n, m, dist[N];<br><span class="hljs-type">bool</span> used[N];  <span class="hljs-comment">// 记录某个点是否被使用过</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[s] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br><br>    <span class="hljs-keyword">while</span> (!heap.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (used[ver])  <span class="hljs-keyword">continue</span>;<br>        used[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i]) &#123;<br>                dist[j] = dist[ver] + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] &gt;= <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="bellman-ford">Bellman-ford</h3><p><font color="#004a97">时间复杂度 $O(nm)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">10010</span>;<br><br><span class="hljs-type">int</span> n, m, k, dis[N], last[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123; <span class="hljs-type">int</span> a, b, c; &#125; edges[M];   <span class="hljs-comment">// 结构体存边</span><br><br><span class="hljs-comment">// 从起点s出发到任一点n的最短距离,限制最多经过k条边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br><br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++ ) &#123;<br>        <span class="hljs-built_in">memcpy</span>(last, dis, <span class="hljs-keyword">sizeof</span> dis);<span class="hljs-comment">// 备份数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ ) &#123;<br>            <span class="hljs-keyword">auto</span> e = edges[j];<br>            dis[e.b] = <span class="hljs-built_in">min</span>(dis[e.b], last[e.a] + e.c);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 不加边数限制的最短路</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford2</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;                  <span class="hljs-comment">// for (int k = 1; k &lt;= n - 1; k++)</span><br>        <span class="hljs-type">bool</span> update = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 正常情况下外循环最多进行 n - 1 次即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">auto</span> t = edges[i];<br>            <span class="hljs-keyword">if</span> (dis[t.a] != <span class="hljs-number">0x3f3f3f3f</span> &amp;&amp; dis[t.b] &gt; dis[t.a] + t.c)<br>                dis[t.b] = dis[t.a] + t.c, update = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!update) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// bellman_ford 判断是否存在负环</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_negative_loop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">auto</span> t = edges[j];<br>            <span class="hljs-keyword">if</span> (dis[t.b] &gt; dis[t.a] + t.c) &#123;<br>                dis[t.b] = dis[t.a] + t.c;<br>                <span class="hljs-comment">// 如果第 n 次仍然更新了，则存在负环</span><br>                <span class="hljs-keyword">if</span>(i == n)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="spfa">SPFA</h3><p><font color="#004a97">谜之时间复杂度</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> n, m, dist[N], cnt[N];<br><span class="hljs-type">bool</span> st[N];  <span class="hljs-comment">// 判断当前点是否在队列之中，防止队列中有重复的点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 队列里只存距离变小了的点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[s] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s); st[s] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-comment">// SPFA 判断是否存在负环</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_negative_loop</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(st));<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    dis[s] = <span class="hljs-number">0</span>, st[s] = <span class="hljs-literal">true</span>;<br>    q.<span class="hljs-built_in">push</span>(s);<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>(); st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dis[j] &gt; dis[t] + w[i])&#123;<br>                dis[j] = dis[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (!st[j])&#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="floyd">Floyd</h3><p><font color="#004a97">时间复杂度 $O(n^3)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Floyd算法是基于动态规划的原理</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>, INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n, m, Q;<br><span class="hljs-type">int</span> d[N][N];  <span class="hljs-comment">// d[i][j]表示从点i到点j的最短距离</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span>    d[i][j] = INF;<br>        &#125;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        d[a][b] = <span class="hljs-built_in">min</span>(d[a][b], c);<br>    &#125;<br><br>    <span class="hljs-built_in">floyd</span>();<br><br>    <span class="hljs-keyword">while</span> (Q--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br><br>        <span class="hljs-type">int</span> t = d[a][b];<br>        <span class="hljs-keyword">if</span> (t &gt; INF / <span class="hljs-number">2</span>)    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="传递闭包">传递闭包</h3><p><font color="#004a97">使用Floyd解决，时间复杂度 $O(n^3)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">350</span>;<br><span class="hljs-type">int</span> n, m, d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) d[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> x, y;   cin &gt;&gt; x &gt;&gt; y;<br>        d[x][y] = d[y][x] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                d[i][j] |= d[i][k] &amp; d[k][j];<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="记录路径">记录路径</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以朴素dijkstra为例，记录一个path数组，当dist数组被更新时，就同步更新path数组。</span><br><span class="hljs-type">int</span> g[maxn][maxn];<br><span class="hljs-type">int</span> st[maxn], dist[<span class="hljs-number">500010</span>];<br><span class="hljs-type">int</span> path[<span class="hljs-number">500010</span>];  <span class="hljs-comment">// 记录走来的路径</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">memset</span>(path, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> path);<br><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br>        &#125;<br><br>        st[t] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + g[t][j]) &#123;<br>                dist[j] = dist[t] + g[t][j];<br>                path[j] = t;  <span class="hljs-comment">// 记录</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_path</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; p;<br>    <span class="hljs-keyword">for</span> (; x != <span class="hljs-number">-1</span>; x = path[x])<br>        p.<span class="hljs-built_in">push_back</span>(x);<br>    <span class="hljs-comment">// p中存下的是n到1的顺序，我们逆反一下顺序。</span><br>    <span class="hljs-built_in">reverse</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            g[i][j] = (i == j) ? <span class="hljs-number">0</span> : INF;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">dijkstra</span>() &lt;&lt; endl;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; p = <span class="hljs-built_in">get_path</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : p)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, it);<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="最短路计数">最短路计数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> cnt[maxn];  <span class="hljs-comment">// 长度为i的路径的数量</span><br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;  <span class="hljs-comment">// 以bfs为例</span><br>    <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : G[t]) &#123;<br>        <span class="hljs-keyword">if</span> (dist[it] &gt; dist[t] + <span class="hljs-number">1</span>) &#123;<br>            dist[it] = dist[t] + <span class="hljs-number">1</span>;<br>            cnt[it] = cnt[t];<br>            q.<span class="hljs-built_in">push</span>(it);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dist[it] == dist[t] + <span class="hljs-number">1</span>)<br>            cnt[it] = (cnt[it] + cnt[t]) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="最小生成树">最小生成树</h2><h3 id="kruskal">Kruskal</h3><p><font color="#004a97">时间复杂度 $O(mlogm)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>, M = <span class="hljs-number">500010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m, p[N];<br><br><span class="hljs-comment">// 结构体存边</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123; <span class="hljs-type">int</span> a, b, w; &#125; edges[M]；<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge&amp; a, Edge&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.w &lt; b.w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)  p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m, cmp);<br><br>    <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    p[i] = i;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br><br>        <span class="hljs-keyword">if</span> (a != b) &#123;<br>            p[a] = b;   <span class="hljs-comment">// 合并集合</span><br>            res += w;   <span class="hljs-comment">// 记录总长</span><br>            cnt++;      <span class="hljs-comment">// 记录边数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果加的边小于n-1, 则原图不连通, 无法构造最小生成树</span><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);<br>        edges[i] = &#123;a, b, w&#125;;<br>    &#125;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">kruskal</span>();<br><br>    <span class="hljs-keyword">if</span> (t == INF)   <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="prim">Prim</h3><p><font color="#004a97">时间复杂度 $O(n^2)$   </font></p><p>适用于稠密图，尤其完全图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m, g[N][N], dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))   t = j;<br><br>        <span class="hljs-keyword">if</span> (dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br><br>        res += dist[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">prim</span>();<br>    <span class="hljs-keyword">if</span> (t == INF)   <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="tarjan">Tarjan</h2><p>有向图至少加多少条边可以变成强连通分量：</p><p>$$max(p,q)\quad \quad ——\ p,q 分别是出度为零和入度为零的点$$</p><br><p>无向图至少加多少条边可以变成边双连通分量：</p><p>$$\lfloor\frac{cnt+1}{2}\rfloor\quad \quad——\ cnt 是缩点以后叶子节点的个数$$</p><br><h3 id="有向图的强连通分量">有向图的强连通分量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>, M = <span class="hljs-number">50010</span>;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> dfn[N], low[N], timetmp;<br><span class="hljs-type">int</span> id[N], scc_cnt, sz[N];<br><span class="hljs-type">int</span> n, m, dout[N];<br><span class="hljs-type">bool</span> st[N];<br>stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    dfn[u] = low[u] = ++timetmp;<br>    stk.<span class="hljs-built_in">push</span>(u), st[u] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dfn[j]) &#123;<br>            <span class="hljs-built_in">tarjan</span>(j);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st[j]) low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[j]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dfn[u] == low[u]) &#123;<br>        ++scc_cnt;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">do</span> &#123;<br>            tmp = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>(), st[tmp] = <span class="hljs-literal">false</span>;<br>            id [tmp] = scc_cnt;<br>            sz[scc_cnt]++;<br>        &#125; <span class="hljs-keyword">while</span>(tmp != u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (!dfn[i])    <span class="hljs-built_in">tarjan</span>(i);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = h[i]; ~j; j = ne[j]) &#123;<br>            <span class="hljs-type">int</span> k = e[j];<br>            <span class="hljs-type">int</span> a = id[i], b = id[k];<br>            <span class="hljs-keyword">if</span> (a != b) dout[a]++;<br>        &#125;<br>    <span class="hljs-type">int</span> zeros = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= scc_cnt; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!dout[i])   zeros++, ans = sz[i];<br>        <span class="hljs-keyword">if</span> (zeros &gt; <span class="hljs-number">1</span>)  ans = <span class="hljs-number">0</span>, i = scc_cnt;<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="无向图的边双连通分量">无向图的边双连通分量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, dfn[N], low[N];<br><span class="hljs-type">int</span> dcc_cnt, timetmp;<br>stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>vector&lt;<span class="hljs-type">int</span>&gt; zz[M];<br><span class="hljs-type">bool</span> is[M];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fr)</span> </span>&#123;<br>    dfn[u] = low[u] = ++timetmp;<br>    stk.<span class="hljs-built_in">push</span>(u);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dfn[j]) &#123;<br>            <span class="hljs-built_in">tarjan</span>(j, i);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>            <span class="hljs-keyword">if</span> (low[j] &gt; dfn[u])    is[i] = is[i ^ <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != (fr ^ <span class="hljs-number">1</span>))     low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[j]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dfn[u] == low[u]) &#123;<br>        ++dcc_cnt;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">do</span> &#123;<br>            tmp = stk.<span class="hljs-built_in">top</span>();    stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// id[tmp] = dcc_cnt;</span><br>            zz[dcc_cnt].<span class="hljs-built_in">pb</span>(tmp);<br>        &#125; <span class="hljs-keyword">while</span> (tmp != u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (!dfn[i])    <span class="hljs-built_in">tarjan</span>(i, i);<br>    <br>    cout &lt;&lt; dcc_cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= dcc_cnt; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, zz[i].<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : zz[i])    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, x);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="无向图的点双连通分量">无向图的点双连通分量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">4</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, root, dcc_cnt;<br><span class="hljs-type">int</span> dfn[N], low[N], timetmp;<br><span class="hljs-type">bool</span> cut[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; zz[N];<br>stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    dfn[u] = low[u] = ++timetmp;<br>    stk.<span class="hljs-built_in">push</span>(u);<br><br>    <span class="hljs-keyword">if</span> (u == root &amp;&amp; h[u] == <span class="hljs-number">-1</span>) &#123;<br>        zz[++dcc_cnt].<span class="hljs-built_in">pb</span>(u);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dfn[j]) &#123;<br>            <span class="hljs-built_in">tarjan</span>(j);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>            <span class="hljs-keyword">if</span> (dfn[u] &lt;= low[j]) &#123;<br>                cnt++;<br>                <span class="hljs-keyword">if</span> (u != root || cnt &gt; <span class="hljs-number">1</span>)   cut[u] = <span class="hljs-literal">true</span>;<br>                ++dcc_cnt;<br>                <span class="hljs-type">int</span> tmp;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    tmp = stk.<span class="hljs-built_in">top</span>();    stk.<span class="hljs-built_in">pop</span>();<br>                    zz[dcc_cnt].<span class="hljs-built_in">pb</span>(tmp);<br>                &#125; <span class="hljs-keyword">while</span> (tmp != j);<br>                zz[dcc_cnt].<span class="hljs-built_in">pb</span>(u);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 判自环</span><br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (root = <span class="hljs-number">1</span>; root &lt;= n; root++)<br>        <span class="hljs-keyword">if</span> (!dfn[root]) <span class="hljs-built_in">tarjan</span>(root);<br>    <br>    cout &lt;&lt; dcc_cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= dcc_cnt; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, zz[i].<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : zz[i])    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, x);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="lca">LCA</h2><h3 id="倍增lca">倍增LCA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxd = <span class="hljs-number">20</span>;    <span class="hljs-comment">// 估计一下就行</span><br><span class="hljs-type">int</span> ne[M], e[M], h[N], idx;<br><span class="hljs-type">int</span> n, m, p, a, b;<br><span class="hljs-type">int</span> dep[N], fa[N][maxd + <span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    dep[u] = dep[p] + <span class="hljs-number">1</span>;<br>    fa[u][<span class="hljs-number">0</span>] = p;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= n; i++)<br>        fa[u][i] = fa[fa[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dep[j])    <span class="hljs-built_in">dfs</span>(j, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dep[x] &lt; dep[y])    <span class="hljs-built_in">swap</span>(x, y);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxd; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (dep[fa[x][i]] &gt;= dep[y])<br>            x = fa[x][i];<br><br>    <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> x;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxd; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i])<br>            x = fa[x][i], y = fa[y][i];<br><br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(p, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">lca</span>(a, b));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="欧拉序lca">欧拉序LCA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> n, m, p;<br><span class="hljs-type">int</span> e[M], ne[M], h[M], w[M], idx;<br><span class="hljs-type">int</span> lo2[N];       <span class="hljs-comment">// 预处理log2[x]</span><br><span class="hljs-type">int</span> dfn[N], cnt;  <span class="hljs-comment">// 欧拉序</span><br><span class="hljs-type">int</span> f[N][<span class="hljs-number">50</span>];     <span class="hljs-comment">// RMQ中的数组</span><br><span class="hljs-type">int</span> first[N];     <span class="hljs-comment">// 第一次出现的位置</span><br><span class="hljs-type">int</span> dep[N];       <span class="hljs-comment">// 深度</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>    first[u] = ++cnt, dfn[cnt] = u;<br>    dep[cnt] = d;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == fa)    <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-built_in">dfs</span>(j, u, d + <span class="hljs-number">1</span>);<br>        dfn[++cnt] = u;  <span class="hljs-comment">// 回溯时也要加到序列里</span><br>        dep[cnt] = d;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)  <span class="hljs-comment">// 预处理log2</span><br>        lo2[i] = lo2[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++)  f[i][<span class="hljs-number">0</span>] = i;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lo2[cnt]; j++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= cnt; i++) &#123;<br>            <span class="hljs-type">int</span> a = f[i][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> b = f[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">if</span> (dep[a] &lt;= dep[b])   f[i][j] = b;<br>            <span class="hljs-keyword">else</span>    f[i][j] = b;<br>        &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(p, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 欧拉序</span><br>    <span class="hljs-built_in">init</span>();        <span class="hljs-comment">//  RMQ</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        l = first[l], r = first[r];<br>        <span class="hljs-keyword">if</span> (l &gt; r)  <span class="hljs-built_in">swap</span>(l, r);<br><br>        <span class="hljs-type">int</span> p = lo2[r - l + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a = f[l][p], b = f[r - (l &lt;&lt; p) + <span class="hljs-number">1</span>][p];<br>        <br>        <span class="hljs-keyword">if</span> (dep[a] &lt;= dep[b])   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dfn[a]);<br>        <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dfn[b]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="欧拉路径和欧拉回路">欧拉路径和欧拉回路</h2><p><strong>欧拉路径：</strong> 从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边通过且只通过一次。</p><p><strong>欧拉回路：</strong> 起点和终点相同的欧拉路</p><h3 id="对于无向图">对于无向图</h3><p>（所有的边必须都连通）</p><ul><li><p><strong>欧拉路径</strong>：度数为奇数的点只有0或2个</p></li><li><p><strong>欧拉回路</strong>：所有的点度数都为偶数</p></li></ul><br><h3 id="对于有向图">对于有向图</h3><p>（所有的边必须都连通）</p><ul><li><p><strong>欧拉路径</strong>：</p><ol><li>所有的点入度 = 出度</li><li><ul><li>有一个点出度 = 入度 + 1（起点）</li><li>有一个点入度 = 出度 + 1（终点</li><li>其它所有的点入度 = 出度</li></ul></li></ol></li><li><p><strong>欧拉回路</strong>：所有的点出度 = 入度</p></li></ul><br><h2 id="二分图">二分图</h2><h3 id="染色法判断二分图">染色法判断二分图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">200010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;  <span class="hljs-comment">// 邻接表存图</span><br><span class="hljs-type">int</span> color[N];                <span class="hljs-comment">// 1 和 2 两个颜色 </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 如果在染色过程中发生矛盾，则不是二分图</span><br><span class="hljs-comment">// 如果完美染色，则是二分图</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    color[u] = c;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!color[j]) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, <span class="hljs-number">3</span> - c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);  <span class="hljs-comment">// 双边</span><br>    &#125;<br><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 因为并不知道图是否连通，要对每个节点遍历一边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (!color[i]) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>)) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">if</span> (flag)   <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="匈牙利算法">匈牙利算法</h3><p>最小点覆盖 = 最大匹配</p><p>最大独立集 = n - 最大匹配</p><p>最小路径点覆盖 = n - 最大匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n1, n2, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> match[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j])) &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i))    res++;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="拓扑排序">拓扑排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> e[N], ne[N], h[N], idx;<br><span class="hljs-type">int</span> n, m, d[N], top[N], cnt;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (!d[i])  q.<span class="hljs-built_in">push</span>(i);<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();  q.<span class="hljs-built_in">pop</span>();<br>        top[cnt++] = t;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (--d[j] == <span class="hljs-number">0</span>)    q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);<br>        d[b]++;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <span class="hljs-type">bool</span> f = <span class="hljs-built_in">topsort</span>();<br><br>    <span class="hljs-keyword">if</span> (!f) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cout &lt;&lt; top[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="差分约束">差分约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs none">A = B     &lt;=&gt; A ≥ B B ≥ A   add(b, a, 0), add(a, b, 0);<br>A &lt; B     &lt;=&gt; B ≥ A + 1     add(a, b, 1);<br>A ≥ B     &lt;=&gt; A ≥ B         add(b, a, 0);<br>A &gt; B     &lt;=&gt; A ≥ B + 1     add(b, a, 1);<br>B ≥ A     &lt;=&gt; B ≥ A         add(a, b, 0);<br></code></pre></td></tr></table></figure><p>$x &gt;= 1$ 时，建立虚拟源点$x_0$  $(dist[x_0] = 0)$</p><p>即$x &gt;= x_0 + 1$   $add(x_0, x, 1);$</p><br><h2 id="网络流">网络流</h2><h3 id="最大流">最大流</h3><h4 id="edmonds-karp">Edmonds-Karp</h4><p><font color="#004a97">最坏情况下，算法的时间复杂度是 $O(nm^2)$</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">20010</span>, INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, zz[N][N], d[N], pre[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(st));<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), st[S] = <span class="hljs-literal">true</span>, d[S] = INF;<br>    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (st[j] || !w[i]) <span class="hljs-keyword">continue</span>;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            d[j] = <span class="hljs-built_in">min</span>(d[t], w[i]);<br>            pre[j] = i;<span class="hljs-comment">// 这里记录的实际是前驱边</span><br>            <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">EK</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        ans += d[T];<span class="hljs-comment">// 这里就是我们存图的技巧</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>])<br>            w[pre[i]] -= d[T], w[pre[i] ^ <span class="hljs-number">1</span>] += d[T];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        zz[a][b] += c;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (zz[i][j])   <span class="hljs-built_in">add</span>(i, j, zz[i][j]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">EK</span>());<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="dinic">Dinic</h4><p><font color="#004a97">最坏情况下，算法的时间复杂度是 $O(mn^2)$</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T)<span class="hljs-keyword">return</span> limit;<br>    <br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;  <span class="hljs-comment">// 当前弧优化</span><br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow));<br>            <span class="hljs-keyword">if</span> (!t)d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">dinic</span>());<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> ACM-Template </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Template-Data_structure</title>
      <link href="/post/24e496bb.html"/>
      <url>/post/24e496bb.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221208191918315.png" alt="image-20221208191918315"></p><p><font size="5" color="#004a97"><strong>数据结构</strong></font></p><br><h2 id="并查集">并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归回溯的过程中实现了路径压缩优化</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)  p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="单调栈">单调栈</h2><p><font color="#004a97">时间复杂度 $O(n)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">check</span>(s.<span class="hljs-built_in">top</span>(), i))s.<span class="hljs-built_in">pop</span>();<br>    s.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="单调队列">单调队列</h2><p><font color="#004a97">时间复杂度 $O(n)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br>deque&lt;<span class="hljs-type">int</span>&gt; q;  <span class="hljs-comment">// q存放编号</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br><br>    q.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-comment">// 单调递增 求最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] &gt;= a[i])   q.<span class="hljs-built_in">pop_back</span>();<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - k &gt;= q.<span class="hljs-built_in">front</span>())    q.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">if</span> (i &gt;= k) cout &lt;&lt; a[q.<span class="hljs-built_in">front</span>()] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <br>    q.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] &lt;= a[i])   q.<span class="hljs-built_in">pop_back</span>();<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - k &gt;= q.<span class="hljs-built_in">front</span>())    q.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">if</span> (i &gt;= k) cout &lt;&lt; a[q.<span class="hljs-built_in">front</span>()] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 二维单调队列</span><br><span class="hljs-type">int</span> n, m, a, b, res;<br><span class="hljs-type">int</span> g[N * N], mp[N][N], ans[N][N];<br>deque&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-type">int</span> x, y, z;<br>    cin &gt;&gt; g[<span class="hljs-number">0</span>] &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N * N; i++) <br>        g[i] = (g[i - <span class="hljs-number">1</span>] * x + y) % z;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            mp[i][j] = g[(i - <span class="hljs-number">1</span>) * m + j - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">// 先处理行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        q.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; j - b &gt;= q.<span class="hljs-built_in">front</span>()) <br>                q.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; mp[i][q.<span class="hljs-built_in">back</span>()] &gt;= mp[i][j]) <br>                q.<span class="hljs-built_in">pop_back</span>();<br>            q.<span class="hljs-built_in">push_back</span>(j);<br>            ans[i][j] = mp[i][q.<span class="hljs-built_in">front</span>()];<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-comment">// 再处理列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>        q.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - a &gt;= q.<span class="hljs-built_in">front</span>()) <br>                q.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; ans[q.<span class="hljs-built_in">back</span>()][j] &gt;= ans[i][j]) <br>                q.<span class="hljs-built_in">pop_back</span>();<br>            q.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span> (i &gt;= a &amp;&amp; j &gt;= b)   res += ans[q.<span class="hljs-built_in">front</span>()][j];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="树状数组">树状数组</h2><h3 id="单点修改区间查询">单点修改，区间查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i))  ans += tr[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i))<br>        tr[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-comment">// 区间查询 (l ~ r)</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="区间修改单点查询">区间修改，单点查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 可以用树状数组维护 原数组的差分数组</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, a[N], c[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i))  ans += c[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) c[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-comment">//树状数组维护差分数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">add</span>(i, a[i] - a[i - <span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> l, r, d;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>, op, &amp;l);<br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;C&#x27;</span>) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;r, &amp;d);<br>            <span class="hljs-built_in">add</span>(l, d), <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -d);<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%intd\n&quot;</span>, <span class="hljs-built_in">sum</span>(l));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="区间修改区间查询">区间修改，区间查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 构造两个树状数组 tr1  tr2</span><br><span class="hljs-comment">// a. tr1 维护原数组的差分数组</span><br><span class="hljs-comment">// b. tr2 维护原数组 下标乘差分</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, a[N];<br><span class="hljs-type">int</span> tr1[N], tr2[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> tr[], <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> tr[], <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i))  ans += tr[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">presum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(tr1, x) * (x + <span class="hljs-number">1</span>) - <span class="hljs-built_in">sum</span>(tr2, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> t = a[i] - a[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">add</span>(tr1, i, t);<br>        <span class="hljs-built_in">add</span>(tr2, i, (<span class="hljs-type">int</span>)i * t);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> l, r, d;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);<br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%intd\n&quot;</span>, <span class="hljs-built_in">presum</span>(r) - <span class="hljs-built_in">presum</span>(l - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;d);<br>            <span class="hljs-built_in">add</span>(tr1, l, d), <span class="hljs-built_in">add</span>(tr1, r + <span class="hljs-number">1</span>, -d);<br>            <span class="hljs-built_in">add</span>(tr2, l, l * d), <span class="hljs-built_in">add</span>(tr2, r + <span class="hljs-number">1</span>, (r + <span class="hljs-number">1</span>) * -d);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="线段树">线段树</h2><h3 id="单点修改">单点修改</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, p, last;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> dat, l, r;<br>&#125; tr[N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    tr[x].dat = <span class="hljs-built_in">max</span>(tr[x &lt;&lt; <span class="hljs-number">1</span>].dat, tr[x &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].dat);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tr[p].l = l, tr[p].r = r;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[p].dat;<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">-0x3f3f3f3f</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r));<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l == x &amp;&amp; tr[p].r == x) &#123;<br>        tr[p].dat = v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="区间修改">区间修改</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, w[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">int</span> add;<br>&#125; tr[N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    tr[p].sum = tr[p &lt;&lt; <span class="hljs-number">1</span>].sum + tr[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node &amp;c, node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c.add) &#123;<br>        a.add += c.add;<br>        a.sum += (a.r - a.l + <span class="hljs-number">1</span>) * c.add;<br>        b.add += c.add;<br>        b.sum += (b.r - b.l + <span class="hljs-number">1</span>) * c.add;<br>        c.add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-built_in">pushdown</span>(tr[p], tr[p &lt;&lt; <span class="hljs-number">1</span>], tr[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tr[p].l = l, tr[p].r = r;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        tr[p] = &#123;l, r, w[l], <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r) &#123;<br>        tr[p].sum += (tr[p].r - tr[p].l + <span class="hljs-number">1</span>) * v;<br>        tr[p].add += v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, v);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, v);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[p].sum;<br>    <br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="权值线段树">权值线段树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">110</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-comment">// int e[M], ne[M], h[M], w[M], idx;</span><br><span class="hljs-type">int</span> n, m, op[N], a[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, sum;<br>&#125; tr[N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">getid</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">all</span>(v), x) - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tr[p] = &#123;l, r, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(lson, l, mid);<br>    <span class="hljs-built_in">build</span>(rson, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l == tr[p].r) &#123;<br>        tr[p].sum += v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid)    <span class="hljs-built_in">modify</span>(lson, x, v);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">modify</span>(rson, x, v);<br><br>    tr[p].sum = tr[lson].sum + tr[rson].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt; r)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= tr[p].l &amp;&amp; r &gt;= tr[p].r)   <span class="hljs-keyword">return</span> tr[p].sum;<br><br>    <span class="hljs-type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (r &lt;= mid)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(lson, l, r);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l &gt; mid)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rson, l, r);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(lson, l, mid) + <span class="hljs-built_in">query</span>(rson, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-comment">// 查找第k小</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l == tr[p].r) <span class="hljs-keyword">return</span> tr[p].l;<br><br>    <span class="hljs-type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (tr[lson].sum &gt;= k)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(lson, k);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(rson, k - tr[lson].sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;op[i], &amp;a[i]);<br>        <span class="hljs-keyword">if</span> (op[i] != <span class="hljs-number">4</span>) v.<span class="hljs-built_in">pb</span>(a[i]);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(v));<br>    v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(<span class="hljs-built_in">all</span>(v)), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> tot = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">1</span>)         <span class="hljs-comment">// 插入</span><br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">getid</span>(a[i]), <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">2</span>)    <span class="hljs-comment">// 删除 </span><br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">getid</span>(a[i]), <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">3</span>) &#123;  <span class="hljs-comment">// x的排名</span><br>            <span class="hljs-type">int</span> ans = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">getid</span>(a[i]) - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">4</span>) &#123;  <span class="hljs-comment">// 排名为x的数</span><br>            <span class="hljs-type">int</span> idx = <span class="hljs-built_in">kth</span>(<span class="hljs-number">1</span>, a[i]) - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v[idx]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">5</span>) &#123;  <span class="hljs-comment">// 前驱</span><br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">getid</span>(a[i]) - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v[<span class="hljs-built_in">kth</span>(<span class="hljs-number">1</span>, t) - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;                  <span class="hljs-comment">// 后继</span><br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">getid</span>(a[i]));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v[<span class="hljs-built_in">kth</span>(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; tt;</span><br>    <span class="hljs-comment">// init();</span><br>    <span class="hljs-keyword">while</span> (tt--)<br>        <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">一、查询第K小的数：</span><br><span class="hljs-comment">这个可以利用权值线段树存储的是数出现的次数</span><br><span class="hljs-comment">维护区间内数字出现的次数</span><br><span class="hljs-comment">查询左右子树数字出现的次数</span><br><span class="hljs-comment">    如果左儿子数字出现次数和是小于K，代表这个第K小在右子树</span><br><span class="hljs-comment">    但是它在右子树的排名是K减去左子树儿子的个数</span><br><span class="hljs-comment">这样不断往下进行查找，当查找到单点的时候，就是第K小。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">二、查询x数的排名：</span><br><span class="hljs-comment">可以利用权值线段树存储的数字个数的信息</span><br><span class="hljs-comment">查询[1,x-1]区间内部数字出现的个数+1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">三、求x的前驱：</span><br><span class="hljs-comment">我们可以求在[1,x-1]区间内部数字出现的次数记为k</span><br><span class="hljs-comment">那么第k大其实就是前面最靠近x的数，也就是前驱</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">四、求x的后继:</span><br><span class="hljs-comment">我们可以求在[1,x]区间内部数字出现的的次数为k</span><br><span class="hljs-comment">那么第k+1大其实就是后面最靠近x的数，也就是后继。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><h2 id="主席树">主席树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, a[N],cnt, root[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, sum;<br>&#125; tr[N * <span class="hljs-number">40</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getid</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">all</span>(v), x) - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pre, <span class="hljs-type">int</span> &amp;now, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    tr[++cnt] = tr[pre];<br>    now = cnt;<br>    tr[now].sum++;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (pos &lt;= mid)  <span class="hljs-built_in">insert</span>(l, mid, tr[pre].l, tr[now].l, pos);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">insert</span>(mid + <span class="hljs-number">1</span>, r, tr[pre].r, tr[now].r, pos);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> st, <span class="hljs-type">int</span> ed, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmp = tr[tr[ed].l].sum - tr[tr[st].l].sum;<br>    <span class="hljs-keyword">if</span> (k &lt;= tmp)   <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, mid, tr[st].l, tr[ed].l, k);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, r, tr[st].r, tr[ed].r, k - tmp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>        v.<span class="hljs-built_in">pb</span>(a[i]);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(v));<br>    v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(<span class="hljs-built_in">all</span>(v)), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, n, root[i - <span class="hljs-number">1</span>], root[i], <span class="hljs-built_in">getid</span>(a[i]));<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> x, y, k;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;k);<br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, n, root[x - <span class="hljs-number">1</span>], root[y], k);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v[idx - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="st表">ST表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, x, f[N][<span class="hljs-number">100</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        f[i][<span class="hljs-number">0</span>] = x;<br>    &#125; <br><br>    <span class="hljs-type">int</span> tmp = (<span class="hljs-type">int</span>)(<span class="hljs-built_in">log</span>(n) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= tmp; j++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++)<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        <span class="hljs-type">int</span> p = (<span class="hljs-type">int</span>)(<span class="hljs-built_in">log</span>(r - l + <span class="hljs-number">1</span>) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-built_in">max</span>(f[l][p], f[r - (<span class="hljs-number">1</span> &lt;&lt; p) + <span class="hljs-number">1</span>][p]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="树剖">树剖</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[M], idx;<br><span class="hljs-type">int</span> n, m, rt, mod, v[M];<br><span class="hljs-comment">//父节点， 深度， 大小， 重儿子</span><br><span class="hljs-type">int</span> fa[N], dep[N], sz[N], son[N];<br><span class="hljs-comment">// 时间戳计数， 时间戳， 重链头， 权值</span><br><span class="hljs-type">int</span> tim, dfn[N], top[N], w[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">int</span> add;<br>&#125; tr[N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    tr[p].sum = (tr[p &lt;&lt; <span class="hljs-number">1</span>].sum + tr[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum) % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node &amp;c, node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c.add) &#123;<br>        a.add += c.add;<br>        a.sum += (a.r - a.l + <span class="hljs-number">1</span>) * c.add % mod;<br>        b.add += c.add;<br>        b.sum += (b.r - b.l + <span class="hljs-number">1</span>) * c.add % mod;<br>        c.add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-built_in">pushdown</span>(tr[p], tr[p &lt;&lt; <span class="hljs-number">1</span>], tr[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tr[p].l = l, tr[p].r = r;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        tr[p] = &#123;l, r, w[l] % mod, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r) &#123;<br>        tr[p].add += v;<br>        tr[p].sum += (tr[p].r - tr[p].l + <span class="hljs-number">1</span>) * v ;<br>        tr[p].sum %= mod;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, v);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, v);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[p].sum % mod;<br>    <br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> sum % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> pa)</span> </span>&#123;<br>    fa[u] = pa, dep[u] = dep[pa] + <span class="hljs-number">1</span>;<br>    sz[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mxsz = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == pa)    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(j, u);<br>        sz[u] += sz[j];<br>        <span class="hljs-keyword">if</span> (sz[j] &gt; mxsz)   mxsz = sz[j], son[u] = j;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>    dfn[u] = ++tim, top[u] = t;<br>    w[tim] = v[u];<br>    <span class="hljs-keyword">if</span> (!son[u])    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有重儿子</span><br>    <span class="hljs-built_in">dfs2</span>(son[u], t);        <span class="hljs-comment">// 头结点不变</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == fa[u] || j == son[u])  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(j, j);         <span class="hljs-comment">// 再从轻儿子开始</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将x到y最短路径上的结点加z</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify_chain</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;<br>    z %= mod;<br>    <span class="hljs-keyword">while</span> (top[x] != top[y]) &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[x]] &lt; dep[top[y]])  <span class="hljs-built_in">swap</span>(x, y);<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, dfn[top[x]], dfn[x], z);<br>        x = fa[top[x]];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[x] &gt; dep[y])    <span class="hljs-built_in">swap</span>(x, y);<br>    <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, dfn[x], dfn[y], z);<br>&#125;<br><br><span class="hljs-comment">// 求x到y最短路径上的结点之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_chain</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (top[x] != top[y]) &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[x]] &lt; dep[top[y]])  <span class="hljs-built_in">swap</span>(x, y);<br>        res += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, dfn[top[x]], dfn[x]);<br>        x = fa[top[x]];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[x] &gt; dep[y])    <span class="hljs-built_in">swap</span>(x, y);<br>    res += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, dfn[x], dfn[y]);<br><br>    <span class="hljs-keyword">return</span> res % mod;<br>&#125;<br><br><span class="hljs-comment">// 以x为根节点的子树结点都加上z</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify_son</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> z)</span> </span>&#123;<br>    <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>, z);<br>&#125;<br><br><span class="hljs-comment">// 求以x为根节点的子树节点数值之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_son</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;rt, &amp;mod);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    cin &gt;&gt; v[i];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> ta, tb;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ta, &amp;tb);<br>        <span class="hljs-built_in">add</span>(ta, tb), <span class="hljs-built_in">add</span>(tb, ta);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs1</span>(rt, rt);<br>    <span class="hljs-built_in">dfs2</span>(rt, rt);<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> op;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;op);<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> x, y, z;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);<br>            <span class="hljs-built_in">modify_chain</span>(x, y, z);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-type">int</span> x, y;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">query_chain</span>(x, y)); <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-type">int</span> x, z;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;z);<br>            <span class="hljs-built_in">modify_son</span>(x, z);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> x;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">query_son</span>(x));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="莫队">莫队</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e4</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, k, a[N], pos[N], cnt[N];<br><span class="hljs-type">int</span> res, ans[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, id;<br>&#125; q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos[a.l] == pos[b.l])   <span class="hljs-keyword">return</span> a.r &lt; b.r;<br>    <span class="hljs-keyword">return</span> pos[a.l] &lt; pos[b.l];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    cnt[a[x]]++;<br>    res += cnt[a[x]] * cnt[a[x]] - (cnt[a[x]] - <span class="hljs-number">1</span>) * (cnt[a[x]] - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Sub</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    cnt[a[x]]--;<br>    res -= (cnt[a[x]] + <span class="hljs-number">1</span>) * (cnt[a[x]] + <span class="hljs-number">1</span>) - cnt[a[x]] * cnt[a[x]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-type">int</span> ksz = <span class="hljs-built_in">sqrt</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>        pos[i] = i / ksz;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;q[i].l, &amp;q[i].r);<br>        q[i].id = i;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(q + <span class="hljs-number">1</span>, q + <span class="hljs-number">1</span> + m, cmp);<br><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">while</span> (q[i].l &lt; l)  <span class="hljs-built_in">Add</span>(--l);<br>        <span class="hljs-keyword">while</span> (q[i].r &gt; r)  <span class="hljs-built_in">Add</span>(++r);<br><br>        <span class="hljs-keyword">while</span> (q[i].l &gt; l)  <span class="hljs-built_in">Sub</span>(l++);<br>        <span class="hljs-keyword">while</span> (q[i].r &lt; r)  <span class="hljs-built_in">Sub</span>(r--);<br><br>        ans[q[i].id] = res;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        cout &lt;&lt; ans[i] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="点分治">点分治</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[M], w[M], idx;<br><span class="hljs-type">int</span> n, m, rt, sum, cnt;<br><span class="hljs-type">int</span> tmp[N], sz[N], mxsz[N], q[<span class="hljs-number">200</span>], dis[N];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MX = <span class="hljs-number">1e7</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">bool</span> judge[MX], ans[<span class="hljs-number">200</span>], st[N]; <br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 找树的重心</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    sz[u] = <span class="hljs-number">1</span>, mxsz[u] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (st[j] || j == fa)   <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(j, u);<br>        sz[u] += sz[j];<br>        mxsz[u] = <span class="hljs-built_in">max</span>(mxsz[u], sz[j]);<br>    &#125;<br>    mxsz[u] = <span class="hljs-built_in">max</span>(mxsz[u], sum - sz[u]);<br>    <span class="hljs-keyword">if</span> (mxsz[u] &lt; mxsz[rt]) rt = u;<br><br>&#125;<br><br><span class="hljs-comment">// 处理每个点到根节点的距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dis[u] &lt;= MX)   tmp[cnt++] = dis[u];<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == fa || st[j])   <span class="hljs-keyword">continue</span>;<br>        dis[j] = dis[u] + w[i];<br>        <span class="hljs-built_in">dfs2</span>(j, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (st[j])  <span class="hljs-keyword">continue</span>;<br>        cnt = <span class="hljs-number">0</span>, dis[j] = w[i];<br>        <span class="hljs-built_in">dfs2</span>(j, u);<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; cnt; x++)    <span class="hljs-comment">// 遍历距离</span><br>            <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; m; y++)  <span class="hljs-comment">// 遍历询问</span><br>                <span class="hljs-keyword">if</span> (q[y] &gt;= tmp[x]) <br>                    ans[y] |= judge[q[y] - tmp[x]];<br>        <br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; cnt; k++) &#123;<br>            que.<span class="hljs-built_in">push</span>(tmp[k]);<br>            judge[tmp[k]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 优化清空</span><br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        judge[que.<span class="hljs-built_in">front</span>()] = <span class="hljs-literal">false</span>;<br>        que.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 分治</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    st[u] = judge[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">test</span>(u);<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (st[j])  <span class="hljs-keyword">continue</span>;<br>        rt = <span class="hljs-number">0</span>, mxsz[rt] = sum = sz[j];<br>        <span class="hljs-built_in">dfs1</span>(j, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs1</span>(rt, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">divide</span>(rt);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-type">int</span> a, b, c;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;q[i]);<br>    mxsz[<span class="hljs-number">0</span>] = sum = n;<br>    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 找根</span><br>    <span class="hljs-built_in">dfs1</span>(rt, <span class="hljs-number">0</span>);    <span class="hljs-comment">// 确定根以后 更新size</span><br>    <span class="hljs-built_in">divide</span>(rt);<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (ans[i]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;AYE&quot;</span>);<br>        <span class="hljs-keyword">else</span>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NAY&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="二维数点">二维数点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, cnt, c[<span class="hljs-number">10000010</span>], ans[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> x, y, id, op;<br>&#125; qs[N &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.x &lt; b.x;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>&#125; zz[N];<br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(point a, point b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.x &lt; b.x;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i))  ans += c[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) c[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> x, y;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);<br>        zz[i] = &#123;x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> x1, y1, x2, y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br>        x1++, y1++, x2++, y2++;<br>        qs[++cnt] = &#123;x2, y2, i, <span class="hljs-number">1</span>&#125;;<br>        qs[++cnt] = &#123;x1 - <span class="hljs-number">1</span>, y2, i, <span class="hljs-number">-1</span>&#125;;<br>        qs[++cnt] = &#123;x2, y1 - <span class="hljs-number">1</span>, i, <span class="hljs-number">-1</span>&#125;;<br>        qs[++cnt] = &#123;x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(zz + <span class="hljs-number">1</span>, zz + n + <span class="hljs-number">1</span>, cmp2);<br>    <span class="hljs-built_in">sort</span>(qs + <span class="hljs-number">1</span>, qs + cnt + <span class="hljs-number">1</span>, cmp1);<br><br>    <span class="hljs-type">int</span> now = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<br>        <span class="hljs-keyword">while</span> (now &lt;= n &amp;&amp; zz[now].x &lt;= qs[i].x) &#123;<br>            <span class="hljs-built_in">add</span>(zz[now].y, <span class="hljs-number">1</span>);<br>            now++;<br>        &#125;<br>        ans[qs[i].id] += qs[i].op * <span class="hljs-built_in">sum</span>(qs[i].y);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans[i]);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> ACM-Template </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Template-String</title>
      <link href="/post/61c841f1.html"/>
      <url>/post/61c841f1.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221208200822351.png" alt="image-20221208200822351"></p><p><font size="5" color="#004a97"><strong>字符串</strong></font></p><br><h2 id="kmp">KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, nx[N];<br>string s, t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; s &gt;&gt; t;<br>    n = s.<span class="hljs-built_in">size</span>(), m = t.<span class="hljs-built_in">size</span>();<br>    s = <span class="hljs-string">&quot; &quot;</span> + s, t = <span class="hljs-string">&quot; &quot;</span> + t;<br><br>    nx[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br>        nx[i] = nx[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (nx[i] &amp;&amp; t[i] != t[nx[i] + <span class="hljs-number">1</span>])   <br>            nx[i] = nx[nx[i]];<br>        nx[i] += (t[i] == t[nx[i] + <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &lt;= n;) &#123;<br>        <span class="hljs-keyword">while</span> (j != <span class="hljs-number">1</span> &amp;&amp; s[i] != t[j])<br>            j = nx[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == t[j])   i++, j++;<br>        <span class="hljs-keyword">else</span>    i++;<br>        <br>        <span class="hljs-keyword">if</span> (j == m + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, i - m);<br>            j = nx[m] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, nx[i]);<br>    <br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KMP</span> &#123;<br>    <span class="hljs-type">int</span> nxt[maxn];<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">char</span> t[maxn];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; len = nxt[<span class="hljs-number">0</span>] = nxt[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-comment">/* 1-bas */</span><br>    <span class="hljs-comment">/* 注意在ss结尾添加‘\0’ */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">char</span>* ss)</span> </span>&#123;<br>        len = <span class="hljs-built_in">strlen</span>(ss + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">memcpy</span>(t, ss, (len + <span class="hljs-number">2</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= len; i++) &#123;<br>            nxt[i] = nxt[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (nxt[i] &amp;&amp; ss[i] != ss[nxt[i] + <span class="hljs-number">1</span>])<br>                nxt[i] = nxt[nxt[i]];<br>            nxt[i] += (ss[i] == ss[nxt[i] + <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 求所有在ss串中的start_pos. 如果first_only设置为true，则只返回第一个位置*/</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-type">char</span>* ss, <span class="hljs-type">bool</span> first_only = <span class="hljs-literal">false</span>)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len_s = <span class="hljs-built_in">strlen</span>(ss + <span class="hljs-number">1</span>);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">start_pos</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &lt;= len_s;) &#123;<br>            <span class="hljs-keyword">while</span> (j != <span class="hljs-number">1</span> &amp;&amp; ss[i] != t[j])<br>                j = nxt[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (ss[i] == t[j])  j++, i++;<br>            <span class="hljs-keyword">else</span>    i++;<br>            <span class="hljs-keyword">if</span> (j == len + <span class="hljs-number">1</span>) &#123;<br>                start_pos.<span class="hljs-built_in">push_back</span>(i - j + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (first_only) <span class="hljs-keyword">return</span> start_pos;<br>                j = nxt[len] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> start_pos;<br>    &#125;<br><br>    <span class="hljs-comment">/* 循环周期 形如 acaca 中 ac 是一个合法周期 */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">periodic</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-type">int</span> now = len;<br>        <span class="hljs-keyword">while</span> (now) &#123;<br>            now = nxt[now];<br>            ret.<span class="hljs-built_in">push_back</span>(len - now);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-comment">/* 循环节 形如 acac 中ac、acac是循环节，aca不是*/</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">periodic_loop</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : <span class="hljs-built_in">periodic</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (len % x == <span class="hljs-number">0</span>)   ret.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min_periodic_loop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">periodic_loop</span>()[<span class="hljs-number">0</span>]; &#125;<br>&#125; kmper;<br><br></code></pre></td></tr></table></figure><br><h2 id="失配树">失配树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 两个前缀的公共border其实就是在失配树上求lca</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>, maxd = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, nx[N], dep[N], fa[N][maxd + <span class="hljs-number">1</span>];<br>string s;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    dep[u] = dep[p] + <span class="hljs-number">1</span>;<br>    fa[u][<span class="hljs-number">0</span>] = p;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= n; i++)<br>        fa[u][i] = fa[fa[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dep[j])    <span class="hljs-built_in">dfs</span>(j, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dep[x] &lt; dep[y])    <span class="hljs-built_in">swap</span>(x, y);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxd; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (dep[fa[x][i]] &gt;= dep[y])<br>            x = fa[x][i];<br><br>    <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> x;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxd; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i])<br>            x = fa[x][i], y = fa[y][i];<br><br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; s &gt;&gt; m;<br>    n = s.<span class="hljs-built_in">size</span>();   s = <span class="hljs-string">&quot; &quot;</span> + s;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        nx[i] = nx[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (nx[i] &amp;&amp; s[i] != s[nx[i] + <span class="hljs-number">1</span>])   nx[i] = nx[nx[i]];<br>        nx[i] += (s[i] == s[nx[i] + <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> j = nx[i], u = i;<br>        <span class="hljs-built_in">add</span>(u, j), <span class="hljs-built_in">add</span>(j, u);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> p, q;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;p, &amp;q);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-built_in">lca</span>(p, q);<br><br>        <span class="hljs-comment">// 这里处理一下特判就行</span><br>        <span class="hljs-keyword">if</span> (ans == p || ans == q)   ans = nx[ans];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="manacher">Manacher</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Manacher</span> &#123;<br>    <span class="hljs-type">int</span> lc[MAX];<br>    <span class="hljs-type">char</span> ch[MAX];<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-built_in">Manacher</span>(<span class="hljs-type">char</span>* s) &#123;<br>        <span class="hljs-built_in">init</span>(s);<br>        <span class="hljs-built_in">manacher</span>();<br>    &#125;<br>    <span class="hljs-comment">/* s 1 bas */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br>        ch[n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        ch[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;@&#x27;</span>;<br>        ch[n * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>            ch[i * <span class="hljs-number">2</span>] = s[i];<br>            ch[i * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        &#125;<br>        N = <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">manacher</span><span class="hljs-params">()</span> </span>&#123;<br>        lc[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++) &#123;<br>            <span class="hljs-type">int</span> p = k + lc[k] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i &lt;= p) &#123;<br>                lc[i] = <span class="hljs-built_in">min</span>(lc[<span class="hljs-number">2</span> * k - i], p - i + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lc[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (ch[i + lc[i]] == ch[i - lc[i]])<br>                lc[i]++;<br>            <span class="hljs-keyword">if</span> (i + lc[i] &gt; k + lc[k])<br>                k = i;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><br><h2 id="hash">hash</h2><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221209203619250.png" alt="image-20221209203619250"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">305</span> * <span class="hljs-number">305</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> HASH_CNT = <span class="hljs-number">2</span>; <span class="hljs-comment">/* hash次数 */</span><br>ULL Seed_Pool[] = &#123;<span class="hljs-number">911</span>, <span class="hljs-number">146527</span>, <span class="hljs-number">19260817</span>, <span class="hljs-number">91815541</span>&#125;;<br>ULL Mod_Pool[] = &#123;<span class="hljs-number">29123</span>, <span class="hljs-number">998244353</span>, <span class="hljs-number">1000000009</span>, <span class="hljs-number">4294967291ull</span>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hash</span> &#123;<br>    ULL seed, mod;<br>    ULL base[maxn], sum[maxn];<br>    <span class="hljs-comment">// 构造哈希,从1~n,如果没有输入字符串的长度，需要手动把n设为sz(a)-1</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> seedindex, <span class="hljs-type">int</span> modindex, string a)</span> </span>&#123;<br>        seed = Seed_Pool[seedindex], mod = Mod_Pool[modindex];<br>        base[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            base[i] = base[i - <span class="hljs-number">1</span>] * seed % mod;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum[i] = (sum[i - <span class="hljs-number">1</span>] * seed % mod + a[i - <span class="hljs-number">1</span>]) % mod;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 这个不会单独用，是为了给外面的函数得到哈希值用的</span><br>    <span class="hljs-function">ULL <span class="hljs-title">gethash</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (sum[r] - sum[l - <span class="hljs-number">1</span>] * base[r - l + <span class="hljs-number">1</span>] % mod + mod) % mod;<br>    &#125;<br>&#125; hasher[HASH_CNT];<br><span class="hljs-comment">// 得到字符串(l~r)的哈希值(双哈希)</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> pair&lt;ULL, ULL&gt; <span class="hljs-title">hashrange</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(hasher[<span class="hljs-number">0</span>].<span class="hljs-built_in">gethash</span>(l, r), hasher[<span class="hljs-number">1</span>].<span class="hljs-built_in">gethash</span>(l, r));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    string a;<br>    cin &gt;&gt; a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; HASH_CNT; i++) &#123;<br>        hasher[i].<span class="hljs-built_in">init</span>(i, i, a);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> l1, r1, l2, r2;<br>        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hashrange</span>(l1, r1) == <span class="hljs-built_in">hashrange</span>(l2, r2))<br>            cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="字典树">字典树</h2><h3 id="trie">Trie</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, son[N][<span class="hljs-number">26</span>], cnt[N], nowtmp;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : s) &#123;<br>        <span class="hljs-type">int</span> c = i - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][c]) son[p][c] = ++nowtmp;<br>        p = son[p][c];<br>    &#125;<br>    cnt[p]++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : s) &#123;<br>        <span class="hljs-type">int</span> c = i - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][c]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][c];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>]; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        string s;   cin &gt;&gt; s;<br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>)   <span class="hljs-built_in">insert</span>(s);<br>        <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(s)); <br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="01trie">01Trie</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 区间异或值最大</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, a[N], pre[N];<br><span class="hljs-type">int</span> nowtmp, son[N][<span class="hljs-number">2</span>], tag[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> c = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][c]) son[p][c] = ++nowtmp;<br>        p = son[p][c];<br>    &#125;<br>    tag[p] = id;<br>&#125;<br><br><span class="hljs-function">il PII <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> c = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>, o = c ^ <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (son[p][o])  p = son[p][o], res |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>        <span class="hljs-keyword">else</span>    p = son[p][c];<br>        <span class="hljs-comment">// 这样更新也是可以的</span><br>        <span class="hljs-comment">// if (son[p][o])  p = son[p][o], res = res &lt;&lt; 1 | 1;</span><br>        <span class="hljs-comment">// else    p = son[p][c], res &lt;&lt;= 1;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;res, tag[p]&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>        pre[i] = pre[i - <span class="hljs-number">1</span>] ^ a[i];<br>    &#125;<br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>, l, r;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        PII tmp = <span class="hljs-built_in">search</span>(pre[i]);<br>        <span class="hljs-keyword">if</span> (ans &lt; tmp.first)<br>            ans = tmp.first, l = tmp.second, r = i;<br>        <span class="hljs-built_in">insert</span>(pre[i], i + <span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="可持久01trie">可持久01Trie</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> root[N], son[N * <span class="hljs-number">30</span>][<span class="hljs-number">2</span>], cnt[N * <span class="hljs-number">30</span>], nowtmp;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>    <span class="hljs-type">int</span> u = ++nowtmp, t = u;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> tmp = ((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>        son[u][<span class="hljs-number">0</span>] = son[pre][<span class="hljs-number">0</span>], son[u][<span class="hljs-number">1</span>] = son[pre][<span class="hljs-number">1</span>];<br>        cnt[u] = cnt[pre] + <span class="hljs-number">1</span>;<br>        son[u][tmp] = ++nowtmp;<br>        u = son[u][tmp], pre = son[pre][tmp];<br>    &#125;<br>    cnt[u] = cnt[pre] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> tmp = !((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (cnt[son[r][tmp]] - cnt[son[l][tmp]] &gt; <span class="hljs-number">0</span>) &#123;<br>            res |= (<span class="hljs-number">1ll</span> &lt;&lt; i);<br>            l = son[l][tmp], r = son[r][tmp];<br>        &#125;<br>        <span class="hljs-keyword">else</span>    l = son[l][!tmp], r = son[r][!tmp];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>    n++;<br>    root[<span class="hljs-number">1</span>] = <span class="hljs-built_in">insert</span>(now, root[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> x;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x);<br>        now ^= x;<br>        root[i] = <span class="hljs-built_in">insert</span>(now, root[i - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> x;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x);<br>            now ^= x;<br>            n++;<br>            root[n] = <span class="hljs-built_in">insert</span>(now, root[n - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> l, r, x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;l, &amp;r, &amp;x);<br>            <span class="hljs-type">int</span> tmp = now ^ x;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-built_in">query</span>(tmp, root[l - <span class="hljs-number">1</span>], root[r]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="ac自动机">AC自动机</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = N;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, fail[N], son[N][<span class="hljs-number">26</span>], nowtmp;<br><span class="hljs-type">int</span> ed[N], sum[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> idx)</span> </span>&#123;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(), p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-type">int</span> c = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (!son[p][c]) &#123;<br>son[p][c] = ++ nowtmp;<br>&#125;<br>p = son[p][c];<br>&#125;<br>ed[idx] = p;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">get_fail</span><span class="hljs-params">()</span> </span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (son[<span class="hljs-number">0</span>][i]) &#123;<br>fail[son[<span class="hljs-number">0</span>][i]]= <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(son[<span class="hljs-number">0</span>][i]);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (son[u][i]) &#123;<br>fail[son[u][i]] = son[fail[u]][i];<br>q.<span class="hljs-built_in">push</span>(son[u][i]);<br>&#125;<br><span class="hljs-keyword">else</span>son[u][i] = son[fail[u]][i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-built_in">dfs</span>(e[i]);<br>        sum[u] += sum[e[i]];<br>    &#125;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">acam</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(), p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>p = son[p][s[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>++sum[p];<br>&#125;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nowtmp; i++)<br>        <span class="hljs-built_in">add</span>(fail[i], i);<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br><br>    string s;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; s;<br>        <span class="hljs-built_in">insert</span>(s, i);<br>    &#125;<br><br>    <span class="hljs-built_in">get_fail</span>();<br>    cin &gt;&gt; s;<br>    <span class="hljs-built_in">acam</span>(s);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, sum[ed[i]]);<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM-Template </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
