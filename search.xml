<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构（非ACM版）</title>
      <link href="/post/79666db.html"/>
      <url>/post/79666db.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p><strong>数据结构：</strong></p><p>数据结构是互相之间存在一种或多种特定关系的数据元素的集合。</p><p>根据数据元素之间关系的不同特性，通常分为四种逻辑结构：</p><p>1）集合</p><p>2）线性结构</p><p>3）树形结构</p><p>4）图状或网状结构</p><br><p><strong>算法和算法分析：</strong></p><p>算法的特性：有穷性，确定性，可行性，输入输出性</p><p>设计算法的要求：正确性，可读性，健壮性，高效性</p><br><h1 id="线性表">线性表</h1><p>线性表就是具有相同特性的数据元素的一个有限序列，是最常用且最简单的一种数据结构。</p><p>线性表的逻辑结构特征：</p><p>（1）有限性：线性表中数据元素的个数是有穷的</p><p>（2）相同性：本章线性表中数据元素的类型是同一的</p><p>（3）顺序性：线性表中相邻的数据元素 $a_i$ 和ai之间存在<strong>序偶关系</strong> $(a_{i-1}, a_i)$，即 $a_{i-1}$ 是 $a_i$ 的前驱， $a_i$ 是 $a_{i-1}$ 的后继；$a_1$ 无前驱，$a_n$ 无后继，其它每个元素有且仅有一个前驱和一个后继</p><br><p>线性表的存储表示有两种，顺序存储和链表存储。</p><br><h2 id="顺序表">顺序表</h2><p>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。</p><p>一般来说，线性表的第i个数据元素 $a_i$ 的存储位置为：</p><p>$$LOC(a_i) = LOC(a_1) + (i-1)*l$$</p><br><p><strong>顺序表的存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 10  <span class="hljs-comment">// 线性表存储空间的初始分配量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LISTINCREMENT 10   <span class="hljs-comment">// 线性表存储空间的分配增量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1               <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0            <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;  <span class="hljs-comment">// ElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-comment">// 顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType* elem;<br>    <span class="hljs-type">int</span> length;    <span class="hljs-comment">// 当前长度</span><br>    <span class="hljs-type">int</span> listsize;  <span class="hljs-comment">// 当前的存储容量</span><br>&#125; SqList;<br></code></pre></td></tr></table></figure><br><p><strong>顺序表的功能实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 线性表L的初始化</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123;<br>    L.elem = (ElemType*)<span class="hljs-built_in">malloc</span>(LIST_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">if</span> (!L.elem)    <span class="hljs-keyword">return</span> ERROR;<br>    L.length = <span class="hljs-number">0</span>;<br>    L.listsize = LIST_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 消除线性表</span><br><span class="hljs-function">Status <span class="hljs-title">DestoryList</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(L.elem);  <span class="hljs-comment">// 释放空间</span><br>    L.elem = <span class="hljs-literal">NULL</span>;<br>    L.length = L.listsize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 获得线性表的长度，记忆保存的元素的个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(SqList&amp; L)</span> </span>&#123; <span class="hljs-keyword">return</span> L.length; &#125;<br><br><span class="hljs-comment">// 判断一个线性表是否为空表</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L.length == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 用e返回L中第i个数据元素的值</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L.length == <span class="hljs-number">0</span> || i &lt; <span class="hljs-number">1</span> || i &gt; L.length) &#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    e = L.elem[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 查找：在线性表中找到元素e在登记号位置上</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L, ElemType e)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (L.elem[i] == e) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 若未找到，返回0</span><br>&#125;<br><br><span class="hljs-comment">// 插入：在L中的第i个位置之前插入新的数据元素e，L的长度加1</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> i, ElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (L.length &gt;= L.listsize) &#123;<br>        <span class="hljs-comment">// 线性表已满</span><br>        ElemType* newbase = (ElemType*)<span class="hljs-built_in">realloc</span>(<br>            L.elem, (L.listsize + LISTINCREMENT) * <span class="hljs-built_in">sizeof</span>(ElemType));<br><br>        <span class="hljs-keyword">if</span> (!newbase)   <span class="hljs-keyword">return</span> ERROR;<br>        L.elem = newbase;<br>        L.listsize += LISTINCREMENT;<br>    &#125;<br>    <span class="hljs-type">int</span> *p, *q;<br>    q = &amp;(L.elem[i - <span class="hljs-number">1</span>]);  <span class="hljs-comment">// 插入位置</span><br>    <span class="hljs-keyword">for</span> (p = &amp;(L.elem[L.length - <span class="hljs-number">1</span>]); p &gt;= q; --p) &#123;<br>        *(p + <span class="hljs-number">1</span>) = *p;<br>    &#125;<br>    *q = e;<br>    ++L.length;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 删除：删除L的第i个数据元素，并用e返回其值，L的长度减1</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList&amp; L, <span class="hljs-type">int</span> i, ElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length)  <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-type">int</span> *p, *q;<br>    p = &amp;L.elem[i - <span class="hljs-number">1</span>];<br>    e = *p;<br>    q = &amp;L.elem[L.length - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (++p; p &lt;= q; ++p) &#123;<br>        *(p - <span class="hljs-number">1</span>) = *p;<br>    &#125;<br>    --L.length;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 打印线性表中的所有元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, L.elem[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在顺序存储结构的线性表中插入或删除一个数据元素，平均约移动表中一半元素。</p><p>时间复杂度约为 $O(n)$</p><br><p><strong>优点：</strong></p><p>存储密度大（结点本身所占存储量 / 结点结构所占存储量）</p><p>可以随机存取表中任一元素</p><p><strong>缺点：</strong></p><p>在插入、删除某一元素时， 需要移动大量元素</p><p>浪费存储空间</p><p>属于静态存储形式， 数据元素的个数不能自由扩充</p><br><h2 id="链式表">链式表</h2><p>链表是一种物理存储结构上非连续、非顺序的存储结构</p><p>数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p><br><p>结点：数据元素的存储映像。由数据域和指针域两部分组成</p><p>链表：n个结点由指针链组成一个链表</p><p>头指针：是指向链表中第一个结点的指针</p><p>头结点：要表示一个单链表时，只需声明一个头指针 L ，指向单链表的第一个结点</p><p>首元结点：是指链表中存储第一个数据元素的结点</p><br><p><strong>在链表中设置头结点有什么好处？</strong></p><p>（1）便于首元结点的处理</p><p>首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其它位置一致， 无须进行特殊处理</p><p>（2）便于空表和非空表的统一处理</p><p>无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了</p><br><h3 id="单链表">单链表</h3><p><strong>单链表的存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1               <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0            <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;  <span class="hljs-comment">// ElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-comment">// 链表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> &#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>* next;<br>&#125; LNode, *LinkList;<br></code></pre></td></tr></table></figure><br><p><strong>单链表的功能实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表的初始化</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList&amp; L)</span> </span>&#123;<br>    L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>    <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> ERROR;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 判断单链表是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LinkList L)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L-&gt;next == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 销毁单链表</span><br><span class="hljs-function">Status <span class="hljs-title">DestoryList</span><span class="hljs-params">(LinkList&amp; L)</span> </span>&#123;<br>    LNode* p;<br>    <span class="hljs-keyword">while</span> (L) &#123;<br>        p = L;  L = L-&gt;next;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 清空单链表</span><br><span class="hljs-function">Status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList&amp; L)</span> </span>&#123;<br>    LNode *p = L-&gt;next, *q;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        q = p-&gt;next;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = q;<br>    &#125;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 用e返回L中第i个数据元素的值</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i, ElemType&amp; e)</span> </span>&#123;<br>    LNode* p = L-&gt;next;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i) &#123;<br>        j++;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!p || j &gt; i)    <span class="hljs-keyword">return</span> ERROR;<br>    e = p-&gt;data;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 按值查找，找到就返回其地址</span><br><span class="hljs-function">LNode* <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L, ElemType e)</span> </span>&#123;<br>    LNode* p = L-&gt;next;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;data != e)<br>        p = p-&gt;next;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// 在第i个位置前插入元素e</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> i, ElemType e)</span> </span>&#123;<br>    LNode* p = L;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i - <span class="hljs-number">1</span>) &#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!p || j &gt; i - <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> ERROR;<br><br>    LNode* s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>    s-&gt;data = e;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 删除第i个元素，并由e返回其值</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> i, ElemType e)</span> </span>&#123;<br>    LNode* p = L;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i - <span class="hljs-number">1</span>) &#123;<br>        j++;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!p-&gt;next || j &gt; i - <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> ERROR;<br><br>    LNode* q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    e = q-&gt;data;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 打印线性表中的所有元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(LinkList L)</span> </span>&#123;<br>    LNode* p = L-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 头插法：数据是倒叙插入</span><br>ElemType a[<span class="hljs-number">100</span>], b[<span class="hljs-number">100</span>];<br><span class="hljs-function">LinkList <span class="hljs-title">List_HeadInsert</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    LNode* s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>        s-&gt;data = a[i];<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><br><span class="hljs-comment">// 尾插法：数据是正序插入</span><br><span class="hljs-function">LinkList <span class="hljs-title">List_TailInsert</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    LNode *s, *r = L;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));<br>        s-&gt;data = b[i];<br>        r-&gt;next = s;<br>        r = s;<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 尾结点指针置空</span><br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="循环链表">循环链表</h3><p>循环链表的特点：</p><p>表中最后一个结点的指针域指向头指针，整个链表形成一个环</p><p>从表中任一结点出发都可以找到其他的结点</p><p>循环链表的操作与单链表基本一致，但由于循环链表中没有NULL指针</p><p>故涉及遍历操作时，其终止条件就不再像非循环链表那样判断 p 或 p-&gt;next 是否为空</p><p>而是判断它们是否等于头指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将两个带尾指针的循环链表合并</span><br><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta, LinkList Tb)</span> </span>&#123;<br>    LNode* p = Ta-&gt;next;<br>    Ta-&gt;next = Tb-&gt;next-&gt;next;<br>    <span class="hljs-keyword">delete</span> Tb-&gt;next;<br>    Tb-&gt;next = p;<br>    <span class="hljs-keyword">return</span> Tb;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="双向链表">双向链表</h3><p>比单链表多一个 <strong>前驱指针prior</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> &#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *next, *prior;<br>&#125; DuLNode, *DuLinkList;<br><br><span class="hljs-comment">// 返回L中第i个数据元素的地址</span><br><span class="hljs-function">DuLNode* <span class="hljs-title">GetElem</span><span class="hljs-params">(DuLinkList L, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    DuLNode* p = L-&gt;next;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; i) &#123;<br>        j++;<br>        p = p-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// 在第i个位置之前插入元素e</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(DuLinkList&amp; L, <span class="hljs-type">int</span> i, ElemType e)</span> </span>&#123;<br>    DuLNode *p, *s;<br>    <span class="hljs-keyword">if</span> (!(p = <span class="hljs-built_in">GetElem</span>(L, i)))<br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (!(s = (DuLinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(DuLNode))))<br>        <span class="hljs-keyword">return</span> ERROR;<br><br>    s-&gt;data = e;<br>    s-&gt;prior = p-&gt;prior;<br>    p-&gt;prior-&gt;next = s;<br>    s-&gt;next = p;<br>    p-&gt;prior = s;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 删除第i个元素</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(DuLinkList&amp; L, <span class="hljs-type">int</span> i, ElemType&amp; e)</span> </span>&#123;<br>    DuLNode *p, *s;<br>    <span class="hljs-keyword">if</span> (!(p = <span class="hljs-built_in">GetElem</span>(L, i)))<br>        <span class="hljs-keyword">return</span> ERROR;<br><br>    e = p-&gt;data;<br>    p-&gt;prior-&gt;next = p-&gt;next;<br>    p-&gt;next-&gt;prior = p-&gt;prior;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="应用">应用</h2><p><strong>顺序存储和链式存储的各自特点和应用环境：</strong></p><p>（1）顺序存储</p><p>顺序存储结构的特点是逻辑上相邻的数据元素，物理存储位置也相邻，即地址连续</p><p>并且，顺序表的存储空间需要预先分配</p><p>适用于插入和删除操作较少的情况下</p><p>（2）链式存储</p><p>各个元素存储在任意的地址空间，逻辑相邻的元素在物理内存中没有联系</p><p>适用于需要频繁进行插入和删除操作的情况下</p><br><h3 id="有序表的合并">有序表的合并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">已知顺序线性表La和Lb的元素按值非递减排列</span><br><span class="hljs-comment">归并La和Lb得到新的顺序线性表Lc，Lc的元素也按值非递减排列</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">Status <span class="hljs-title">MergeList</span><span class="hljs-params">(SqList La, SqList Lb, SqList&amp; Lc)</span> </span>&#123;<br>    ElemType *pa, *pb, *pc, *pa_last, *pb_last;<br>    pa = La.elem, pa_last = pa + La.length - <span class="hljs-number">1</span>;<br>    pb = Lb.elem, pb_last = pb + Lb.length - <span class="hljs-number">1</span>;<br>    <br>    Lc.listsize = Lc.length = La.length + Lb.length;<br>    pc = Lc.elem = (ElemType*)<span class="hljs-built_in">malloc</span>(Lc.listsize * <span class="hljs-built_in">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">if</span> (!pc)    <span class="hljs-keyword">return</span> ERROR;<br><br>    <span class="hljs-keyword">while</span> (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123;<br>        <span class="hljs-keyword">if</span> (*pa &lt;= *pb) *pc++ = *pa++;<br>        <span class="hljs-keyword">else</span>    *pc++ = *pb++;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (pa &lt;= pa_last)   *pc++ = *pa++;<br>    <span class="hljs-keyword">while</span> (pb &lt;= pb_last)   *pc++ = *pb++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">// 将两个有序链表合并为一个有序链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList</span><span class="hljs-params">(LinkList&amp; La, LinkList&amp; Lb, LinkList&amp; Lc)</span> </span>&#123;<br>    LNode *pa = La-&gt;next, *pb = Lb-&gt;next, *pc;<br>    Lc = pc = La;<br>    <span class="hljs-keyword">while</span> (pa &amp;&amp; pb) &#123;<br>        <span class="hljs-keyword">if</span> (pa-&gt;data &lt;= pb-&gt;data) &#123;<br>            pc-&gt;next = pa;<br>            pc = pa;<br>            pa = pa-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pc-&gt;next = pb;<br>            pc = pb;<br>            pb = pb-&gt;next;<br>        &#125;<br>    &#125;<br>    pc-&gt;next = pa ? pa : pb;<br>    <span class="hljs-built_in">free</span>(Lb);<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="一元多项式的加法">一元多项式的加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 链表实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1     <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0  <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;  <span class="hljs-comment">// ElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-comment">// 链表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span> &#123;<br>    <span class="hljs-type">int</span> coef;  <span class="hljs-comment">// 系数</span><br>    <span class="hljs-type">int</span> expn;  <span class="hljs-comment">// 指数</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span>* next;<br>&#125; PNode, *LinkList;<br><br><span class="hljs-comment">// 尾插法：数据是正序插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Create</span><span class="hljs-params">(LinkList&amp; p, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    p = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(PNode));<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    PNode* s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(PNode));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;s-&gt;coef, &amp;s-&gt;expn);<br>        PNode *pre = p, *q = p-&gt;next;<br>        <span class="hljs-comment">// 保证指数递增</span><br>        <span class="hljs-keyword">while</span> (q &amp;&amp; q-&gt;expn &lt; s-&gt;expn) &#123;<br>            pre = q;<br>            q = q-&gt;next;<br>        &#125;<br>        s-&gt;next = q;<br>        pre-&gt;next = s;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(LinkList L)</span> </span>&#123;<br>    PNode* p = L-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d  **&quot;</span>, p-&gt;coef, p-&gt;expn);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(LinkList La, LinkList Lb, LinkList&amp; Lc)</span> </span>&#123;<br>    PNode *pa = La-&gt;next, *pb = Lb-&gt;next, *pc, *r;<br><br>    Lc = pc = La;<br>    <span class="hljs-keyword">while</span> (pa &amp;&amp; pb) &#123;<br>        <span class="hljs-keyword">if</span> (pa-&gt;expn &lt; pb-&gt;expn) &#123;<br>            pc-&gt;next = pa;<br>            pc = pa;<br>            pa = pa-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pa-&gt;expn &gt; pb-&gt;expn) &#123;<br>            pc-&gt;next = pb;<br>            pc = pb;<br>            pb = pb-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> sum = pa-&gt;coef + pb-&gt;coef;<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                r = pa;<br>                pa = pa-&gt;next;<br>                <span class="hljs-built_in">free</span>(r);<br>                r = pb;<br>                pb = pb-&gt;next;<br>                <span class="hljs-built_in">free</span>(r);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pa-&gt;coef = sum;<br>                pc-&gt;next = pa;<br>                pc = pa;<br>                pa = pa-&gt;next;<br>                r = pb;<br>                pb = pb-&gt;next;<br>                <span class="hljs-built_in">free</span>(r);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    pc-&gt;next = pa ? pa : pb;<br>    <span class="hljs-built_in">free</span>(pb);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    LinkList La, Lb, Lc;<br>    <span class="hljs-built_in">Create</span>(La, n);<br>    <span class="hljs-built_in">Create</span>(Lb, m);<br><br>    <span class="hljs-built_in">Merge</span>(La, Lb, Lc);<br>    <span class="hljs-built_in">OutPut</span>(Lc);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">4 3</span><br><span class="hljs-comment">7 0</span><br><span class="hljs-comment">3 1</span><br><span class="hljs-comment">9 8</span><br><span class="hljs-comment">5 17</span><br><span class="hljs-comment">8 1</span><br><span class="hljs-comment">22 7</span><br><span class="hljs-comment">-9 8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><h1 id="栈和队列">栈和队列</h1><p>栈和队列都是线性表的一种特殊情况</p><p>栈： 是只允许在一端进行插入或删除操作的线性表</p><p>队列：是只允许在一端进行插入，在另一端删除的线性表</p><be><h2 id="栈">栈</h2><p>“先入后出”（FILO）原则</p><p>最先放入栈中元素在栈底，最后放入的元素在栈顶</p><p>而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p><br><p><strong>卡特兰数</strong></p><p>$n$ 个不同的元素进站，出栈元素不同排列的个数有 $\frac{1}{n+1}C_{2n}^n$ 个</p><p>和线性表相似，栈也有两种存储表示方式，顺序栈更加常见</p><br><h3 id="顺序栈">顺序栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_INIT_SIZE 10  <span class="hljs-comment">// 存储空间的初始分配量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACKINCREMENT 10   <span class="hljs-comment">// 存储空间的分配增量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1                <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0             <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SElemType;  <span class="hljs-comment">// SElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    SElemType* base;<br>    SElemType* top;<br>    <span class="hljs-type">int</span> stacksize;  <span class="hljs-comment">// 当前的存储容量</span><br>&#125; SqStack;<br><br><span class="hljs-comment">// base == top 表示栈空</span><br><span class="hljs-comment">// top - base == stacksize 表示栈满</span><br><br><span class="hljs-comment">// 栈的初始化</span><br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack&amp; S)</span> </span>&#123;<br>    S.base = (SElemType*)<span class="hljs-built_in">malloc</span>(STACK_INIT_SIZE * <span class="hljs-built_in">sizeof</span>(SElemType));<br>    <span class="hljs-keyword">if</span> (!S.base) <span class="hljs-keyword">return</span> ERROR;<br>    S.top = S.base;<br>    S.stacksize = STACK_INIT_SIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 清空栈</span><br><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack&amp; S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.base) S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 销毁栈</span><br><span class="hljs-function">Status <span class="hljs-title">DextoryStack</span><span class="hljs-params">(SqStack&amp; S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.base) &#123;<br>        <span class="hljs-keyword">delete</span> S.base;<br>        S.stacksize = <span class="hljs-number">0</span>;<br>        S.base = S.top = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 用e返回栈顶元素</span><br><span class="hljs-function">Status <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack&amp; S, SElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *(S.top - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 插入新的元素</span><br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack&amp; S, SElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top - S.base == S.stacksize) &#123;<br>        <span class="hljs-comment">// 栈满，追加空间</span><br>        S.base = (SElemType*)<span class="hljs-built_in">realloc</span>(<br>            S.base, (S.stacksize + STACKINCREMENT) * <span class="hljs-built_in">sizeof</span>(SElemType));<br>        <span class="hljs-keyword">if</span> (!S.base) <span class="hljs-keyword">return</span> ERROR;<br><br>        S.top = S.base + S.stacksize;<br>        S.stacksize += STACKINCREMENT;<br>    &#125;<br>    *S.top++ = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 弹出栈顶元素</span><br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack&amp; S, SElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top == S.base) <span class="hljs-keyword">return</span> ERROR;<br>    e = *(--S.top);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="链栈">链栈</h3><p>链表的头指针就是栈顶</p><p>不需要头结点</p><p>基本不存在栈满的情况</p><p>空栈相当于头指针指向NULL</p><p>插入和删除仅在栈顶处进行</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230531111630648.png" alt="image-20230531111630648"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1                <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0             <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SElemType;  <span class="hljs-comment">// SElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span> &#123;<br>    SElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span>* next;<br>&#125; StackNode, *LinkStack;<br><br><span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StackEmpty</span><span class="hljs-params">(LinkStack&amp; S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 入栈</span><br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack&amp; S, SElemType e)</span> </span>&#123;<br>    StackNode* p = (StackNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SElemType));<br>    p-&gt;data = e;<br>    p-&gt;next = S;<br>    S = p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 出栈</span><br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack&amp; S, SElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    e = S-&gt;data;<br>    StackNode* p = S;<br>    S = S-&gt;next;<br>    <span class="hljs-built_in">delete</span> (p);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 取栈顶元素</span><br><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkStack&amp; S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S) <span class="hljs-keyword">return</span> S-&gt;data;<br>&#125;<br><br></code></pre></td></tr></table></figure><br><h2 id="队列">队列</h2><p>“先进先出”（FIFO）原则</p><p>是一种特殊的线性结构，它只允许在队列的首部进行删除操作，即“出队”</p><p>在队列的尾部进行插入操作，即“入队”</p><br><p>同样的，栈也有两种存储表示方式，循环顺序队列更加常见</p><br><h3 id="循环顺序队列">循环顺序队列</h3><p>用模运算将存储空间在逻辑上变成了 <strong>“环状”</strong> ，牺牲一个单元来区分队满和队空</p><p>(Q.rear + 1) % MAXQSIZE == Q.front 表示队满</p><p>Q.rear == Q.front  表示队空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100  <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1          <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0       <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> QElemType;  <span class="hljs-comment">// QElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-comment">// 顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span> &#123;<br>    QElemType* base;<br>    <span class="hljs-type">int</span> front, rear;<br>&#125; SqQueue;<br><br><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue&amp; Q)</span> </span>&#123;<br>    Q.base = (QElemType*)<span class="hljs-built_in">malloc</span>(MAXQSIZE * <span class="hljs-built_in">sizeof</span>(QElemType));<br>    <span class="hljs-keyword">if</span> (!Q.base) <span class="hljs-keyword">return</span> ERROR;<br>    Q.front = Q.rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 求队列中的元素个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue&amp; Q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;<br>&#125;<br><br><span class="hljs-comment">// 入队</span><br><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue&amp; Q, QElemType e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE == Q.front) <span class="hljs-keyword">return</span> ERROR;<br>    Q.base[Q.rear] = e;<br>    Q.rear = (Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 出队</span><br><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    e = Q.base[Q.front];<br>    Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXQSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 取队头元素</span><br><span class="hljs-function">QElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue &amp;Q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.front != Q.rear)  <span class="hljs-keyword">return</span> Q.base[Q.front];<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="链队列">链队列</h3><p>当无法估计所用队列的长度时，宜采用链队列</p><p>与链栈不同，链队列有头结点</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230531152133237.png" alt="image-20230531152133237"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1     <span class="hljs-comment">// 成功</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0  <span class="hljs-comment">// 失败</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;  <span class="hljs-comment">// Status是函数的类型，其值是函数结果状态代码，如 OK 等</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> QElemType;  <span class="hljs-comment">// QElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span> &#123;<br>    QElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span>* next;<br>&#125; QNode, *QueuePtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    QueuePtr front;<br>    QueuePtr rear;<br>&#125; LinkQueue;<br><br><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue&amp; Q)</span> </span>&#123;<br>    Q.front = Q.rear = (QNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span> (!Q.front) <span class="hljs-keyword">return</span> ERROR;<br>    Q.front-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 销毁</span><br><span class="hljs-function">Status <span class="hljs-title">DestoryQueue</span><span class="hljs-params">(LinkQueue&amp; Q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (Q.front) &#123;<br>        QueuePtr p = Q.front-&gt;next;<br>        <span class="hljs-built_in">free</span>(Q.front);<br>        Q.front = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 入队</span><br><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue&amp; Q, QElemType e)</span> </span>&#123;<br>    QueuePtr p = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> ERROR;<br>    p-&gt;data = e; p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next = p;<br>    Q.rear = p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 出队</span><br><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue&amp; Q, QElemType&amp; e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    QueuePtr p = Q.front-&gt;next;<br>    e = p-&gt;data;<br>    Q.front-&gt;next = p-&gt;next;<br>    <span class="hljs-keyword">if</span> (Q.rear == p) Q.rear = Q.front;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 取队头元素</span><br><span class="hljs-function">QElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(LinkQueue &amp;Q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.front != Q.rear) <span class="hljs-keyword">return</span> (Q.front-&gt;next-&gt;data);<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="应用">应用</h2><h3 id="表达式求值">表达式求值</h3><p><strong>表达式的组成：</strong></p><p>操作数；常数、变量</p><p>运算符：算术运算符、关系运算符和逻辑运算符</p><p>界限符：左右括弧和表达式结束符</p><p>任何一个算术表达式都由操作数、算术运算符和界限符组成</p><p>后两者统称为算符</p><p>例如：# 3 * ( 7 - 2 ) #</p><br>为了实现表达式求值。需要设置两个栈<p>一个是算符栈 OPTR，用于寄存运算符</p><p>另一个称为操作数栈 QPND，用于寄存运算数和运算结果</p><p><strong>求值的处理过程：</strong></p><p>是自左至右扫描表达式的每一个字符</p><ul><li><p>当扫描到的是运算数，则将其压入栈OPND</p></li><li><p>当扫描到的是运算符时</p><ul><li>若这个运算符比OPTR栈顶运算符的优先级高，则入栈OPTR，继续向后处理</li><li>若这个运算符比OPTR栈顶运算符优先级低，则从OPND栈中弹出两个运算数，从OPTR中弹出栈顶运算符进行运算，并将运算结果压入栈OPND</li></ul></li><li><p>继续处理当前字符，直到遇到结束符为止。</p></li></ul><br><h1 id="串-数组和广义表">串、数组和广义表</h1><h2 id="串">串</h2><p>即字符串，是由零个或多个字符组成的有限序列。一般记为</p><p>$$s=‘a_1a_2…a_n’$$</p><p>子串：一个串中任意个连续字符组成的子序列（含空串）</p><br><h3 id="模式串匹配-bf">模式串匹配 - BF</h3><p>就是暴力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">char</span> ch[MAXLEN + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> length; <br>&#125; SString;<br><br><br><span class="hljs-comment">// 子串T在主串S的第pos个字符后出现的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_BF</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = pos, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;<br>        <span class="hljs-keyword">if</span> (S.ch[i] == T.ch[j]) i++, j++;<br>        <span class="hljs-keyword">else</span> i = i - j + <span class="hljs-number">2</span>, j = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (j &gt; T.length) <span class="hljs-keyword">return</span> i - T.length;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="模式串匹配-kmp">模式串匹配 - KMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s, t;<br>    cin &gt;&gt; s &gt;&gt; t;  <span class="hljs-comment">// 下标从1开始</span><br>    n = s.<span class="hljs-built_in">size</span>(), m = t.<span class="hljs-built_in">size</span>(), s = <span class="hljs-string">&quot; &quot;</span> + s, t = <span class="hljs-string">&quot; &quot;</span> + t;<br><br>    nx[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br>        nx[i] = nx[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (nx[i] &amp;&amp; t[i] != t[nx[i] + <span class="hljs-number">1</span>])   nx[i] = nx[nx[i]];<br>        nx[i] += (t[i] == t[nx[i] + <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &lt;= n;) &#123;<br>        <span class="hljs-keyword">while</span> (j != <span class="hljs-number">1</span> &amp;&amp; s[i] != t[j])  j = nx[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == t[j])   i++, j++;<br>        <span class="hljs-keyword">else</span>    i++;<br>        <br>        <span class="hljs-keyword">if</span> (j == m + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, i - m);<br>            j = nx[m] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="数组">数组</h2><p>设数组开始存储位置为 $$LOC(0,0)$$，存储每个元素需要 L 个存储单元</p><p>则数组元素 $a[i][j]$ 的存储位置为：</p><p>$$LOC(i,j)=LOC(0,0)+(n*i+j)*L$$</p><br><p><strong>n维数组</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/B5FB0C24CFAF46274BBED7700E72FDAA.jpg" alt="img"></p><br><h2 id="广义表">广义表</h2><p>（1）广义表中的数据元素有相对次序：一个直接前驱和一个直接后继</p><p>（2）广义表的长度定义为最外层所包含元素的个数：</p><p>如：C = (a, ( b, d ) ) 是长度为 2 的广义表</p><p>（3）广义表的深度定义为该广义表展开后所含括号的重数：</p><p>A = ( b, d ) 的深度为 1，B = ( A, d ) 的深度为 2，C = ( f, B, h ) 的深度为 3</p><p>PS：“原子” 的深度为 0;  “空表” 的深度为 1</p><p>（4）表头和表尾：非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</p><br><ul><li>对任意一个非空的广义表，其表头可能是单元素，也可能是广义表</li><li>对任意一个非空的广义表，其表尾一定是广义表</li><li>表尾是由除了表头以外的其余元素组成的广义表，所以，需要在表尾的直接元素外面再加一层括号</li></ul><br><h1 id="树">树</h1><p><strong>树的属性：</strong></p><ul><li><strong>结点的度</strong>（Degree）：结点的子树个数</li><li><strong>树的度</strong>：树的所有结点中最大的度数</li><li><strong>叶子结点</strong>（Leaf）：度为 0 的结点，也叫<strong>终端结点</strong></li><li><strong>结点的层次</strong>（Level）：规定根结点在1层，其他任一结点的层数是其父结点的层数加1</li><li><strong>树的深度</strong>（Depth）：树中所有结点中的最大层次</li></ul><br><p><strong>树的性质：</strong></p><ol><li>树中的结点数 = 总度数 + 1</li><li>度为 m 的树第 i 层 至多 有 $m^{i − 1}$ 个结点</li><li>具有 n 个结点的 m 叉树的最小高度为 $log_m(n(m-1)+1)$</li></ol><br><p><strong>度为m的树、m叉树的区别</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230602094721628.png" alt="image-20230602094721628"></p><br><h2 id="二叉树">二叉树</h2><ul><li><p>第 i 层最多有 $2^{i-1}$ 个结点</p></li><li><p>高度为 h 的二叉树至多有 $2^h-1$ 个结点</p></li><li><p>对任何一课二叉树 T，如果其叶子结点数为 $n_0$，度为 2 的结点数为 $n_2$，则</p><ul><li>$n_0=n_2+1$</li></ul></li><li><p>具有 n 个结点的完全二叉树的深度为 $\lfloor{log_2n}\rfloor+1$</p></li><li><p>如果对一棵有 n 个结点的完全二叉树的结点按层序编号，则对任一结点 i</p><ul><li>如果 i = 1，则结点 i 是二叉树的根；如果 i &gt; 1，则其双亲是结点$\lfloor{i/2}\rfloor$</li><li>如果 2i &gt; n，则结点 i 无左孩子；否则其左孩子是 2i</li><li>如果 2i + 1 &gt; n，则结点之无右孩子；否则其右孩子是 2i + 1</li></ul></li></ul><br><h3 id="二叉树的存储结构">二叉树的存储结构</h3><p>（1）顺序存储</p><p>这种顺序存储方式仅仅适用于完全二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100  <span class="hljs-comment">// 二叉树的最大结点数</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><span class="hljs-keyword">typedef</span> TElemType SqBiTree[MAX_TREE_SIZE];<br>SqBiTree bt;<br></code></pre></td></tr></table></figure><br><p>（2）链式存储结构</p><p>在n个结点的二叉链表中，有 $n+1$ 个空指针域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> &#123;<br>    TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lChild, *rChild;<br>&#125; BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><br><h3 id="二叉树的遍历">二叉树的遍历</h3><p>二叉树的遍历，包括先序遍历、中序遍历、后序遍历和层序遍历</p><br><p>由二叉树的先序序列和中序序列，或后序序列和中序序列可以确定唯一一棵二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1     <span class="hljs-comment">// 鎴愬姛</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0  <span class="hljs-comment">// 澶辫触</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> &#123;<br>    TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lChild, *rChild;<br>&#125; BiTNode, *BiTree;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(BiTree &amp;T)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, T-&gt;data);<br>&#125;<br><br><br><span class="hljs-comment">// 创建二叉树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTNode</span><span class="hljs-params">(BiTree &amp;T)</span> </span>&#123;<br>    T = (BiTNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br>    TElemType e;<br>    std::cin &gt;&gt; e;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-number">-1</span>) T = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        T-&gt;data = e;<br>        T-&gt;lChild = <span class="hljs-literal">NULL</span>;<br>        T-&gt;rChild = <span class="hljs-literal">NULL</span>;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;请输入&quot;</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot;的左儿子值（-1代表无左儿子）：&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">CreateBiTNode</span>(T-&gt;lChild);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;请输入&quot;</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot;的右儿子值（-1代表无右儿子）：&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">CreateBiTNode</span>(T-&gt;rChild);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function">Status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree&amp; T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-built_in">visit</span>(T);<br>    <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lChild);<br>    <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rChild);<br>&#125;<br><br><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree&amp; T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lChild);<br>    <span class="hljs-built_in">visit</span>(T);<br>    <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rChild);<br>&#125;<br><br><span class="hljs-comment">// 后序遍历</span><br><span class="hljs-function">Status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree&amp; T)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lChild);<br>    <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rChild);<br>    <span class="hljs-built_in">visit</span>(T);<br>&#125;<br><br><span class="hljs-comment">// 层次遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrderTraverse</span><span class="hljs-params">(BiTree T)</span> </span>&#123;<br>    queue&lt;BiTNode*&gt; tree;<br>    tree.<span class="hljs-built_in">push</span>(T);<br>    <span class="hljs-keyword">while</span> (!tree.<span class="hljs-built_in">empty</span>()) &#123;<br>        BiTNode* p = tree.<span class="hljs-built_in">front</span>();<br>        tree.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (p-&gt;lChild != <span class="hljs-literal">NULL</span>) &#123;<br>            tree.<span class="hljs-built_in">push</span>(p-&gt;lChild);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p-&gt;rChild != <span class="hljs-literal">NULL</span>) &#123;<br>            tree.<span class="hljs-built_in">push</span>(p-&gt;rChild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="线索二叉树">线索二叉树</h2><p>利用二叉链表中的空指针域：</p><p>如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱</p><p>如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继</p><p>这种改变指向的指针称为“线索&quot;，加上了线索的二叉树称为线索二叉树</p><p>对二叉树按某种遍历次序使其变为线索二叉树的过程叫线索化</p><br><p>LTag： 若 LTag=0，lchild域指向左孩子；</p><p>若 LTag=1，lchild域指向其前驱。</p><p>RTag： 若 RTag=0，rchild域指向右孩子；</p><p>若 RTag=1，rchild域指向其后继。</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607092648463.png" alt="image-20230607092648463"></p><br><h2 id="树和森林">树和森林</h2><h3 id="表示方法">表示方法</h3><p>（1）双亲表示法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span> &#123;<br>    TElemType data;<br>    <span class="hljs-type">int</span> parent;<br>&#125; PTNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    PTNode nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> root, n;    <span class="hljs-comment">// 根节点的位置和结点个数</span><br>&#125; PTree;<br></code></pre></td></tr></table></figure><br><p>（2）孩子链表法</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605095002276.png" alt="image-20230605095002276"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><br><span class="hljs-comment">// 孩子结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> &#123;<br>    <span class="hljs-type">int</span> child;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *next;<br>&#125; *ChildPtr;<br><br><span class="hljs-comment">// 双亲结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    TElemType data;<br>    ChildPtr firstchild;<br>&#125; CTbox;<br><br><span class="hljs-comment">// 树结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    CTbox nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> root, n;<br>&#125; CTree;<br></code></pre></td></tr></table></figure><br><p>（3）孩子兄弟表示法</p><p>用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一 个兄弟结点</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605095929179.png" alt="image-20230605095929179"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> &#123;<br>    TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> *firstchild, *nextsibling;<br>&#125; CSNode, *CSTree;<br></code></pre></td></tr></table></figure><br><h3 id="与二叉树的相互转换">与二叉树的相互转换</h3><p><strong>将树转换成二叉树</strong></p><p>①加线：在兄弟之间加一连线</p><p>②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系</p><p>③旋转：以树的根结点为轴心，将整树顺时针转45°</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/C687CE919D2723C53A440A1BA7BA80C0.jpg" alt="img"></p><br><p><strong>将二叉树转换成树</strong></p><p>①加线：若p结点是双亲结点的左孩子，则将p沿分支找到的所有右孩子，都与p的双亲用线连起来</p><p>②抹线：抹掉原二叉树中双亲与右孩子之间的连线</p><p>③调整：将结点按层次排列，形成树结构</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/73E2D00D2B89E716C9C6DC0CE63E0765.jpg" alt="img"></p><br><p><strong>将森林转换成二叉树</strong></p><p>先把每棵树变成二叉树</p><p>再把各个根结点相连，再旋转</p><br><p><strong>将二叉树转换成森林</strong></p><p>将二叉树中根结点与其沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树</p><p>再将孤立的二叉树还原成树</p><br><h3 id="遍历">遍历</h3><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605101754867.png" alt="image-20230605101754867"></p><br><p><strong>2. 森林的遍历</strong></p><p>（1）先序遍历</p><p>依次从左到右对森林中的每一棵树进行先根遍历</p><p>（2）中序遍历</p><p>依次从左到右对森林中的每一棵树进行后根遍历</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605102220269.png" alt="image-20230605102220269"></p><br><h2 id="哈夫曼树">哈夫曼树</h2><p>树的路径长度：从树根到每一个结点的路径长度之和</p><p>结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积</p><p>树的带权路径长度：树中所有叶子结点的带权路径长度之和</p><br><p>哈夫曼树：最优树，就是带权路径长度(WPL)最短的树</p><p>PS：&quot;带权路径长度最短”是在度相同的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等</p><br><p><strong>哈夫曼算法：</strong></p><p>（1）根据 n 个给定的权值构成 n 棵二叉树的森林</p><p>（2）在森林中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和</p><p>（3）在森林中删除这两棵树，同时将新得到的二叉树加入森林中</p><p>（4）重复（2）（3）直到森林中只剩下一棵树</p><p>PS：哈夫曼树中共有 $2n-1$ 个结点，且其所有的分支结点的度均不为 1</p><br><p><strong>哈夫曼编码：</strong></p><ol><li>统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）</li><li>利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短</li><li>在哈夫曼树的每个分支上标上0或1 ：<ul><li>结点的左分支标0，右分支标1</li><li>把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码</li></ul></li></ol><br><p><strong>为什么哈夫曼编码能够保证是前缀编码?</strong></p><p>因为没有一片树叶是另一片树叶的祖先， 所以每个叶结点的编码就不可能是其它叶结点编码的前缀</p><p><strong>为什么哈夫曼编码能够保证字符编码总长最短?</strong></p><p>因为哈夫曼树的带权路径长度最短，故字符编码的总长最短</p><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>** HuffmanCode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> parent, lch, rch;<br>&#125; HTNode, *HuffmanTree;<br><br><span class="hljs-comment">// 在HT[1...idx]选择 parent为0 且 weight最小的两个结点，序号为s1, s2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Select</span><span class="hljs-params">(HuffmanTree&amp; HT, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span>&amp; s1, <span class="hljs-type">int</span>&amp; s2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> min1 = INT_MAX, min2 = INT_MAX;<br>    s1 = s2 = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= idx; i++) &#123;<br>        <span class="hljs-keyword">if</span> (HT[i].parent)   <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">if</span> (HT[i].weight &lt;= min1) &#123;<br>            min2 = min1, min1 = HT[i].weight;<br>            s2 = s1, s1 = i;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (HT[i].weight &lt;= min2) &#123;<br>            min2 = HT[i].weight;<br>            s2 = i;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 构造哈夫曼树和哈夫曼编码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatHuffmanTree</span><span class="hljs-params">(HuffmanTree&amp; HT, HuffmanCode HC, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;<br>    HT = (HTNode*)<span class="hljs-built_in">malloc</span>((m + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(HTNode));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        HT[i].lch = HT[i].rch = HT[i].parent = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        std::cin &gt;&gt; HT[i].parent;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> s1, s2;<br>        <span class="hljs-built_in">Select</span>(HT, i - <span class="hljs-number">1</span>, s1, s2);<br>        HT[s1].parent = HT[s2].parent = i;<br>        HT[i].lch = s1, HT[i].rch = s2;<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>    &#125;<br><br>    <span class="hljs-comment">// 从叶子到根逆向求每个字符的哈夫曼编码</span><br>    HC = (HuffmanCode)<span class="hljs-built_in">malloc</span>((n + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*));<br>    <span class="hljs-type">char</span>* cd = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>    cd[n - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> start = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = i, f = HT[i].parent; f; c = f, f = HT[f].parent) &#123;<br>            <span class="hljs-keyword">if</span> (HT[f].lch == c) cd[--start] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">else</span> cd[--start] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125;<br>        HC[i] = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>((n - start) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>        <span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(cd);<br>&#125;<br></code></pre></td></tr></table></figure><br><h1 id="图">图</h1><p>图的逻辑结构：多对多</p><p><strong>连通、连通图和连通分量：</strong></p><p>在无向图中，若从顶点v 到顶点w 有路径存在，则称v 和w 是连通的。</p><p>若图G 中任意两个顶点都是连通的，则称图G 为连通图，否则称为非连通图。</p><p>无向图中的极大连通子图称为连通分量</p><p><strong>强连通图、强连通分量：</strong></p><p>在有向图中，若从顶点v 到顶点w 和从顶点w 到项点v 之间都有路径，则称这两个顶点是强连通的</p><p>若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量</p><br><h2 id="存图">存图</h2><p>主要有<strong>邻接矩阵</strong>和<strong>邻接表</strong>两种存储结构</p><p><strong>邻接矩阵多用于稠密图，邻接表多用于稀疏图</strong></p><br><h3 id="邻接矩阵">邻接矩阵</h3><p><strong>无向图：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605153253588.png" alt="image-20230605153253588"></p><ol><li>无向图的邻接矩阵一定是一个对称矩阵。因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素</li><li>对于无向图，邻接矩阵的第i 行（或第 i 列）中非零元素的个数正好是第 i 个顶点的度</li><li>求顶点 $v_i$ 的所有邻接点就是将矩阵中第 i 行元素扫描一遍，$ A[i][j]=1$ 就是邻接点</li></ol><br><p><strong>有向图：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605153229053.png" alt="image-20230605153229053"></p><ol><li>主对角线上数值依然为0。但因为是有向图，所以此矩阵并不对称</li><li>有向图中，顶点 $v_i$ 的入度为是第 $v_i$ 列各数之和。出度为第 $v_i$ 行的各数之和</li></ol><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTEX_NUM 20  <span class="hljs-comment">// 最大顶点个数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF INT_MAX</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;  <span class="hljs-comment">// 顶点的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;      <span class="hljs-comment">// 边的数据类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcCell</span> &#123;<br>&#125; ArcCell;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    VerTexType vexs[MAX_VERTEX_NUM];               <span class="hljs-comment">// 顶点表</span><br>    ArcType arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];  <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;  <span class="hljs-comment">// 图当前的点数和边数</span><br>&#125; MGraph;<br><br><span class="hljs-comment">// 找到顶点对应的下标</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(MGraph &amp;G, <span class="hljs-type">char</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (G.vexs[i] == x) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(MGraph&amp; G)</span> </span>&#123;<br>    std::cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<br><br>    <span class="hljs-comment">// 输入点的信息</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>        std::cin &gt;&gt; G.vexs[i];<br>    <br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; G.arcnum; j++)<br>            G.arcs[i][j] = INF;<br>    <br>    <span class="hljs-comment">// 存边</span><br>    <span class="hljs-type">char</span> v1, v2;<br>    <span class="hljs-type">int</span> w;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++) &#123;<br>        std::cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<br>        <span class="hljs-type">int</span> i = <span class="hljs-built_in">LocateVex</span>(G, v1);<br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        G.arcs[i][j] = w;<br>        G.arcs[j][i] = w;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表">邻接表</h3><p><strong>无向图：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605164940709.png" alt="image-20230605164940709"></p><p><strong>有向图：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605165021980.png" alt="image-20230605165021980"></p><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTEX_NUM 20  <span class="hljs-comment">// 最大顶点个数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF INT_MAX</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> VerTexType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> &#123;<br>    <span class="hljs-type">int</span> adjvex;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>* nextarc;<br>&#125; ArcNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span> &#123;<br>    VerTexType data;<br>    ArcNode* firstarc;<br>&#125; VNode, AdjList[MAX_VERTEX_NUM];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    AdjList vertices;<br>    <span class="hljs-type">int</span> vexnum, arcnum;  <span class="hljs-comment">// 当前的顶点数和边数</span><br>&#125; ALGraph;<br><br><span class="hljs-comment">// 找到顶点对应的下标</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateVex</span><span class="hljs-params">(ALGraph&amp; G, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (G.vertices-&gt;data == x)  <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(ALGraph&amp; G)</span> </span>&#123;<br>    std::cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) &#123;<br>        std::cin &gt;&gt; G.vertices[i].data;<br>        G.vertices[i].firstarc = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> v1, v2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++) &#123;<br>        std::cin &gt;&gt; v1 &gt;&gt; v2;<br>        <span class="hljs-type">int</span> i = <span class="hljs-built_in">LocateVex</span>(G, v1);<br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        ArcNode *p1 = (ArcNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ArcNode));<br>        p1-&gt;adjvex = j;<br>        <span class="hljs-comment">// 头插法 v1-&gt;v2</span><br>        p1-&gt;nextarc = G.vertices[i].firstarc;<br>        G.vertices[i].firstarc = p1;<br>        <span class="hljs-comment">// 无向图 v2-&gt;v1（有向图则不需要）</span><br>        ArcNode *p2 = (ArcNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ArcNode));<br>        p1-&gt;adjvex = i;<br>        p2-&gt;nextarc = G.vertices[j].firstarc;<br>        G.vertices[j].firstarc = p2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="十字链表">十字链表</h3><p><strong>十字链表是有向图的一种链式存储结构</strong></p><p>对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。</p><p>十字链表就把邻接表与逆邻接表结合了起来</p><br><p><strong>我们重新定义顶点表结点结构：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605175600623.png" alt="image-20230605175600623"></p><p>其中firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout 表示出边表头指针，指向该顶点的出边表中的第一个结点。</p><p><strong>重新定义的边表结点结构：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605175644659.png" alt="image-20230605175644659"></p><p>其中 tailvex 是指弧起点在顶点表的下标，headvex 是指弧终点在顶点表中的下标</p><p>headlink是指入边表指针域，指向终点相同的下一条边</p><p>taillink是指边表指针域，指向起点相同的下一条边</p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/E1EB73315703F3AEB1178048935994D9.jpg" alt="img"></p><br><h3 id="邻接多重表">邻接多重表</h3><p><strong>邻接多重表是无向图的另一种链式存储结构。</strong></p><p>在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低</p><br><p><strong>重新定义的边表结点结构：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605180134589.png" alt="image-20230605180134589"></p><p>其中 ivex 和 jvex 是与某条边依附的两个顶点在顶点表中下标</p><p>ilink 指向依附顶点 ivex 的下一条边，jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构</p><p><strong>每个顶点也用一一个结点表示，它由如下所示的两个域组成</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605180230425.png" alt="image-20230605180230425"></p><p>其中，data 域存储该顶点的相关信息，firstedge 域指示第一条依附于该顶点的边</p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230605180807904.png" alt="image-20230605180807904"></p><br><h2 id="图的遍历">图的遍历</h2><p>对于图的遍历来，通常有两种遍历次序方案：<strong>深度优先遍历</strong>和<strong>广度优先遍历</strong></p><br><p>（1）邻接矩阵存图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    VerTexType vexs[MAX_VERTEX_NUM];<br>    ArcType arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br>    <span class="hljs-type">int</span> vexnum, arcnum;<br>&#125; MGraph;<br><br><br><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(MGraph&amp; G, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    std::cout &lt;&lt; u &lt;&lt; endl;<br>    visited[u] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; G.vexnum; v++) &#123;<br>        <span class="hljs-keyword">if</span> (G.arcs[u][v] &amp;&amp; (!visited[v]))<br>            <span class="hljs-built_in">DFS</span>(G, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>（2）邻接表存图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span> &#123;<br>    <span class="hljs-type">int</span> adjvex;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>* nextarc;<br>&#125; ArcNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span> &#123;<br>    VerTexType data;<br>    ArcNode* firstarc;<br>&#125; VNode, AdjList[MAX_VERTEX_NUM];<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    AdjList vertices;<br>    <span class="hljs-type">int</span> vexnum, arcnum;  <span class="hljs-comment">// 当前的顶点数和边数</span><br>&#125; ALGraph;<br><br><br><span class="hljs-comment">// 邻接表进行DFS</span><br><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(ALGraph&amp; G, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[u])<br>        <span class="hljs-keyword">return</span>;<br><br>    std::cout &lt;&lt; u &lt;&lt; endl;<br>    visited[u] = <span class="hljs-literal">true</span>;<br><br>    ArcNode* tmp = G.vertices[u].firstarc;<br>    <span class="hljs-keyword">while</span> (tmp) &#123;<br>        <span class="hljs-type">int</span> v = tmp-&gt;adjvex;<br>        <span class="hljs-keyword">if</span> (!visited[v])<br>            <span class="hljs-built_in">DFS</span>(G, u);<br>        tmp = tmp-&gt;nextarc;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 邻接表进行BFS</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(ALGraph&amp; G, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-type">int</span> q[<span class="hljs-number">100</span>], h = <span class="hljs-number">0</span>, t = <span class="hljs-number">-1</span>;<br>    q[++t] = u; visited[u] = <span class="hljs-literal">true</span>;<br>    std::cout &lt;&lt; u &lt;&lt; endl;<br><br>    <span class="hljs-keyword">while</span> (h &lt;= t) &#123;<br>        <span class="hljs-type">int</span> now = q[h++];<br><br>        <span class="hljs-keyword">for</span> (ArcNode* tmp = G.vertices[now].firstarc; tmp; tmp = tmp-&gt;nextarc) &#123;<br>            <span class="hljs-type">int</span> v = tmp-&gt;adjvex;<br>            <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>                std::cout &lt;&lt; v &lt;&lt; endl;<br>                visited[v] = <span class="hljs-literal">true</span>;<br>                q[++t] = v;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="图的应用">图的应用</h2><h3 id="最小生成树">最小生成树</h3><p>一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的 n − 1 条边</p><p>若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路</p><p>其中边的权值之和最小的那棵生成树，称为<strong>最小生成树</strong></p><br><p><strong>最小生成树算法主要有 Prim 算法和 Kruskal 算法</strong></p><br><p><strong>Prim</strong></p><p>从一个顶点出发，在保证不形成回路的前提下，每找到并添加一条最短的边，就把当前形成的连通分量当做一个整体或者一个点看待，然后重复“找最短的边并添加”的操作。</p><br><p><strong>Kruskal</strong></p><p>初始时为只有 n 个顶点而无边的非连通图 T，每个顶点自成一个连通分量</p><p>然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边</p><p>若该边依附的顶点落在T中不同的连通分量上，则将此边加入 T</p><p>否则舍弃此边而选择下一条权值最小的边</p><p>以此类推，直至 T 中所有顶点都在一个连通分量上。</p><br><p>prim算法的时间复杂度$O(n^2)$，Kruskal算法的时间复杂度$O(mlogm)$</p><br><h3 id="最短路">最短路</h3><p>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p><p>单源最短路 – Dijkstra</p><p>多源最短路 – Floyd</p><br><h2 id="有向无环图及其应用">有向无环图及其应用</h2><p>有向无环图：边有方向、图中无环</p><br><p>用一个有向图表示一个工程的各子工程及其相互制约的关系</p><p>其中以顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网</p><p>简称 AOV 网（Activity On Vertex）</p><p><strong>应用：拓扑排序</strong></p><br><p>用一个有向图表示一个工程的各子工程及其相互制约的关系</p><p>以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网</p><p>简称为 AOE 网（Activity On Edge）</p><p>AOE网具有以下两个性质：</p><ul><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生</li></ul><p><strong>应用：关键路径</strong></p><br><h3 id="拓扑排序">拓扑排序</h3><p>每个 AOV 网都有一个或多个拓扑排序序列</p><p><strong>构造拓扑排序：</strong></p><p>。在有向图中选一个没有前驱的顶点且输出</p><p>。从图中删除该顶点和所有以它为尾的弧</p><p>。重复上述两步，直至全部顶点均已输出或者当图中不存在无前驱的顶点</p><br><p>我们可以通过拓扑排序来检测 AOV 网中是否存在环：</p><p>对有向图构造其顶点的拓扑序列，若网中所有顶点都在它的拓扑序列中，则该 AOV 网无环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> indegree[MAX_VERTEX_NUM];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(ALGraph G)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化栈，存储入度为0的顶点</span><br>    <span class="hljs-built_in">InitStack</span>(S);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (indegree[i] == <span class="hljs-number">0</span>) <span class="hljs-built_in">Push</span>(S, i);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">IsEmpty</span>(S)) &#123;<br>        <span class="hljs-built_in">Pop</span>(S, i);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br><br>        count++;<br>        <span class="hljs-keyword">for</span> (ArcNode* p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) &#123;<br>            <span class="hljs-type">int</span> v = p-&gt;adjvex;<br>            <span class="hljs-comment">// 入度为0，则入栈</span><br>            <span class="hljs-keyword">if</span> (!--indegree[v]) <span class="hljs-built_in">Push</span>(S, v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 输出顶点少了，有向图中有环，排序失败</span><br>    <span class="hljs-keyword">if</span> (count &lt; G.vexnum) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 拓扑排序成功</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="关键路径">关键路径</h3><p>关键路径 —— 路径长度最长的路径</p><p>路径长度 —— 路径上各活动持续时间之和</p><br><p>ve(vj) —— 表示事件 vj 的最早发生时间</p><p>vl(vj) —— 表示事件 vj 的最迟发生时间</p><p>e(i) —— 表示活动 ai 的最早开始时间</p><p>l(i) —— 表示活动 ai 的最迟开始时间</p><p>那么，l(i) - e(i) —— 表示完成活动 ai 的时间余量</p><p>时间余量为零的活动称为关键活动（一定在关键路径上）</p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/C3984E6DACA7E5DE073BF00655DEB6F2.jpg" alt="img"></p><br><p><strong>求解关键路径：</strong></p><p>从源点出发，令 ve (源点) = 0，按拓扑排序求其余顶点的最早发生时间 ve( )</p><p>从汇点出发，令 vl (汇点) = v，按逆拓扑排序求其余顶点的最迟发生时间 vl( )</p><p>根据各顶点的 ve() 值求所有弧的最早开始时间 e()</p><p>根据各顶点的 vl() 值求所有弧的最迟开始时间 l()</p><p>求 AOE 网中所有活动的时间余量，为零的活动构成关键路径</p><br><h1 id="查找">查找</h1><p>查找表是由同一类型的数据元素（或记录）构成的集合</p><p>由于&quot;集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构</p><br><p>关键字：用来标识一个数据元素（或记录）的某个数据项的值</p><ul><li>主关键字：可唯一地标识一个记录的关键字</li><li>次关键字：用以识别若干记录的关键字</li></ul><br><p>查找算法的评价指标：关键字的平均比较次数，也称平均查找长度（ASL）</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230606182536166.png" alt="image-20230606182536166"></p><br><h2 id="线性表的查找">线性表的查找</h2><p><strong>查找表的存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> KeyType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    KeyType key;  <span class="hljs-comment">// 关键字域</span><br>&#125; ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType* R;<br>    <span class="hljs-type">int</span> length;<br>&#125; SSTable;<br></code></pre></td></tr></table></figure><br><p><strong>（1）顺序查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable&amp; ST, KeyType key)</span> </span>&#123;<br>    ST.R[<span class="hljs-number">0</span>].key = key;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = ST.length; ST.R[i].key != key; i--) ;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找第 i 个元素需要比较 n - i + 1 次，平均查找长度 $ASL=(n+1)/2$</p><p>时间复杂度 $O(n)$</p><br><p><strong>（2）折半查找（二分查找）</strong></p><p>只适用于有序表，且限于顺序存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable&amp; ST, KeyType key)</span> </span>&#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>, high = ST.length;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (ST.R[mid].key == key) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; ST.R[mid].key) high = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>平均查找长度 $ASL=log_2{(n+1)}-1$</p><p>时间复杂度 $O(logn)$</p><br><p><strong>（3）分块查找</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/C4EEC47DC62CD50FD66C6342B284B7D4.jpg" alt="img"></p><br><h2 id="树表的查找">树表的查找</h2><h3 id="二叉排序树"><strong>二叉排序树</strong></h3><p>二叉排序树或是空树，或是满足如下性质的二叉树：</p><ul><li>若其左子树非空，则左子树上所有结点的值均小于根结点的值</li><li>若其右子树非空，则右子树上所有结点的值均大于等于根结点的值</li><li>其左右子树本身又各是一棵二叉排序树</li></ul><br><p>中序遍历二叉排列树得到的是一个非递减序列</p><p><strong>二叉排序树的存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> KeyType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> InfoType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    KeyType key;         <span class="hljs-comment">// 关键字域</span><br>    InfoType otherinfo;  <span class="hljs-comment">// 其他数据域</span><br>&#125; ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span> &#123;<br>    ElemType data;                    <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span> *lchild, *rchild;  <span class="hljs-comment">// 左右孩子指针</span><br>&#125; BSTNode, *BSTree;<br></code></pre></td></tr></table></figure><br><p><strong>查找（递归实现）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BSTree <span class="hljs-title">SearchBST</span><span class="hljs-params">(BSTree&amp; T, KeyType key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((!T) || key == T-&gt;data.key) <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data.key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild, key);<br>&#125;<br></code></pre></td></tr></table></figure><p>含有 n 个结点的二叉排序树的平均查找长度和树的形态有关</p><p>最好情况下：$ASL=log_2{n+ 1}-1$</p><p>最坏情况下退化为顺序查找：$ASL=(n+1)/2$</p><br><p><strong>插入</strong></p><ul><li>若二叉排序树为空，则插入结点作为根结点插入到空树中</li><li>否则，继续在其左、右子树上查找<ul><li>树中已有，不再插入</li><li>树中没有，查找直至某个叶子结点的左子树或右子树为空为止，则插入。结点应为该叶子结点的左孩子或右孩子</li></ul></li></ul><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">在根指针T所指二叉排序树中递归地查找其关键字等于key的数据元素</span><br><span class="hljs-comment">若查找成功，则指针p指向该数据元素结点，并返回TRUE</span><br><span class="hljs-comment">否则指针p指向查找路径上访问的最后一个结点并返回FALSE</span><br><span class="hljs-comment">指针f指向T的双亲，其初始调用值为NULL</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">Status <span class="hljs-title">SearchBST</span><span class="hljs-params">(BSTree T, KeyType key, BSTree f, BSTree&amp; p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!T) &#123;<br>        p = f;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (T-&gt;data.key == key) &#123;<br>        p = T;<br>        <span class="hljs-keyword">return</span> TRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data.key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild, key, T, p);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild, key, T, p);<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">InsertBST</span><span class="hljs-params">(BSTree&amp; T, ElemType e)</span> </span>&#123;<br>    BSTree p;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SearchBST</span>(T, e.key, <span class="hljs-literal">NULL</span>, p)) &#123;<br>        BSTNode* s = (BSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BSTNode));<br>        s-&gt;data = e; s-&gt;lchild = s-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (!p) T = s;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.key &lt; p-&gt;data.key) p-&gt;lchild = s;<br>        <span class="hljs-keyword">else</span> p-&gt;rchild = s;<br>        <span class="hljs-keyword">return</span> TRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>删除</strong></p><p>（1）被删除的结点是叶子结点：直接删去该结点</p><p>（2）被删除的结点只有左子树或者只有右子树，直接用其左子树或者右子树替换它</p><p>（3）被删除的结点既有左子树，也有右子树</p><ul><li><p>以其中序前趋值替换之，然后再删除该前趋结点。前趋是左子树中最大的结点</p></li><li><p>也可以用其后继替换之，然后再删除该后继结点。后继是右子树中最小的结点</p></li></ul><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">Delete</span><span class="hljs-params">(BSTree&amp; p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!p-&gt;rchild) &#123;<br>        BSTree q = p;<br>        p = p-&gt;lchild;<br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!p-&gt;lchild) &#123;<br>        BSTree q = p;<br>        p = p-&gt;rchild;<br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        BSTree q = p, s = p-&gt;lchild;<br>        <span class="hljs-comment">// 找到左子树中最大的结点</span><br>        <span class="hljs-keyword">while</span> (s-&gt;rchild) &#123;<br>            q = s; s = s-&gt;rchild;<br>        &#125;<br>        p-&gt;data = s-&gt;data;<br>        <span class="hljs-keyword">if</span> (q != p) q-&gt;rchild = s-&gt;lchild;  <span class="hljs-comment">// 重接 *q 的右子树</span><br>        <span class="hljs-keyword">else</span> q-&gt;lchild = s-&gt;lchild;         <span class="hljs-comment">// 重接 *q 的左子树</span><br>        <span class="hljs-built_in">free</span>(s); <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="平衡二叉树">平衡二叉树</h3><p>平衡二叉树（balanced binary tree），又称 AVL 树</p><p>一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：</p><ul><li>左子树与右子树的高度之差的绝对值小于等于 1</li><li>左子树和右子树也是平衡二叉排序树</li></ul><br><p>为了方便起见，给每个结点附加一个数字，给出该结点左子树与右子树的高度差</p><p>这个数字称为结点的平衡因子（BF）</p><p>平衡因子 = 结点左子树的高度 - 结点右子树的高度</p><p>根据平衡二叉树的定义，平衡二叉树上所有结点的平衡因子只能是 -1、1 或 0</p><br><p><strong>失衡时的调整：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/D41693E82076277C4BE64E23817787EE.jpg" alt="img"></p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/7B2638ABFDCB5C810D588A90EC2920E0.jpg" alt="img"></p><p>实际上就是找出中间的那个数当作根节点，比它大的放在左边，比它小的放在右边</p><br><p><strong>LL型</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/95A506EA1A4EDBD4B3187C64C93FF5B8.jpg" alt="img"></p><br><p><strong>RR型</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/062942B8CDD296464F20B3D73145421E.jpg" alt="img"></p><br><p><strong>LR型</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607095745819.png" alt="image-20230607095745819"></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/B8049C249B744B468E89882F56814FB1.jpg" alt="img"></p><br><p><strong>RL型</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607100339218.png" alt="image-20230607100339218"></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/89611D4C92163372C6A08A7FAEF28418.jpg" alt="img"></p><br><h2 id="散列表的查找">散列表的查找</h2><p>散列存储（哈希）：选取某个函数，依该函数按关键字计算元素的存储位置</p><p>冲突：不同的关键码映射到同一个散列地址</p><br><p><strong>构造好的散列函数：</strong></p><ul><li>所选函数尽可能简单，以便提高转换速度</li><li>所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费</li></ul><br><br><p><strong>构造散列函数考虑的因素：</strong></p><p>执行速度（即计算散列函数所需时间）</p><p>关键字的长度</p><p>散列表的大小</p><p>关键字的分布情况</p><p>查找频率</p><br><br><p><strong>散列表的构造方法：</strong></p><p>（1）直接定址法：$Hash(key)=a*key+b$</p><p>以关键码 key 的某个线性函数为散列地址</p><p>优：不会产生冲突；劣：空间效率低</p><br><p>（2）除留余数法：$Hash(key)=key\space mod\space p$</p><p>p 的选取：小于表长的一个质数</p><br><p>（3）其他方法</p><p>数字分析法、平方取中法、折叠法、随机数法等</p><br><br><p><strong>处理冲突的方法：</strong></p><p>（1）开放寻址法</p><p>有冲突时就去寻找下一个空的散列地址，并将数据元素存入</p><ul><li>线性探测：增量序列为 $1,2,…,q$</li><li>二次探测法：增量序列为 $1^2,-1^2,2^2,-2^2,…,q^2$</li><li>伪随机探测法：增量序列为伪随机数</li></ul><br><p>（2）链地址法（拉链法）</p><p>相同散列地址的记录链成一个单链表，m 个散列地址就设 m 个单链表</p><p>然后用一个数组将 m 个单链表的表头指针存储起来，形成一个动态的结构</p><p>例如：一组关键字为 {19，14，23，1，68，20，84，27，55，11，10，79 }</p><p>散列函数为 Hash（key）= key  mod  13，则如下图所示：</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230607113532923.png" alt="image-20230607113532923"></p><p>非同义词不会冲突，链表上结点空间是动态申请的，适用于表长不确定的情况</p><br><p>还有其他的方法比如：</p><ul><li><p>再散列法（双哈希）</p></li><li><p>建立一个公共溢出区</p></li></ul><br><br><p><strong>散列表的查找：</strong></p><p>查找的过程其实就是构造的逆过程</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/E382A2EECC416D91603EF6225C227C49.jpg" alt="img"></p><br><p>使用平均查找长度ASL来衡量查找算法，ASL取决于：</p><p>散列函数、处理冲突的方法、散列表的装填因子（表中记录数 / 表长）</p><ul><li>散列表技术具有很好的平均性能，优于一些传统的技术</li><li>拉链法优于开放寻址法</li><li>除留余数法作散列函数优于其它类型函数</li></ul><br><h1 id="排序">排序</h1></be></font>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】CF558_E</title>
      <link href="/post/511433eb.html"/>
      <url>/post/511433eb.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p><strong>题目链接：</strong></p><p><a href="https://codeforces.com/contest/558/problem/E">https://codeforces.com/contest/558/problem/E</a></p><br><h2 id="题目大意">题目大意</h2><p>给定一个长度为 $n$ 的字符串（由小写英文字母组成），和 $q$ 个操作</p><p><strong>( 1 &lt;= n &lt;= 1e5、0 &lt;= q &lt;= 5e4 )</strong></p><p>每个操作 L R K 表示给区间 [L，R] 的字符串排序，K = 1为升序，K = 0为降序</p><p>要求输出最终的字符串 $s$</p><br><h2 id="分析">分析</h2><p><strong>举个例子</strong></p><p>假设区间需要从小到大排序，那么先从 a 开始，找到 a 的数量 cnta</p><p>然后把该区间内的原有 a 都删掉，然后从区间左端开始平铺 cnta 个 a</p><p>接着找到 b 的数量 cntb，清空所有的 b，再将 cntb 个 b 平铺在 a 的右边</p><p>重复平铺所有26个字母</p><p>从大到小同理，我们从右边开始平铺就好了。</p><p>差不多就是下图这样</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230105002011918.png" alt="image-20230105002011918"></p><br><p>所以我们可以用 <strong>26 棵线段树</strong> 维护区间中 <strong>每个字母</strong> 的个数</p><p>对于每个操作，我们只要把这段区间里的字母按 a − z 的顺序依次加入即可</p><ul><li><p>如果是升序，就不停更新加入左端点，右端点即为左端点加这个字母的数量</p></li><li><p>如果是降序，就不停更新加入右端点，左端点即为右端点减这个字母的数量</p></li></ul><p><strong>最后遍历所有线段树输出答案即可</strong></p><br><h2 id="code">Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">110</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-comment">// int e[M], ne[M], h[N], w[M], idx;</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> ans[N];    <span class="hljs-comment">// 记录最后的答案</span><br>string s;       <span class="hljs-comment">// 开始时的字符串</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, cnt, tag;<br>&#125; tr[<span class="hljs-number">26</span>][N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    tr[op][p].cnt = tr[op][p &lt;&lt; <span class="hljs-number">1</span>].cnt + tr[op][p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node &amp;c, node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c.tag != <span class="hljs-number">-1</span>) &#123;<br>        a.tag = b.tag = c.tag;<br>        a.cnt = a.tag * (a.r - a.l + <span class="hljs-number">1</span>);<br>        b.cnt = b.tag * (b.r - b.l + <span class="hljs-number">1</span>);<br>        c.tag = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-built_in">pushdown</span>(tr[op][p], tr[op][p &lt;&lt; <span class="hljs-number">1</span>], tr[op][p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    tr[op][p].l = l, tr[op][p].r = r, tr[op][p].tag = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        tr[op][p] = &#123;l, r, (s[l] == op + <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, op);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, op);<br>    <br>    <span class="hljs-built_in">pushup</span>(p, op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l &gt;= l &amp;&amp; tr[op][p].r &lt;= r) &#123;<br>        tr[op][p].tag = v;<br>        tr[op][p].cnt = (tr[op][p].r - tr[op][p].l + <span class="hljs-number">1</span>) * v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-type">int</span> mid = (tr[op][p].l + tr[op][p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, v, op);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, v, op);<br>    <span class="hljs-built_in">pushup</span>(p, op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l &gt;= l &amp;&amp; tr[op][p].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[op][p].cnt;<br>    <br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-type">int</span> mid = (tr[op][p].l + tr[op][p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, op);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, op);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-comment">// 遍历线段树</span><br><span class="hljs-comment">// 如果该点的权值为1，则答案中该位置为 op + &#x27;a&#x27;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">final</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l == tr[op][p].r) &#123;<br>        <span class="hljs-keyword">if</span> (tr[op][p].cnt == <span class="hljs-number">1</span>)<br>            ans[tr[op][p].l] = op + <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-built_in">final</span>(p &lt;&lt; <span class="hljs-number">1</span>, op);<br>    <span class="hljs-built_in">final</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br>    s = <span class="hljs-string">&quot; &quot;</span> + s;<br><br>    <span class="hljs-comment">// 建立26棵线段树</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, i);<br>    &#125;<br><br>    <span class="hljs-type">int</span> l, r, op;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; op;<br><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 升序</span><br>            <span class="hljs-type">int</span> idx = l, len;<br><br>            <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                len = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r, i);<br><br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)   <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 没出现该字符，跳过</span><br>                <br>                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">0</span>, i);                  <span class="hljs-comment">// 清空</span><br>                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, idx, idx + len - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, i);    <span class="hljs-comment">// 向右平铺</span><br>                idx += len;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 降序</span><br>            <span class="hljs-type">int</span> idx = r, len;<br>            <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                len = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r, i);<br><br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)   <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 没出现该字符，跳过</span><br><br>                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">0</span>, i);                  <span class="hljs-comment">// 清空</span><br>                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, idx - len + <span class="hljs-number">1</span>, idx, <span class="hljs-number">1</span>, i);    <span class="hljs-comment">// 向左平铺 </span><br>                idx -= len;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) <span class="hljs-comment">// 遍历所有线段树</span><br>        <span class="hljs-built_in">final</span>(<span class="hljs-number">1</span>, i);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">// 输出答案</span><br>        cout &lt;&lt; ans[i];<br>    <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="双倍经验">双倍经验</h2><p>CF240_F - TorCoder</p><p><strong>题目链接：</strong></p><p><a href="https://codeforces.com/contest/240/problem/F">https://codeforces.com/contest/240/problem/F</a></p><br><h3 id="题目大意">题目大意</h3><p>给定一个长为 n 的由 <strong>小写字母</strong> 组成的字符串，有 m 次操作</p><p>每次操作将 [L，R] 这些位置的字符进行重排，使得到字典序最小的回文字符串</p><p>如果无法操作就不进行</p><p>求 m 次操作后的字符串 $s$</p><br><h3 id="分析">分析</h3><p>跟上面的题目非常像，我们依然用 <strong>26 棵线段树</strong> 维护区间中 <strong>每个字母</strong> 的个数</p><p>不同的是，本题要求我们按照 <strong>字典序最小的回文串</strong> 排序</p><p>首先，我们很容易发现如果区间可以重排为一个回文串则意味下面的任意一种情况：</p><ol><li>所有字母出现的次数都是偶数</li><li>只有一个字母出现的次数是奇数，其余全是偶数</li></ol><p><strong>那么我们怎么保证排列后的回文串是字典序最小的呢？</strong></p><ul><li>只需要把字典序小的字母 放在前面就好了</li></ul><p>具体地说，</p><p>我们先将区间 “清空”</p><p>如果有一个字母出现的是奇数次，将它放到中间</p><p>然后从 ‘a’ 到 ‘z’，每个字母 在区间的两端各放一半，从两边向中间平铺即可，如下图</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230105201433450.png" alt="image-20230105201433450"></p><p><strong>最后遍历所有线段树输出答案</strong></p><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 线段树部分 与上题一样的</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">110</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-comment">// int e[M], ne[M], h[N], w[M], idx;</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> ans[N];    <span class="hljs-comment">// 记录最后的答案</span><br>string s;       <span class="hljs-comment">// 开始时的字符串</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, cnt, tag;<br>&#125; tr[<span class="hljs-number">26</span>][N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    tr[op][p].cnt = tr[op][p &lt;&lt; <span class="hljs-number">1</span>].cnt + tr[op][p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node &amp;c, node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c.tag != <span class="hljs-number">-1</span>) &#123;<br>        a.tag = b.tag = c.tag;<br>        a.cnt = a.tag * (a.r - a.l + <span class="hljs-number">1</span>);<br>        b.cnt = b.tag * (b.r - b.l + <span class="hljs-number">1</span>);<br>        c.tag = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-built_in">pushdown</span>(tr[op][p], tr[op][p &lt;&lt; <span class="hljs-number">1</span>], tr[op][p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    tr[op][p].l = l, tr[op][p].r = r, tr[op][p].tag = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        tr[op][p] = &#123;l, r, (s[l] == op + <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, op);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, op);<br>    <br>    <span class="hljs-built_in">pushup</span>(p, op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l &gt;= l &amp;&amp; tr[op][p].r &lt;= r) &#123;<br>        tr[op][p].tag = v;<br>        tr[op][p].cnt = (tr[op][p].r - tr[op][p].l + <span class="hljs-number">1</span>) * v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-type">int</span> mid = (tr[op][p].l + tr[op][p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, v, op);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, v, op);<br>    <span class="hljs-built_in">pushup</span>(p, op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l &gt;= l &amp;&amp; tr[op][p].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[op][p].cnt;<br>    <br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-type">int</span> mid = (tr[op][p].l + tr[op][p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, op);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, op);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">final</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[op][p].l == tr[op][p].r) &#123;<br>        <span class="hljs-keyword">if</span> (tr[op][p].cnt == <span class="hljs-number">1</span>)<br>            ans[tr[op][p].l] = op + <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p, op);<br>    <span class="hljs-built_in">final</span>(p &lt;&lt; <span class="hljs-number">1</span>, op);<br>    <span class="hljs-built_in">final</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, op);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br>    s = <span class="hljs-string">&quot; &quot;</span> + s;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, i);<br><br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) mp[i] = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r, i);<br><br>        <span class="hljs-type">int</span> odd = <span class="hljs-number">0</span>, idx;<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[i] &amp; <span class="hljs-number">1</span>)  odd++, idx = i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (odd &gt; <span class="hljs-number">1</span>)    <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 出现奇数次的字母只能有一个</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r, <span class="hljs-number">0</span>, i);  <span class="hljs-comment">// 清空</span><br><br>        <span class="hljs-keyword">if</span> (odd) &#123;                  <span class="hljs-comment">// 先将出现奇数次的字母放一个到正中间</span><br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            mp[idx]--, <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, mid, mid, <span class="hljs-number">1</span>, idx);<br>        &#125;<br><br>        <span class="hljs-type">int</span> nl = l, nr = r;         <span class="hljs-comment">// 从两边向中间放，一边放一半</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, nl, nl + mp[i] / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, i);<br>            nl += mp[i] / <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, nr - mp[i] / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, nr, <span class="hljs-number">1</span>, i);<br>            nr -= mp[i] / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) <span class="hljs-comment">// 遍历所有线段树</span><br>        <span class="hljs-built_in">final</span>(<span class="hljs-number">1</span>, i);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">// 输出答案</span><br>        cout &lt;&lt; ans[i];<br>    <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>PS:</strong></p><p>这题要求从文件 <code>input.txt</code> 中读入数据，输出到文件 <code>output.txt</code> 中</p><p>main函数加段代码就行了，具体不懂~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ONLINE_JUDGE</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】ABC280_F</title>
      <link href="/post/50a3438f.html"/>
      <url>/post/50a3438f.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p><strong>题目链接：</strong></p><p><a href="https://atcoder.jp/contests/abc280/tasks/abc280_f">https://atcoder.jp/contests/abc280/tasks/abc280_f</a></p><br><h2 id="题目大意">题目大意</h2><p>对于 n 个点，m 条边的有向图 G</p><p>有 a → b 的长为 c (c ≥ 0) 的边，且有 b → a 的长为 −c 的边</p><p>对于 q 次询问，每次询问两点之间的最长距离</p><p>如果不可能到达输出 “nan”，如果距离无限大输出 “inf”</p><p>$$n,m,k&lt;=10^5$$</p><br><h2 id="分析">分析</h2><p><strong>（1）对于不可能到达的情况</strong></p><p>我们可以直接用并查集维护连通性</p><p>若两个点不在同一个连通分量，则说明他们不连通，输出 “nan”</p><br><p><strong>（2）对于距离无限大的情况</strong></p><p>显然，当连通块内存在正环时，连通块内的任何两个点之间的距离都是无穷大</p><p>（绕着正环一直走）</p><p><strong>寻找正环的方式：</strong></p><p>我们从连通块中任意选择一个点开始 bfs，</p><p>若到达某一点的距离不唯一，则说明存在正权环，输出“inf”</p><p><strong>为什么距离不唯一就存在正环？</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230102221748726.png" alt="image-20230102221748726"></p><p>如上图，从节点1开始 bfs，到达节点 4 的距离有两个</p><ul><li>dis1 = w1 + w2</li><li>dis2 = w3 + w4</li></ul><p>我们假设dis1 &gt; dis2，即 w1 + w2 &gt; w3 + w4</p><p>则按照题意，节点1 -&gt; 节点2 -&gt; 节点4 -&gt; 节点3 -&gt; 节点1</p><p>= w1 + w2 - w4 - w3</p><p>= dis1 - dis2&gt; 0</p><p>即存在正环</p><br><p><strong>（3）对于距离有限的情况</strong></p><p>如果以上两种情况都不是，则连通分量内的任意两点联通且距离唯一。</p><p>我们随意找到连通块内的一个点 rt，预处理出所有的点到 rt 的距离，记作 dis[]</p><p>则点 x 和点 y 之间的距离可以表示为 <strong>dis[y] - dis[x]</strong></p><br><p>我们发现（3）中的dis数组可以在 bfs 判断有无正环时得到</p><h2 id="code">Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, k, p[N], dis[N];<br><span class="hljs-type">bool</span> lp[N], vis[N]; <span class="hljs-comment">// lp[i] - 是否存在正环</span><br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)  p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    vis[s] = <span class="hljs-literal">true</span>, dis[s] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (!vis[j]) &#123;<br>                vis[j] = <span class="hljs-literal">true</span>;<br>                dis[j] = dis[t] + w[i];<br>                q.<span class="hljs-built_in">push</span>(j);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (dis[t] + w[i] != dis[j]) &#123;<br>                lp[<span class="hljs-built_in">find</span>(s)] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">10</span>; i++) &#123;<br>        dis[i] = INF;<br>        p[i] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br><br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, -c);<br><br>        <span class="hljs-type">int</span> fa = <span class="hljs-built_in">find</span>(a), fb = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (fa != fb)   p[fa] = fb;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">find</span>(i);<br>        <span class="hljs-keyword">if</span> (vis[tmp])   <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">bfs</span>(tmp);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-type">int</span> x, y;   cin &gt;&gt; x &gt;&gt; y;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(x) != <span class="hljs-built_in">find</span>(y))<br>            cout &lt;&lt; <span class="hljs-string">&quot;nan&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lp[<span class="hljs-built_in">find</span>(x)])<br>            cout &lt;&lt; <span class="hljs-string">&quot;inf&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; dis[y] - dis[x] &lt;&lt; endl; <br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java】创建对象时类的调用顺序</title>
      <link href="/post/cc4f59b0.html"/>
      <url>/post/cc4f59b0.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><h2 id="代码块">代码块</h2><p>在Java中，使用 { } 括起来的代码被称为代码块（Code block）</p><br><p>又称作初始化块，属于类中的成员，不需要通过对象名或者类名显式调用，而是在加载类的时候，隐式的被调用。</p><h3 id="分类">分类</h3><p>根据其位置和声明的不同，可以分为：</p><ul><li>普通（局部）代码块</li><li>同步代码块</li><li>静态代码块</li><li>构造（实例）代码块</li></ul><h3 id="普通局部代码块">普通(局部)代码块</h3><p>在类的方法体中出现，可以限定变量生命周期，及早释放，提高内存利用率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 局部代码块</span><br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        &#125;<br>        <span class="hljs-comment">// 局部代码块中声明的变量在代码块外部访问不到！</span><br>        <span class="hljs-comment">// System.out.println(n);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="同步代码块">同步代码块</h3><p>同步代码块指的是被Java中Synchronized关键词修饰的代码块</p><p>在Java中，Synchronized关键词不仅仅可以用来修饰代码块，与此同时也可以用来修饰方法，是一种线程同步机制</p><p>被Synchronized关键词修饰的代码块会被加上内置锁</p><br><h3 id="静态代码块">静态代码块</h3><p>直接放在类下的代码块，由static修饰的就是静态代码块。</p><p><strong><font color="#006eb1">静态代码块只能调用静态成员</font></strong></p><br><h4 id="静态代码块的形式">静态代码块的形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 内容</span><br>        System.out.println(<span class="hljs-string">&quot;执行静态代码块...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="调用时机">调用时机</h4><p><font color="#006eb1">与类的加载一起执行，并且仅执行一次</font></p><p><strong>那么，类在什么时候被加载？</strong></p><ol><li>创建对象实例时</li><li>创建子类对象时，其父类也会被加载</li><li>使用类的静态成员时</li></ol><p><strong>如果一个类中有多个静态代码块，会按照书写顺序依次执行</strong></p><br><h3 id="构造代码块">构造代码块</h3><p>直接放在类下的代码块，不加任何的修饰符</p><p><strong><font color="#006eb1">构造代码块可以调用任意成员</font></strong></p><br><h4 id="构造代码块的形式">构造代码块的形式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    &#123;<br>        <span class="hljs-comment">// 内容</span><br>        System.out.println(<span class="hljs-string">&quot;执行构造代码块...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="调用时机">调用时机</h4><p>与对象初始化一起加载，每次调用构造方法（即创建对象）都会执行，<strong>且优先度高于构造方法</strong></p><p>我们可以把它理解为另一种构造器或者说是对构造器的补充。</p><p>比如，当多个构造器都有相同的部分时，我们可以把相同的部分抽取到代码块中。</p><br><p>需要注意的是：</p><p><strong>如果仅使用类的静态成员，构造代码块是不会执行的</strong></p><p>因为构造代码块必须在创建对象时被调用，而使用类的静态成员并不需要创建对象</p><br><h2 id="执行顺序">执行顺序</h2><p>根据是否加修饰符【static】可以把类下的代码块分为<strong>静态代码块和构造代码块</strong></p><br><p>在Java中</p><p><font color="#006db0">静态代码块、构造代码块和构造函数的执行顺序是一个笔试的考点</font></p><p>这篇文章主要就是来介绍它们之间的执行顺序</p><h2 id="在单纯的一个类中">在单纯的一个类中</h2><p><strong>创建一个对象时的调用顺序：</strong></p><ol><li>调用静态代码块和静态属性初始化（优先级一样，存在多个时按定义顺序调用）</li><li>调用构造代码块和普通属性初始化（优先级一样，存在多个时按定义顺序调用）</li><li>调用构造方法（构造器）</li></ol><br><p><strong>简而言之：</strong></p><p><font color="#006db0">静态代码块 &gt; 构造代码块 &gt; 构造器</font></p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1_1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// 静态属性的初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> getNum1();<br><br>    <span class="hljs-comment">// 静态代码块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行静态代码块1....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行静态代码块2....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 普通属性的初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> getNum2();<br><br>    <span class="hljs-comment">// 构造代码块</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行构造代码块2....&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行构造代码块1....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;A() 构造器被调用...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNum1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行静态属性的初始化....&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNum2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行普通属性的初始化....&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序的执行结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">执行静态属性的初始化....</span><br><span class="hljs-comment">执行静态代码块1....</span><br><span class="hljs-comment">执行静态代码块2....</span><br><span class="hljs-comment">执行普通属性的初始化....</span><br><span class="hljs-comment">执行构造代码块2....</span><br><span class="hljs-comment">执行构造代码块1....</span><br><span class="hljs-comment">A() 构造器被调用...</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><h2 id="在有继承关系的类中">在有继承关系的类中</h2><p><strong>先不考虑静态构造器和静态属性初始化</strong></p><p>我们可以把子类的构造函数看作是</p><ul><li>supper()– 调用父类的构造器</li><li>调用本类的构造代码块</li><li>执行构造器</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1_1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行父类的构造代码块....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-comment">// 调用构造代码块</span><br>        System.out.println(<span class="hljs-string">&quot;父类的 A() 构造器被调用....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行子类的构造代码块....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-comment">// 调用构造代码块</span><br>        System.out.println(<span class="hljs-string">&quot;子类的 B() 构造器被调用...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序的执行结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">执行父类的构造代码块....</span><br><span class="hljs-comment">父类的 A() 构造器被调用....</span><br><span class="hljs-comment">执行子类的构造代码块....</span><br><span class="hljs-comment">子类的 B() 构造器被调用...</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><p>如上规律是我们不考虑静态构造器和静态属性初始化</p><p><strong>我们知道在创建一个对象时的步骤是：</strong></p><ol><li>加载类，先加载父类，再加载子类</li><li>创建对象</li></ol><p>所以我们就会先在加载类时执行静态代码块和静态属性初始化（先父类再子类）</p><p><font color="#006eb1">因此静态构造器和静态属性初始化则总是最早发生</font></p><br><p>综上所述</p><p><strong>创建一个带有继承关系的对象时的调用顺序：</strong></p><ol><li>父类的静态代码块和静态属性初始化（优先级一样，按定义顺序调用）</li><li>子类的静态代码块和静态属性初始化（优先级一样，按定义顺序调用）</li><li>父类的构造代码块和普通属性初始化（优先级一样，按定义顺序调用）</li><li>父类的构造器</li><li>子类的构造代码块和普通属性初始化（优先级一样，按定义顺序调用）</li><li>子类的构造器</li></ol><br><p><strong>简而言之：</strong></p><p><font color="#006db0">父静态代码块 &gt; 子静态代码块 &gt; 父构造代码块 &gt; 父构造器 &gt; 子构造代码块 &gt; 子构造器</font></p><p><strong>示例：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221223134333437.png" alt="image-20221223134333437"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序的执行结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">执行父类的静态属性初始化....</span><br><span class="hljs-comment">执行父类的静态代码块....</span><br><span class="hljs-comment">执行子类的静态属性初始化....</span><br><span class="hljs-comment">执行子类的静态代码块....</span><br><span class="hljs-comment">执行父类的普通属性初始化....</span><br><span class="hljs-comment">执行父类的构造代码块....</span><br><span class="hljs-comment">父类的 A() 构造器被调用....</span><br><span class="hljs-comment">执行子类的普通属性初始化....</span><br><span class="hljs-comment">执行子类的构造代码块....</span><br><span class="hljs-comment">子类的 B() 构造器被调用...</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><p><strong>需要注意的是，因为类仅加载一次</strong></p><p><strong><font color="#0089cf">所以当第二次创建该类的对象时，第1 - 2步（即静态代码块和静态属性初始化）就不再进行</font></strong></p><p>如下面的示例，第二次创建的tmp对象就不再执行静态代码块和静态属性初始化</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 若上图的主方法改为</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1_1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        System.out.println(<span class="hljs-string">&quot;===============================&quot;</span>);<br>        <span class="hljs-type">B</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序的执行结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">执行父类的静态属性初始化....</span><br><span class="hljs-comment">执行父类的静态代码块....</span><br><span class="hljs-comment">执行子类的静态属性初始化....</span><br><span class="hljs-comment">执行子类的静态代码块....</span><br><span class="hljs-comment">执行父类的普通属性初始化....</span><br><span class="hljs-comment">执行父类的构造代码块....</span><br><span class="hljs-comment">父类的 A() 构造器被调用....</span><br><span class="hljs-comment">执行子类的普通属性初始化....</span><br><span class="hljs-comment">执行子类的构造代码块....</span><br><span class="hljs-comment">子类的 B() 构造器被调用...</span><br><span class="hljs-comment">===============================</span><br><span class="hljs-comment">执行父类的普通属性初始化....</span><br><span class="hljs-comment">执行父类的构造代码块....</span><br><span class="hljs-comment">父类的 A() 构造器被调用....</span><br><span class="hljs-comment">执行子类的普通属性初始化....</span><br><span class="hljs-comment">执行子类的构造代码块....</span><br><span class="hljs-comment">子类的 B() 构造器被调用...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><h2 id="例题">例题</h2><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221223142852604.png" alt="image-20221223142852604"></p><br><p>输出的结果应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">静态成员sam初始化<br><span class="hljs-keyword">static</span>块被执行<br>sam1成员初始化<br>test1_1的默认无参构造器被调用<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类 </tag>
            
            <tag> 代码块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ACM】网络流-最小割</title>
      <link href="/post/bacb613e.html"/>
      <url>/post/bacb613e.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><h2 id="最小割">最小割</h2><p>最小割与最大流问题具有等价性。</p><p>最大流 - 最小割定理保证最大流的流量与最小割的容量相等。</p><p>利用这一性质，我们可以将最小割问题规约到最大流问题，用 EK 算法或者 Dinic 算法来寻找最小割。</p><br><p><strong>首先定义S-T Cut：</strong></p><ul><li><p>将所有的节点分成两个集合，起点 s 属于集合 S，终点 t 属于集合 T。</p></li><li><p>集合 S 和集合 T 的并集是整个节点</p></li></ul><br><p>下图就是一个 S-T Cut</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20230530105236436.png" alt="image-20230530105236436"></p><p>我们可以这样理解割的容量：</p><p>割断从集合 S 流向集合 T 的管道，即上图中的</p><p>$$（v_1-&gt;v_3，v_1-&gt;v_4，v_2-&gt;v_4）$$</p><p>容量就是所有这些管道的容量之和</p><p><strong>上图S-T Cut的容量为 2 + 2 + 2 = 6</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210120417218.png" alt="image-20221210120417218"></p><p>而这个S-T Cut 的容量就是2 + 1 = 3</p><p><strong>最小割就是一个最小容量的 S-T Cut</strong></p><p>也就是我们用最小的成本来截断从集合 S 流向集合 T 的水流。</p><p><strong>注意：最小割不一定唯一，比如下图两种 S-T Cut 的容量都是3。</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210120709846.png" alt="image-20221210120709846"></p><br><h2 id="最大流-最小割定理">最大流 - 最小割定理</h2><p>对于一个网络流问题：</p><p><font size="4" color="#004a97">最大流的流量 = 最小割的容量</font></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210121007819.png" alt="image-20221210121007819"></p><p>将最小割转化成最大流问题：</p><p>1、用任意方式得到最大流问题的残留网络</p><p>2、去掉残留网中的反向边</p><p>3、在最终残留网中，从起点出发，找到所有能达到的点，这些节点作为集合S，剩下的点作为集合T。</p><p>4、此时我们得到了最小割</p><br><h2 id="例题-网络战争">例题-网络战争</h2><h3 id="题目描述">题目描述</h3><p>给出一个带权无向图 G = (V, E)，每条边 <em>e</em> 有一个权 We</p><p>求将点 s 和点 t 分开的一个边割集 C，使得该割集的平均边权最小，即最小化：</p><p>$$\frac{\displaystyle\sum_{e\in C} w_e}{|C|}$$</p><p><strong>注意：</strong></p><p>边割集的定义与最小割中的割边的集合不同</p><p>在本题中，一个边割集是指：将这些边删去之后，s 与 t 不再连通</p><br><h3 id="输入">输入</h3><p>第一行包含四个整数 n，m，s，t，其中 n，m 分别表示无向图的点数、边数</p><p>接下来 m 行，每行包含三个整数 a，b，w，表示点 a 和 b 之间存在一条无向边，边权为 w</p><p>点的编号从 1 到 n</p><h3 id="输出">输出</h3><p>输出一个实数，表示将点 s 和点 t 分开的边割集的最小平均边权</p><p>结果保留两位小数</p><br><h3 id="样例">样例</h3><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">8</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><br><h3 id="分析">分析</h3><p><strong>根据01分数规划，我们可以进行转化：</strong></p><p>$$\frac{\sum W_e}{|C|}\ \ &lt;\ \ \lambda$$</p><p>等价于</p><p>$$\sum W_e\ \ &lt;\ \ \lambda * |C|$$</p><p>等价于</p><p>$$\sum W_e-\lambda * |C|\ \ &lt;\ \ 0$$</p><p>即</p><p>$$\sum(W_e-\lambda)\ \ &lt;\ \ 0$$</p><p>所以</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221215163931649.png" alt="image-20221215163931649"></p><p><font color="#2063c0">这个性质具有二段性，可以二分</font></p><br><p>那么式子的左边该怎么得到呢？</p><p>首先我们可以建一个新图，新图上每条边的边权是原图的$W_e-\lambda$</p><p>即 $W_e’=W_e-\lambda$</p><br><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221215170319645.png" alt="image-20221215170319645"></p><p><strong>我们注意到本题定义的割集并不是最小割中的割集</strong></p><p>如上图所示：</p><ul><li>最小割定义的割集是所有的绿色边</li><li>而本题定义的割集则又额外加了蓝色的边</li></ul><p>因为将绿色边删去之后，s 与 t 已经不再连通，此时再加上蓝色边仍然不连通</p><br><p>所以我们有以下结论：</p><ul><li>当 $W_e’&lt;0$，该边必选</li></ul><p>因为当前的边权小于零，一定会使最后的答案更小（即更优）</p><ul><li><p>对于无向边，添加双向边即可</p></li><li><p>在去掉权值小于零的边以后，就不需要再加额外的边，直接求最小割就是最终的答案</p></li></ul><p>因为额外的边只会令结果更大（而我们要求最小化结果）</p><br><p><strong>综上，本题的思路就是：</strong></p><ol><li>二分</li><li>在当前的 mid 建图</li><li>若边权（$W_e-mid$）小于零，则直接加到答案上</li><li>求最小割</li></ol><p><font color="#1a5cbe"><strong>另外本题的流量并不都是整数，所以需要用double</strong></font></p><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<br><span class="hljs-type">int</span> e[M], ne[M], tw[N], h[N], idx;<br><span class="hljs-type">double</span> w[N];<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, tw[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, tw[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">double</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">double</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">double</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">double</span> <span class="hljs-title">dinic</span><span class="hljs-params">(<span class="hljs-type">double</span> mid)</span> </span>&#123;<br>    <span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i += <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">if</span> (tw[i] &lt;= mid) &#123;<br>            res += tw[i] - mid;      <span class="hljs-comment">// 此时边权 wi - mid &lt; 0，加上更优</span><br>            w[i] = w[i ^ <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    w[i] = w[i ^ <span class="hljs-number">1</span>] = tw[i] - mid;<br>    <br>    <span class="hljs-type">double</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<span class="hljs-comment">// 此处存边权</span><br>    &#125;<br><br>    <span class="hljs-comment">// 二分</span><br>    <span class="hljs-type">double</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e7</span>;<br>    <span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dinic</span>(mid) &lt; <span class="hljs-number">0</span>)r = mid;<br>        <span class="hljs-keyword">else</span>l = mid;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, r);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】星际转移问题</title>
      <link href="/post/7e22abfa.html"/>
      <url>/post/7e22abfa.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2754">https://www.luogu.com.cn/problem/P2754</a></p><h2 id="题目描述">题目描述</h2><p>由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。</p><p>现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而太空船的容量是有限的，第 $i$ 艘太空船只可容纳  $r_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如 (1,3,4) 表示该太空船将周期性地停靠太空站 134134134… 每一艘太空船从一个太空站驶往任一太空站耗时均为 1。人们只能在太空船停靠太空站(或月球、地球)时上、下船。</p><p>初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。</p><br><h2 id="分析">分析</h2><p><strong>首先我们判断是否有解：</strong></p><p>其实就是判断地球和月球之间是否连通，用并查集维护即可</p><p>具体地：</p><p>将一艘飞船可以到达的所有星球并查集连起来，最后如果地球和月球无法连接，则无解</p><br><p><strong>若有解：</strong></p><p>枚举答案 + 最大流判定</p><p>因为有距离（天数）的限制，我们使用分层图，第 i 层表示第 i 天</p><p>以站点为点，太空船为边，人为流量</p><br><p><strong>建图：</strong></p><p>每一层图都有包括地球和月球在内的 n + 2 个点</p><p>有三类边：</p><ol><li>源点和汇点<ul><li>从源点向第0层(即第0天) 的0号点(即地球) 连一条容量为 k 的边，表示一开始有 k 个人</li><li>从每一层的 n + 1 号点(即月球) 向 汇点连一条容量为 INF 的边</li></ul></li><li>从第 i 层向第 i + 1 层可达到的点连一条容量为$r_i$ 的边，表示限制太空船的容纳人数</li><li>第 i 层的每个点向第 i + 1 层连一条容量为 INF 的边，表示人们可以在当前太空站停留</li></ol><p>如下图，我们不同的颜色表示三种类型的边</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221214123521342.png" alt="image-20221214123521342"></p><p>所以这题的做法就是：</p><ul><li><p>枚举day</p></li><li><p>求最大流，如果最大流大于等于k，说明我们可以把k个人在day天内移动到月球</p></li></ul><br><p>当然二分 day 也是可以的</p><p><strong>但是我们从小到大枚举 day 会比二分更优：</strong></p><p>因为随着层数的增加，点数和边数会越来越多，越来越复杂</p><p>二分的话需要每次都重新建图</p><p>而枚举只需要在当前的基础上加一些额外的边即可</p><h2 id="code">Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1101</span> * <span class="hljs-number">50</span> + <span class="hljs-number">10</span>, M = (N + <span class="hljs-number">1100</span> + <span class="hljs-number">20</span> * <span class="hljs-number">1101</span>) + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, k, S, T, cur[N], d[N], p[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ship</span> &#123;<br>    <span class="hljs-type">int</span> r;<br>    vector&lt;<span class="hljs-type">int</span>&gt; zz;<br>&#125; ships[<span class="hljs-number">30</span>];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)  p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 得到第i个点在第day天的编号</span><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> day)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> day * (n + <span class="hljs-number">2</span>) + i;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    S = N - <span class="hljs-number">2</span>, T = N - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) p[i] = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-comment">// 存太空船的信息</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;   cin &gt;&gt; a &gt;&gt; b;<br>        ships[i].r = a;<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, x; j &lt; b; j++) &#123;<br>            cin &gt;&gt; x;<br>            <span class="hljs-keyword">if</span> (x == <span class="hljs-number">-1</span>)    x = n + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 是月球</span><br>            ships[i].zz.<span class="hljs-built_in">pb</span>(x);<br>            <span class="hljs-keyword">if</span> (j) &#123;<br>                <span class="hljs-type">int</span> tmp = ships[i].zz[j - <span class="hljs-number">1</span>];<br>                p[<span class="hljs-built_in">find</span>(tmp)] = <span class="hljs-built_in">find</span>(x);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 是否有解</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>) != <span class="hljs-built_in">find</span>(n + <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第一类边</span><br>    <span class="hljs-built_in">add</span>(S, <span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), k);<br>    <span class="hljs-built_in">add</span>(<span class="hljs-built_in">get</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), T, INF);<br><br>    <span class="hljs-comment">// 枚举天数day</span><br>    <span class="hljs-type">int</span> day = <span class="hljs-number">1</span>, now = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 每一层的月球向汇点连一条容量为INF的边</span><br>        <span class="hljs-built_in">add</span>(<span class="hljs-built_in">get</span>(n + <span class="hljs-number">1</span>, day), T, INF);<br>        <br>        <span class="hljs-comment">// 表示在太空站停留的边</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> u = <span class="hljs-built_in">get</span>(i, day - <span class="hljs-number">1</span>), v = <span class="hljs-built_in">get</span>(i, day);<br>            <span class="hljs-built_in">add</span>(u, v, INF);<br>        &#125;<br><br>        <span class="hljs-comment">// 表示从上一层通过太空船到达的边，容量为ri</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-type">int</span> tt = ships[i].zz.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> a = ships[i].zz[(day - <span class="hljs-number">1</span>) % tt], b = ships[i].zz[day % tt];<br>            <span class="hljs-type">int</span> u = <span class="hljs-built_in">get</span>(a, day - <span class="hljs-number">1</span>), v = <span class="hljs-built_in">get</span>(b, day);<br>            <span class="hljs-built_in">add</span>(u, v, ships[i].r);<br>        &#125;<br><br>        now += <span class="hljs-built_in">dinic</span>();<br>        <span class="hljs-keyword">if</span> (now &gt;= k)   <span class="hljs-keyword">break</span>;<br>        day++;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出答案</span><br>    cout &lt;&lt; day &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 网络流24题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ACM】最大流模型(二)</title>
      <link href="/post/9be3e0a3.html"/>
      <url>/post/9be3e0a3.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><h2 id="多源汇最大流">多源汇最大流</h2><p>这种多起点题型很容易就能想到：</p><ul><li><p>建立一个超级源点，从超级源点向所有源点连一条容量是无穷大的边</p></li><li><p>建立一个超级汇点， 所有汇点向超级汇点连一条容量为无穷大的边</p></li></ul><p>在新图跑最大流即可得出原图的最大流。</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221214091959047.png" alt="image-20221214091959047"></p><h3 id="模板题">模板题</h3><h4 id="题目描述">题目描述</h4><p>给定一个包含 n 个点 m 条边的有向图，并给定每条边的容量，边的容量非负。</p><p>其中有 $S_c$ 个源点，$T_c$ 个汇点，图中可能存在重边和自环。</p><p>保证源点集合和汇点集合没有交集，求整个网络的最大流。</p><br><h4 id="输入">输入</h4><p>第一行包含四个整数 n，m，$S_c$，$T_C$</p><p>第二行包含 $S_c$ 个整数，表示所有源点的编号</p><p>第三行包含 $T_c$ 个整数，表示所有汇点的编号</p><p>接下来 m 行，每行三个整数 u，v，c，表示从点 u 到点 v 存在一条有向边，容量为 c</p><p>点的编号从 1 到 n</p><h4 id="输出">输出</h4><p>输出一个整数表示整个网络的最大流</p><br><h4 id="样例">样例</h4><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">70<br></code></pre></td></tr></table></figure><br><h4 id="code">Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><span class="hljs-type">int</span> sc, tc;<br><br><span class="hljs-comment">// dinic()</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; sc &gt;&gt; tc;<br>    S = <span class="hljs-number">0</span>, T = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= sc; i++) &#123;<br>        cin &gt;&gt; x;<br>        <span class="hljs-built_in">add</span>(S, x, INF);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= tc; i++) &#123;<br>        cin &gt;&gt; x;<br>        <span class="hljs-built_in">add</span>(x, T, INF);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">dinic</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="最大流关键边">最大流关键边</h2><p><font color="#008ad0">只给其扩大容量之后整个流网络的最大流能够变大，对于这样的边我们称之为关键边。</font></p><br><p>判断 u-&gt;v 是否为关键边：</p><ul><li><p>在某一个最大可行流中，这条边的流量是满的</p></li><li><p>在当前残留网络中，存在一条 S-&gt;u 和 v-&gt;T 的路径</p></li></ul><br><p>具体地：</p><ol><li><p>我们先对原图做一遍dinic</p></li><li><p>在当前最大流的残留网络上进行搜索</p><ul><li>在其残留网络上沿着容量大于0的边走，所有从源点能够到达的点和所有汇点能够到达的点打上标记</li></ul></li><li><p>当一条边满足：满流（f[i] == 0），并且他的起始点能从 S 点出发搜索到，终止点能够从 T 点出发搜索到，则为关键边。</p></li></ol><br><p><strong>从汇点搜的时候需要用反向边判断，即：</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221214101357922.png" alt="image-20221214101357922"></p><p>我们用一号类型的边找到点，再用二号类型的边（即反向边）进行判断</p><br><h3 id="模板题">模板题</h3><h4 id="题目描述">题目描述</h4><p>伊基编写了一个最大流程序，并计算出了当前运输网络的最大运输能力。</p><p>他对运输速度的现状十分不满，并希望能够提高国家的运输能力。</p><p>提高运输能力的方法很简单，伊基将在运输网络中重建一些道路，以使这些道路具有更高的运输能力。</p><p>但是不幸的是，凤凰国的财力有限，道路建设经费只够重建一条道路，伊基想要知道共有多少条道路可以纳入重建道路候选名单，这些道路需要满足，将其重建后，国家的总运输能力能够增加。</p><br><h4 id="输入">输入</h4><p>第一行包含 N 和 M，分别表示城市和道路的数量</p><p>接下来 M 行，每行包含三个整数 a，b，c，表示存在一条道路从城市 a 通往城市 b，且运输能力为 c</p><p>所有道路都是有方向的，城市编号从 0 到 N−1</p><p>生产日常商品的城市为 0 号城市，首都为 N−1 号城市</p><h4 id="输出">输出</h4><p>输出一个整数 K</p><p>表示存在 K 条道路，对其中每条道路进行重建都会增加运输网络的运输能力。</p><br><h4 id="样例">样例</h4><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><br><h4 id="code">Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><span class="hljs-type">bool</span> vis_s[N], <span class="hljs-type">vis_t</span>[N];<br><br><span class="hljs-comment">// dinic（）</span><br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">bool</span> st[], <span class="hljs-type">int</span> op)</span> </span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = i ^ op, ver = e[i];<br>        <span class="hljs-keyword">if</span> (w[j] &amp;&amp; !st[ver])   <span class="hljs-built_in">dfs</span>(ver, st, op);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    S = <span class="hljs-number">0</span>, T = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br>    <span class="hljs-built_in">dinic</span>();<br><br>    <span class="hljs-built_in">dfs</span>(S, vis_s, <span class="hljs-number">0</span>);   <span class="hljs-comment">// 0 表示不需要用反向边来判断</span><br>    <span class="hljs-built_in">dfs</span>(T, <span class="hljs-type">vis_t</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">// 1 表示需要用反向边来判断</span><br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> u = e[i ^ <span class="hljs-number">1</span>], v = e[i];<br>        <span class="hljs-keyword">if</span> (!w[i] &amp;&amp; vis_s[u] &amp;&amp; <span class="hljs-type">vis_t</span>[v])  ans++;<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br><h2 id="最大流判定">最大流判定</h2><p>直接看题。</p><br><h3 id="秘密挤奶机">秘密挤奶机</h3><p><strong>题目链接：<a href="http://poj.org/problem?id=2455">http://poj.org/problem?id=2455</a></strong></p><h4 id="题目描述">题目描述</h4><p>题目说现在有 n 个点，p 条边</p><p>每条边只能走一次，现在要从 1 号点到 n 号点走 t 次</p><p>求出所有走的边的最大值，使这个最大值最小</p><br><h4 id="输入">输入</h4><p>第一行包含三个整数 N，P，T</p><p>接下来 P 行，每行包含三个整数 a，b，c，表示地标 a 和 b之间存在一条长度为 c 的道路</p><h4 id="输出">输出</h4><p>输出一个整数，表示约翰必须使用的最长的单个道路的最小可能长度</p><br><h4 id="样例">样例</h4><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">9</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><br><p><strong>经典最大值最小化问题，可以直接二分出最大的边权 mid</strong></p><p>看是否存在一个最大流，其中所有边权都小于等于 mid，且流量大于 K</p><p>不断二分下去即可找到答案</p><br><p>那么现在的问题就是如何判断我们能不能只用长度小于 mid 的边，能走 t 次</p><p>也就是如何写我们的check函数，我们可以使用最大流判定</p><br><p>我们可以按照这个图建一个网络流，给每条长度小于 mid 的边流量为 1，说明只能走一次</p><p>大于 mid 的边流量为0，说明不能走</p><p>源点设为 1，汇点设为 n，求一遍源点到汇点的最大流就能得到我们能走多少遍，再判断是否大于等于要求的 t 即可</p><br><p><strong>还有一个问题，就是无向图向有向图的转换</strong></p><p>题目给定的是无向图，而网络流用的是有向图</p><p>我们在建图时，对于一条无向边（u，v），我们建两条有向边 u -&gt; v 和 v -&gt; u 两条有向边</p><p>Q：如下图，原网络中只能走一次，但是我们建了双向边的话就可以来回各走一次，不就不符合容量限制了吗？<br><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221214113132889.png" alt="image-20221214113132889"></p><p><strong>我们可以把正反各走一次看作没有流量经过，所以不影响容量限制</strong></p><br><h4 id="code">code</h4><p>这里我们开始时先存边的长度tw[]，在二分时再修改边的容量w[]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><span class="hljs-type">int</span> k, tw[M];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, tw[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, tw[idx] = c, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-comment">// dinic()</span><br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// 修改容量限制</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++) &#123;<br>        <span class="hljs-keyword">if</span> (tw[i] &gt; x)  w[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span>    w[i] = <span class="hljs-number">1</span>;   <br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">return</span> res &gt;= k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    S = <span class="hljs-number">1</span>, T = n;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-comment">// 建图，记录边的长度tw[]</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br><br>    <span class="hljs-comment">// 二分</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e6</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span>    l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    cout &lt;&lt; l &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ACM】最大流模型(一)</title>
      <link href="/post/a362395a.html"/>
      <url>/post/a362395a.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p>本篇内容大多参考 <a href="https://www.cnblogs.com/liu-runda/p/6262832.html">https://www.cnblogs.com/liu-runda/p/6262832.html</a></p></font><h2 id="无源汇上下界可行流循环流">无源汇上下界可行流(循环流)</h2><font size="3"><p><strong>模型：</strong></p><p>给一个网络，求一个流满足：</p><p>每条边 i 流量在 [low(i), upp(i)] 之间，每个点 u 都要满足流量守恒。</p><br><p><font color="\#004a97">可行流算法的核心是将一个不满足流量守恒的初始流调整成满足流量守恒的流</font></p><br><p>如果存在一个可行流，那么一定满足每条边的流量都大于等于流量的下限。</p><p>因此我们可以令每条边的流量等于流量下限，得到一个初始流。</p><p>然后建出这个流的残量网络。(即：每条边的流量等于这条边的流量上限与流量下限之差)</p><br><p>初始流就是一开始将每条边流量设为low(i)的流，显然这个流不一定满足流量守恒。</p><p>因此我们考虑在残量网络上求出一个另不满足流量守恒的附加流，使得这个附加流和我们的初始流合并之后满足流量守恒。即:</p><ul><li><p>如果某个点在初始流中满足流量守恒，那么这个点在附加流中也满足流量守恒</p></li><li><p>如果某个点在初始流中的流入量比流出量多x，那么这个点在附加流中的流出量比流入量多x</p></li><li><p>如果某个点在初始流中的流入量比流出量少x，那么这个点在附加流中的流出量比流入量少x</p></li></ul><p>X的数值可以枚举x的所有连边求出，比较方便的写法是开一个数组A[]，</p><p><strong>A[i]表示i在初始流中的流入量 - 流出量的值</strong></p><p>那么A[i]的正负表示流入量和流出量的大小关系，下面就用A[i]表示初始流中 i 的流入量 - 流出量</p><br><p>所以在附加流中，让点 u 的流入量 - 流出量 = −A[u]，就能保证流量守恒。</p><ul><li><p>当 A[u] &gt; 0（即 -a[u] &lt; 0），需要让u的流入量增加a[u]。</p><ul><li>这可以通过新建超级源点 SS，并增加 SS→u，容量为 A[u] 的边做到</li></ul></li><li><p>当 A[u] &lt; 0（即 -A[u] &gt; 0），需要让u的流出量增加A[u]。</p><ul><li>这可以通过新建超级汇点 TT，并增加 u→TT，容量为 −A[u] 的边做到</li></ul></li></ul><br><p>如果我们能找到一个流满足新加的边都满流，那这个流在原图上的部分就是我们需要的附加流。</p><p>(根据我们的建图方式，<strong>“新加的边都满流”</strong> 和 ”附加流合并上初始流得到流量平衡的流” 是等价的约束条件)</p><br><p><strong>那么怎样找出一个新加的边都满流的流呢？</strong></p><p>可以发现假如存在这样的方案，这样的流一定是我们所建出的图的 SS-TT 最大流。</p><p><strong>解法：</strong></p><p>跑 SS-TT 的最大流，再判断最大流的大小是否等于 SS 出发的所有边的流量上限之和（此时指向 TT 的边也一定满流，因为这两部分边的流量上限之和相等)。</p><p>最后，每条边在可行流中的流量 = 容量下界 + 附加流中它的流量（即跑完dinic之后所加反向边的权值）</p><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">500</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">200010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N], low[M], upp[M], a[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);<br><br>    S = <span class="hljs-number">0</span>, T = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;u, &amp;v, &amp;low[i], &amp;upp[i]);<br>        a[u] -= low[i], a[v] += low[i]; <span class="hljs-comment">// 构造差</span><br>        <span class="hljs-built_in">add</span>(u, v, upp[i] - low[i]);     <span class="hljs-comment">// 建残留网络</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(S, i, a[i]), tot += a[i];<br>        <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(i, T, -a[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span> (ans != tot) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, w[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] + low[i + <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br></font><h2 id="有源汇上下界可行流">有源汇上下界可行流</h2><font size="3"><p><strong>模型：</strong></p><p>现在的网络有一个源点 s 和汇点 t。求出一个流使得源点的总流出量等于汇点的总流入量。</p><p>其他的点满足流量守恒，而且每条边的流量满足上界和下界限制。</p><br><p>为了使源汇点满足流量守恒，我们需要有边流入源点 s，有边流出汇点 t。</p><p>注意到源点 s 的流出量等于汇点 t 的流入量，我们就可以从汇点 t 向源点 s 连一条下界为0上界为无穷大的边。</p><p>相当于把从源点 s 流出的流量再流回来。</p><p>在这样的图中套用上面的算法求出一个可行的循环流，拆掉从汇点 t 到源点 s 的边就得到一个可行的有源汇流。</p><br><p><strong>这里有一个小问题：最后得到的可行的有源汇流的流量是多少?</strong></p><p>可以发现，循环流中一定满足 s 流出的总流量 = 流入 s 的总流量</p><p>假定原图中没有边流入s，那么s流出的流量就是 t 到 s 的无穷边的流量，也就是 s-t 可行流的流量。</p><p>因此我们最后看一下 t 到 s 的无穷边的流量（即dinic跑完之后反向边的权值）即可知道原图中有源汇可行流的流量。</p><br></font><h2 id="有源汇上下界最大流">有源汇上下界最大流</h2><font size="3"><p><strong>模型：</strong></p><p>现在的网络有一个源点 s 和汇点 t，求出一个流使得源点的总流出量等于汇点的总流入量。</p><p>其他的点满足流量守恒，而且每条边的流量满足上界和下界限制。</p><p>在这些前提下要求<strong>总流量最大</strong></p><br><p>首先套用上面的算法求出一个有源汇有上下界可行流。</p><p>此时的流不一定最大，接下来在残量网络上跑 s-t 最大流即可</p><br><p><strong>最终的最大流流量 = 可行流流量(即 t 到 s 的无穷边上跑出的流量) + 新增广出的 s-t 最大流</strong></p></font><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">520</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">200010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><span class="hljs-type">int</span> a[N], s, t;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, ll, rr;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; ll &gt;&gt; rr;<br>        a[u] -= ll, a[v] += ll;<br>        <span class="hljs-built_in">add</span>(u, v, rr - ll);<br>    &#125;<br><br>    <span class="hljs-comment">// 先利用 虚拟源点S和虚拟汇点T 找到一组可行流</span><br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    S = <span class="hljs-number">0</span>, T = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(S, i, a[i]), tot += a[i];<br>        <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(i, T, -a[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">add</span>(t, s, INF);<br><br>    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span> (tmp != tot) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;No Solution&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 可行流的流量就是t到s的无穷边上跑出的流量</span><br>    <span class="hljs-type">int</span> ans = w[idx - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 然后在当前的残留网络上跑 s-t 的最大流</span><br>    S = s, T = t;<br>    w[idx - <span class="hljs-number">1</span>] = w[idx - <span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; ans + <span class="hljs-built_in">dinic</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="有源汇上下界最小流">有源汇上下界最小流</h2><font size="3"><p><strong>模型：</strong></p><p>现在的网络有一个源点 s 和汇点 t，求出一个流使得源点的总流出量等于汇点的总流入量。</p><p>其他的点满足流量守恒，而且每条边的流量满足上界和下界限制。</p><p>在这些前提下要求<strong>总流量最小</strong></p><br><p>依然是先跑出一个有源汇可行流，这时候的流也不一定是最小的。</p><p>假如我们能在残量网络上找到一条 s-t 的路径使得去掉这条路径上的流量之后仍然满足流量下限，我们就可以得到一个更小的流。但是好像我们并没有什么算法可以”找到尽可能多的能够去除流量的路径”</p><br><p>这时候需要我们再理解一下dinic的反向边：<font color="\#004a97">反向边的流量增加等价于正向边的的流量减少。</font></p><p>因此我们在残量网络上找出 t 到 s 的流就相当于减小了 s 到 t 的流，那么我们在跑出可行流的残量网络上跑 t-s 最大流，用可行流的大小减去这一次 t-s 最大流的大小就是最小流的大小。</p><p><strong>t-s 最大流其实就是尽量缩减 s-t 方向的流</strong></p></font><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e4</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><span class="hljs-type">int</span> s, t, a[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, ll, rr;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; ll &gt;&gt; rr;<br>        a[u] -= ll, a[v] += ll;<br>        <span class="hljs-built_in">add</span>(u, v, rr - ll);<br>    &#125;<br><br>    <span class="hljs-comment">// 先利用 虚拟源点S和虚拟汇点T 找到一组可行流</span><br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    S = <span class="hljs-number">0</span>, T = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(S, i, a[i]), tot += a[i];<br>        <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>)   <span class="hljs-built_in">add</span>(i, T, -a[i]);<br>    &#125;<br>    <span class="hljs-built_in">add</span>(t, s, INF);<br><br>    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span> (tmp != tot) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;No Solution&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 可行流的流量就是t到s的无穷边上跑出的流量</span><br>    <span class="hljs-type">int</span> ans = w[idx - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 然后在当前的残留网络上跑 t-s 的最大流</span><br>    S = t, T = s;<br>    w[idx - <span class="hljs-number">1</span>] = w[idx - <span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; ans - <span class="hljs-built_in">dinic</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】最长不下降子序列问题</title>
      <link href="/post/da24e842.html"/>
      <url>/post/da24e842.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2766">https://www.luogu.com.cn/problem/P2766</a></p><h2 id="题目描述">题目描述</h2><p>给定正整数序列</p><p>$${x_1,x_2,x_3…x_n}$$</p><ol><li>计算其最长不下降子序列的长度 $s$。</li><li>计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。</li><li>如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$ ，则从给定序列中最多可取出多少个长度为$s$ 的不下降子序列。</li></ol><br><h2 id="分析">分析</h2><p><font color="\#004a97">最大流拆点模型</font></p><p>我们可以通过容量来限制边</p><p>通过拆点来限制点</p><p>(1) <strong>第一问：</strong> 可以dp求解 maxlen</p><p>dp[i] 表示以 a[i] 结尾的最长不下降子序列长度</p><br><p>(2) <strong>第二问：</strong> 因为每个元素只能被取一次，考虑拆点。</p><p>一个点分为 i 和 i&quot;， 并在他们之间连一条容量为 1 的边。</p><ul><li><p>若 dp[i] == 1，则 S→i 连一条容量为 1 的边</p></li><li><p>若 dp[i] == x，则 i&quot;→T 连一条容量为1 的边</p></li><li><p>若 dp[i] == dp[j] + 1，j &lt; i，a[j] ≤ a[i]，则 j&quot;→i 连一条容量为 1 的边</p></li></ul><p>再跑 S-T 的最大流即可</p><br><p>(3) <strong>第三问：</strong> $x_1$ 和 $x_n$ 可以取出多次。</p><p>那么改变的就是与这两点直接相关的边的流量</p><p>我们在第二问的答案基础上，修改一些边。</p><ul><li>1→1&quot; 连一条容量为 INF 的边</li><li>n→n&quot; 连一条容量为 INF 的边</li><li>S→1 连一条容量为 INF 的边</li><li>若 dp[n] == maxlen，则 n&quot;→T 连一条容量为 1 的边</li></ul><p>再跑 S-T 的最大流即可</p><br><p><strong>特判：</strong></p><p>对于 n == 1 的情况需要特判</p><br><p><strong>那么我们为什么要拆点？</strong></p><p>我们观察序列 {4， 3， 5， 9， 7}</p><p>dp[] = {1, 1, 2, 3, 3}</p><p>如果我们不拆点的话，建图就是下图的样子</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221213215342188.png" alt="image-20221213215342188"></p><p>这个建图方式得到的最大流是2，但是我们很容易得到正确的答案应该是1</p><p>其实我们只需要加上一个虚拟点限制该点的流出量只能为1，即可解决：</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221213215558828.png" alt="image-20221213215558828"></p><p><font color="#004a97"><strong>所以我们把每个点拆分成两个点，连一条容量为 1 的边，限制住只能取一次这个条件</strong></font></p><br><h2 id="code">Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, M = N * N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, a[N], dp[N], ans1;<br><span class="hljs-type">int</span> d[N], cur[N], S, T;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">DP</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )&#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>            <span class="hljs-keyword">if</span> (a[j] &lt;= a[i])<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        ans1 = <span class="hljs-built_in">max</span>(ans1, dp[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-comment">// 特判</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">DP</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans1);<br><br><span class="hljs-comment">/* ====================================== */</span><br>    <br>    S = <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>, T = <span class="hljs-number">2</span> * n + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">add</span>(i, i + n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">1</span>)  <span class="hljs-built_in">add</span>(S, i, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (dp[i] == ans1)  <span class="hljs-built_in">add</span>(i + n, T, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (dp[j] == dp[i] + <span class="hljs-number">1</span> &amp;&amp; a[i] &lt;= a[j])<br>                <span class="hljs-built_in">add</span>(i + n, j, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">int</span> ans2 = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans2);<br><br><span class="hljs-comment">/* ====================================== */</span><br>    <br>    <span class="hljs-comment">// 特殊处理四种边，直接增广</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i++) &#123;<br>        <span class="hljs-type">int</span> u = e[i ^ <span class="hljs-number">1</span>], v = e[i];<br>        <span class="hljs-keyword">if</span> (u == S &amp;&amp; v == <span class="hljs-number">1</span>)   w[i] = INF;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">1</span> &amp;&amp; v == n + <span class="hljs-number">1</span>)   w[i] = INF;<br>        <span class="hljs-keyword">if</span> (u == n &amp;&amp; v == n + n)   w[i] = INF;<br>        <span class="hljs-keyword">if</span> (u == n + n &amp;&amp; v == T)   w[i] = INF;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> ans3 = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans2 + ans3);  <span class="hljs-comment">// 加上增广前的最大流</span><br>    <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 网络流24题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】圆桌问题</title>
      <link href="/post/3f3901b7.html"/>
      <url>/post/3f3901b7.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p>题目链接： <a href="https://www.luogu.com.cn/problem/P3254">https://www.luogu.com.cn/problem/P3254</a></p><br><h2 id="题目描述">题目描述</h2><p>有来自 m 个不同单位的代表参加一次国际会议。第 i 个单位派出了 ri 个代表。</p><p>会议的餐厅共有 n 张餐桌，第 i 张餐桌可容纳 ci 个代表就餐。</p><p>为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。</p><p>请给出一个满足要求的代表就餐方案。</p><br><h2 id="分析">分析</h2><font size="4"> <p>与“飞行员配对方案问题”很像</p><p>属于网络流的二分图匹配问题。</p></font><br><p><strong>建图：</strong></p><p>根据流网络的定义，先建立源点S和汇点T。</p><ul><li>源点到每个单位连一条容量为 ri 的边 ，限制每个单位有 ri 个人。</li><li>每个公司到每个桌子连一条容量为1的边 ，限制每桌每个单位只能坐一个人。</li><li>每个桌子到汇点连一条容量为 ci 的边 ，限制每个桌子最多坐 ci 个人。</li></ul><p>可以发现，整个流网络中的可行流满足容量限制和流量守恒。</p><p>所以任意一个可行流都是一个满足题意的解</p><p>如果最大流就是 $∑ri$ 的话，就说明所有的单位里的人都找到一个不同的位置坐。</p><p>也就是可以找到满足题目要求的方案，输出1。</p><br><h2 id="输出方案">输出方案</h2><p>枚举所有左右两个集合之间的边，看哪条边的流量是满的</p><p>流量满则意味着这是一组可行的匹配</p><p>有很多种处理的方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 姿势一</span><br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= m; u++) &#123;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j &gt; m &amp;&amp; j &lt;= m + n &amp;&amp; !w[i])<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, j - m);<span class="hljs-comment">// 映射回去</span><br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">// 姿势二</span><br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; mp;<br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i += <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-type">int</span> v = e[i], u = e[i ^ <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (v &gt; m &amp;&amp; v &lt;= m + n &amp;&amp; !w[i])<br>        mp[u].<span class="hljs-built_in">pb</span>(v - m);<span class="hljs-comment">// 映射回去</span><br>&#125;<br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : mp[i])<br>        cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="code">Code</h2><p><strong>完整的代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">500</span> + <span class="hljs-number">10</span>, M = (<span class="hljs-number">150</span> * <span class="hljs-number">270</span> +N) * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;m, &amp;n);<br>    S = <span class="hljs-number">0</span>, T = m + n + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-comment">// 建图</span><br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> r;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;r);<br>        <span class="hljs-built_in">add</span>(S, i, r);<br>        tot += r;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> c;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;c);<br>        <span class="hljs-built_in">add</span>(m + i, T, c);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)  <br>            <span class="hljs-built_in">add</span>(i, m + j, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 判断是否可以找到满足题意的方案</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span> (ans != tot) &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 输出方案</span><br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= m; u++) &#123;<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (j &gt; m &amp;&amp; j &lt;= m + n &amp;&amp; !w[i])<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, j - m);<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 网络流24题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】飞行员配对问题</title>
      <link href="/post/85b494b8.html"/>
      <url>/post/85b494b8.html</url>
      
        <content type="html"><![CDATA[<font size="3"><meta name="referrer" content="no-referrer"><p>题目链接： <a href="https://www.luogu.com.cn/problem/P2756">https://www.luogu.com.cn/problem/P2756</a></p><h2 id="题目描述">题目描述</h2><p>一共有 n 个飞行员，其中有 m 个外籍飞行员和 (n−m) 个英国飞行员</p><p>外籍飞行员从 1 到 m 编号，英国飞行员从 m+1 到 n 编号</p><p>对于给定的外籍飞行员与英国飞行员的配合情况，找出最佳飞行员配对方案。</p><p><strong>一句话：</strong></p><p><strong>m 个外籍和 n-m 个英国飞行员两两配对，问最大匹配数和匹配方案</strong></p><br><h2 id="分析">分析</h2><font size="4"> <p>很明显的二分图最大匹配模型。</p></font><p>对于二分图的最大匹配问题：</p><ul><li><p>匈牙利算法的时间复杂度是$O(nm)$</p></li><li><p>Dinic算法的时间复杂度是$O(m\sqrt{n})$</p></li></ul><p>匈牙利算法是每次只找一条增广路的最大流算法。</p><p><strong>所以匈牙利算法本质上就是 EK算法</strong></p><br><p><strong>建图：</strong></p><p>根据流网络的定义，先建立源点S和汇点T。</p><ul><li>从源点S向所有外籍飞行员建立一条容量为1的边</li><li>从所有外籍飞行员向其可搭档的英国飞行员建立一条容量为1的边</li><li>从所有英国飞行员向汇点T建立一条容量为1的边。</li></ul><p>可以发现，整个流网络中的可行流满足容量限制和流量守恒。</p><p>所以任意一个可行流都是一个满足题意的解</p><p>那么，整个流网络中的最大流便是最大匹配方案</p><br><h2 id="输出方案">输出方案</h2><p>枚举所有左右两个集合之间的边，看哪条边的流量是满的</p><p>流满则意味着这是一组可行的匹配</p><p>有很多种处理的方式，下面是其中一种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 枚举所有的正向边</span><br><span class="hljs-comment">// 因为存图时我们成对存储，所以偶数的边就是正向边</span><br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i += <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// 两个端点</span><br>    <span class="hljs-type">int</span> v = e[i], u = e[i ^ <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 如果两个端点分别在两个集合中 并且这条边的流量已满</span><br>    <span class="hljs-keyword">if</span> (v &gt; m &amp;&amp; v &lt;= n &amp;&amp; !w[i])<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>, u, v);<span class="hljs-comment">// 输出方案</span><br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="code">Code</h2><p><strong>完整的代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">500</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">6000</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T) <span class="hljs-keyword">return</span> limit;<br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;<br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow)); <br>            <span class="hljs-keyword">if</span> (!t) d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">if</span> (flow == <span class="hljs-number">0</span>)  d[u] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;m, &amp;n);<br>    S = <span class="hljs-number">0</span>, T = n + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 建图</span><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-built_in">add</span>(S, i, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = m + <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">add</span>(i, T, <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-type">int</span> a, b;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b), a != <span class="hljs-number">-1</span> &amp;&amp; b != <span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">add</span>(a, b, <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">// 求最大流</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">dinic</span>());<br><br>    <span class="hljs-comment">// 输出方案</span><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx; i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> v = e[i], u = e[i ^ <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (v &gt; m &amp;&amp; v &lt;= n &amp;&amp; !w[i])<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>, u, v); <br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></font><br>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 网络流24题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ACM】网络流-最大流</title>
      <link href="/post/8448711d.html"/>
      <url>/post/8448711d.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>要求：</p><p>给定一个有向带权图，其中有两个特殊的点源S（Sources）和汇T（Sinks）</p><p>每条边有指定的容量（Capacity），求满足条件的从S到T的最大流（MaxFlow）</p><p>本篇内容都基于：<a href="https://www.bilibili.com/video/BV1K64y1C7Do/">https://www.bilibili.com/video/BV1K64y1C7Do/</a></p><h2 id="基本理解">基本理解</h2><p>我们可以这样理解最大流问题：</p><ul><li><p>我们希望把水从起点 S 送到终点 T ，水要通过一些管道来输送，这些管道就是途图中的边。</p></li><li><p>边都有权重，即管道的容量，送水量不能超过管道的容量。</p></li><li><p>给定管道的限制，请问水的最大流量是多少。</p></li></ul><p><font size="4"><strong>我们先了解一种简单但是不能保证正确性的算法</strong></font></p><h2 id="naive-algorithm">Naive Algorithm</h2><p><strong>首先我们先了解什么是增广路径</strong></p><p>增广路就是从起点 S 出发，经过容量大于零的边，到达终点 T 的简单路径（无环）</p><p>我们只考虑基于原图构造的 <strong>Residual Graph</strong>，即边权为空闲量的图（残留网络）</p><p>初始时，由于没有水流经过，残留网络就是原图。</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210104305479.png" alt="image-20221210104305479"></p><p>当可以找到增广路径时我们循环进行以下操作</p><ul><li>先找到一条从起点 S 到终点 T 的增广路</li><li>找到此条路经的最小权重 x</li><li>路径上的边权（空闲量）都减去 x</li></ul><p><strong>但是这种算法会根据选择路径的顺序造成不同的答案，不能保证找到的一定是最大流，只能保证找到一个阻塞流 (Blocking Flow)。</strong></p><p>所以我们需要稍微复杂的算法来解决最大流的问题</p><h2 id="ford-fulkerson-algorithm">Ford-Fulkerson Algorithm</h2><p>Ford-Fulkerson 算法，由 Ford 和 Fulkerson 两人在 1956 年提出，这种算法可以保证找到最大流。</p><p><font color="#004a97">最坏情况下，算法的时间复杂度是 $O(f m)$，$f$ 是最大流的大小，$m$ 是边的数量。</font></p><p>观察发现简单算法的缺陷是算法不能反悔，不能纠错，一旦坏的路径被找到算法就不能找到最大流。</p><p>而Ford-Fulkerson 算法可以”反悔“，将坏的路径撤销。</p><p>依旧是仅考虑 <strong>Residual Graph</strong></p><p>与简单算法很像，当可以找到增广路时我们循环进行以下操作：</p><ul><li><p>在当前的残留网络中找增广路</p></li><li><p>更新当前的残留网络</p><ul><li><p>找到此条路经的最小权重 x</p></li><li><p>路径上的边权（空闲量）都减去 x</p></li><li><p><font color="red">添加一条权重为 x 的反向路径</font></p></li></ul></li></ul><p><strong>过程中，我们可以通过添加反向边来”纠错“。</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210105509117.png" alt="image-20221210105509117"></p><br><h2 id="edmonds-karp-algorithm">Edmonds-Karp Algorithm</h2><p>因为Ford-Fulkerson 算法的复杂度依赖最大流的大小，最坏情况下可能会很大，所以我们常把Ford-Fulkerson 算法叫做<strong>FF方法</strong>，把它当作解决最大流问题的一个核心思路，在此基础上进行不同的实现方法。</p><p>下面我们了解一个新的算法——Edmonds-Karp 算法，由 Edmonds 和 Karp 两人在 1972 年提出。</p><p>我们可以把 EK算法理解为 FF方法的一种具体实现方式，一定能找到最大流。</p><p><font size="4"><strong>核心在于 Edmonds-Karp 算法在寻找简单路径时要使用最短路算法：</strong></font></p><ul><li>寻找最短路的时候，把图当做无权图，也就是边的权重都是1。</li></ul><p><font size="4">可以想到，用基础的bfs就可以解决。</font></p><p><font color="#004a97">最坏情况下，算法的时间复杂度是 $O(nm^2)$</font></p><br><h3 id="如何存图呢">如何存图呢</h3><p>我们发现，算法的实现过程中需要<strong>快速的找到某条边的反向边</strong></p><p>所以在用<strong>链式前向星</strong>加边的时候，我们把正向边和反向边成对连续添加。</p><p>那么第 i 条边的反向边实际就是第 i ^ 1 条边。</p><p>在记录路径时，我们用 pre[] 数组记录当前点的<strong>前驱边</strong></p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210220602561.png" alt="image-20221210220602561"></p><p>如上图，假设我们此时找到了点v</p><p>edge1实际就是 pre[i]，反向边edge2就是 pre[i] ^ 1</p><p>而点 u 就是 e[pre[i] ^ 1]。</p><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P3376</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">20010</span>, INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, zz[N][N], d[N], pre[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(st));<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), st[S] = <span class="hljs-literal">true</span>, d[S] = INF;<br>    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (st[j] || !w[i]) <span class="hljs-keyword">continue</span>;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            d[j] = <span class="hljs-built_in">min</span>(d[t], w[i]);<br>            pre[j] = i;<span class="hljs-comment">// 这里记录的实际是前驱边</span><br>            <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">EK</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        ans += d[T];<span class="hljs-comment">// 这里就是我们存图的技巧</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>])<br>            w[pre[i]] -= d[T], w[pre[i] ^ <span class="hljs-number">1</span>] += d[T];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        zz[a][b] += c;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (zz[i][j])   <span class="hljs-built_in">add</span>(i, j, zz[i][j]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">EK</span>());<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="dinic-algorithm">Dinic Algorithm</h2><p>Dinic 算法，它由 Dinitz 在 1970 年提出。</p><p><font color="#004a97">最坏情况下，算法的时间复杂度是 $O(mn^2)$</font></p><p>Ek算法每次在残留网络中找一条增广路，而Dinic算法则是每次找到尽量多的增广路。</p><p>为了防止在找增广路时出现环，我们引入分层图的概念。</p><p>首先了解什么是<strong>Level Graph：</strong></p><p>我们把从起点走x步可以到达的点看作一层，<strong>Level Graph</strong> 就是只保留相邻层之间的边的图，是原图的一个子图，且一点没有环。</p><p>下面左图就是右图（原图）的分层图，使用 bfs 即可做到。</p><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210113123903.png" alt="image-20221210113123903"></p><p>算法的流程如下：</p><p>1、先构造残留网（边权为空闲量的图）</p><p>2、然后我们进行以下循环：</p><ul><li>构造残留网络的 Leval Graph（bfs）</li><li>在构造的 Leval Graph 中（下面的左图）寻找所有的增广路径</li></ul><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210113843073.png" alt="image-20221210113843073"></p><ul><li>然后我们更新右图，在残留网络中减去 Leval Graph 的流量，再添加反向边</li></ul><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221210114211420.png" alt="image-20221210114211420"></p><br><h3 id="当前弧优化">当前弧优化</h3><p>如果某条边在搜索的时候已经满了，那么我们可以跳过这条边，从下一条边开始搜。</p><br><h3 id="code">Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// https://www.luogu.com.cn/problem/P3376</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 判断是否含有增广路</span><br><span class="hljs-comment">// 有则返回true，并且构造分层图</span><br><span class="hljs-comment">// 没有则返回false</span><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T)<span class="hljs-keyword">return</span> limit;<br>    <br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;  <span class="hljs-comment">// 当前弧优化</span><br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow));<br>            <span class="hljs-keyword">if</span> (!t)d[ver] = <span class="hljs-number">-1</span>;<span class="hljs-comment">// 残枝优化</span><br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">dinic</span>());<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="时间复杂度">时间复杂度</h2><p>由于一些奇怪的原因，最大流算法中的时间复杂度上限很宽松</p><p><strong>实际运行速度远比理论上的要好很多。</strong></p><p>所以 EK算法 实际上大致可以解决1000~10000的点</p><p>Dinic算法 则大致可以解决10000~100000的点</p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Template-Math</title>
      <link href="/post/ecb77944.html"/>
      <url>/post/ecb77944.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221209135823540.png" alt="image-20221209135823540"></p><p><font size="5" color="#004a97"><strong>数学</strong></font></p><br><h2 id="__int128">__int128</h2><p><strong>从招招那里抄的kuangbin模板。</strong></p><p>范围：$$[-2^{127}, 2^{127}]\space  约10^{38}$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> __int128 <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    __int128 x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>)  f = <span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(__int128 x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        x = -x;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">9</span>)  <span class="hljs-built_in">print</span>(x / <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    __int128 a = <span class="hljs-built_in">read</span>();<br>    __int128 b = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">print</span>(a + b);<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="最大公约数">最大公约数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="最小公倍数">最小公倍数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a / <span class="hljs-built_in">gcd</span>(a, b) * b;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="筛质数">筛质数</h2><h3 id="埃筛">埃筛</h3><p><font color="#004a97">时间复杂度 $O(nloglogn)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> isprime[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>        isprime[i] = <span class="hljs-literal">true</span>;            <span class="hljs-comment">// 先全部置为真</span><br>    isprime[<span class="hljs-number">0</span>] = isprime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 1 0 不是素数</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (isprime[i])<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= n; j += i)<br>                isprime[j] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span> (isprime[i]) &#123;<br>            cnt++;             <span class="hljs-comment">// 素数的个数</span><br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出该素数</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; endl &lt;&lt; cnt;  <span class="hljs-comment">// 输出总个数</span><br></code></pre></td></tr></table></figure><br><h3 id="线性筛">线性筛</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pirme</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>            p[cnt++] = i;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; p[j] &lt;= n / i; j++) &#123;<br>            st[p[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="快速幂">快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)  ans = a * ans % p;<br>        a = a * a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 逆元</span><br><span class="hljs-built_in">test</span>(n, mod - <span class="hljs-number">2</span>, mod)<br></code></pre></td></tr></table></figure><br><h2 id="快速乘">快速乘</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)  ans = (ans + a) % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>        a = (a * <span class="hljs-number">2</span>) % mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="欧拉函数">欧拉函数</h2><p><font size="4">1 ~ N 中与 N 互质的数</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i++) &#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;<br>            res = res / i * (i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>                x /= i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>)  res = res / x * (x - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-comment">// 筛法欧拉函数</span><br><span class="hljs-comment">// 求 1 - N 中每个数的欧拉函数之和</span><br><span class="hljs-type">int</span> p[N], cnt, e[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function">ll <span class="hljs-title">get_eulars</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    e[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) &#123;<br>            p[cnt++] = i;<br>            e[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; p[j] &lt;= n / i; j++) &#123;<br>            <span class="hljs-type">int</span> t = p[j] * i;<br>            st[t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) &#123;<br>                e[t] = e[i] * p[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            e[t] = e[i] * (p[j] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)ans += e[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="组合数">组合数</h2><p>$$C_a^b\ mod\ (1e9+7)$$</p><h3 id="姿势一">姿势一</h3><p>范围：</p><p>$$1≤b≤a≤2000$$</p><p>解法：</p><p>$$C_a^b=C_{a-1}^{b-1}+C_{a-1}^b$$</p><p><font color="#004a97">时间复杂度 $O(n^2)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2022</span>;<br><span class="hljs-type">int</span> n, p = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> C[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)<br>                C[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                C[i][j] = (C[i - <span class="hljs-number">1</span>][j] + C[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % p;<br>        &#125;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        cout &lt;&lt; C[a][b] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="姿势二">姿势二</h3><p>范围：</p><p>$$1≤b≤a≤10^5$$</p><p>解法：</p><p>$$C_a^b=\frac{a!}{b!(a-b)!}$$</p><p><font color="#004a97">时间复杂度 $O(a*log(mod))$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> fact[N], infact[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> mod)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b)&#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)  ans = ans * a % mod;<br>        a = a * a % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)&#123;<br>        fact[i] = fact[i - <span class="hljs-number">1</span>] * i % mod;<br>        infact[i] = infact[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">qmi</span>(i, mod - <span class="hljs-number">2</span>, mod) % mod;<br>    &#125;<br><br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--)&#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-type">int</span> ans = fact[a] * infact[a - b] % mod * infact[b] % mod;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%intd\n&quot;</span>, ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="姿势三">姿势三</h3><p>范围：</p><p>$$1≤b≤a≤10^{18},\ 1≤p≤10^5$$</p><p>解法：</p><p><strong>卢卡斯定理</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)  res = res * a % p;<br>        a = (<span class="hljs-type">int</span>)a * a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b &gt; a)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = a; i &lt;= b; i++, j--) &#123;<br>        res = (<span class="hljs-type">int</span>)res * j % p;<br>        res = (<span class="hljs-type">int</span>)res * <span class="hljs-built_in">qmi</span>(i, p - <span class="hljs-number">2</span>, p) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a, b, p);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)<span class="hljs-built_in">C</span>(a % p, b % p, p) * <span class="hljs-built_in">lucas</span>(a / p, b / p, p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-type">int</span> a, b, p;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>        cout &lt;&lt; <span class="hljs-built_in">lucas</span>(a, b, p) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>卢卡斯 + 预处理</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, p, a[N], dp[N], sz[N], fact[N], infact[N];<br><br><span class="hljs-function">ll <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    ll res = <span class="hljs-number">1</span> % p;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)  res = res * a % p;<br>        a = (ll)a * a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> fact[a] * infact[a - b] % p * infact[b] % p;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(ll a, ll b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; p &amp;&amp; b &lt; p)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a, b, p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a % p, b % p, p) * <span class="hljs-built_in">lucas</span>(a / p, b / p, p) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; p;<br><br>    fact[<span class="hljs-number">0</span>] = infact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        fact[i] = fact[i - <span class="hljs-number">1</span>] * i % p;<br>        infact[i] = infact[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">qmi</span>(i, p - <span class="hljs-number">2</span>, p) % p;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        sz[i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">2</span>; i--)<br>        sz[i &gt;&gt; <span class="hljs-number">1</span>] += sz[i];<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = n; i &lt;= <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>; i++)<br>        dp[i] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-type">int</span> a = sz[i] - <span class="hljs-number">1</span>, b = sz[i &lt;&lt; <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">lucas</span>(a, b, p);<br>        dp[i] = num % p * dp[i &lt;&lt; <span class="hljs-number">1</span>] % p * dp[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] % p;<br>    &#125;<br><br>    cout &lt;&lt; dp[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="整除分块">整除分块</h2><p>抄招招的模板<img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221209150128352.png" alt="image-20221209150128352"></p><p>$$\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 下取整</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getdown</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r, len; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>        r = n / (n / l), len = r - l + <span class="hljs-number">1</span>;<br>        ans += len * (n / l);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 上取整</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getup</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r, len; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>        r = n / (n / l), len = r - l + <span class="hljs-number">1</span>;<br>        ans += len * (n / l + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (n % r == <span class="hljs-number">0</span>) ans -= r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="正方形长方形">正方形长方形</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> ta = n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> tb = m * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> all = ta * tb;<br>    <span class="hljs-type">int</span> zh = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">min</span>(n, m); i++) &#123;<br>        zh += (m - i + <span class="hljs-number">1</span>) * (n - i + <span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; zh &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; all - zh &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="博弈论">博弈论</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 巴什博弈</span><br>只有一堆，n个物品，两个人轮流从这堆物品中取物<br>规定每次至少取一个，最多取m个。最后取光者得胜。<br><br>结论：<br>若 n % (m + <span class="hljs-number">1</span>) = <span class="hljs-number">0</span>，则先手必败。<br>否则先手必胜。<br><br><br><br><span class="hljs-comment">// 尼姆博弈</span><br>有n堆各若干个物品，两个人轮流从某一堆取任意多的物品<br>规定每次至少取一个，多者不限，最后取光者得胜。<br><br>结论：<br>若 a1^a2^...^an = <span class="hljs-number">0</span>，则先手必败。<br>否则先手必胜。<br></code></pre></td></tr></table></figure><br><h2 id="矩阵ksm">矩阵ksm</h2><br><h2 id="线性基">线性基</h2><br>]]></content>
      
      
      <categories>
          
          <category> ACM-Template </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Template-Graph</title>
      <link href="/post/70dc2d05.html"/>
      <url>/post/70dc2d05.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221208195445408.png" alt="image-20221208195445408"></p><p><font size="5" color="#004a97"><strong>图论</strong></font></p><br><h2 id="最短路">最短路</h2><h3 id="朴素dijkstra">朴素Dijkstra</h3><p><font color="#004a97">时间复杂度 $O(n^2)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用邻接矩阵储存，适用于稠密图</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n, m;             <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> g[N][N], dis[N];  <span class="hljs-comment">// g表示邻接矩阵，dis表示每个点到起点的距离</span><br><span class="hljs-type">bool</span> used[N];         <span class="hljs-comment">// 记录某个点是否被使用过</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br>    dis[s] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (!used[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dis[t] &gt; dis[j]))   t = j;<br><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">-1</span>)    <span class="hljs-keyword">break</span>;<br><br>        used[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            dis[j] = <span class="hljs-built_in">min</span>(dis[j], dis[t] + g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dis[n] == <span class="hljs-number">0x3f3f3f3f</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> dis[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(g));<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-comment">// 存在重边和自环时，仅需处理最短的边即可</span><br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="堆优化dijkstra">堆优化Dijkstra</h3><p><font color="#004a97">时间复杂度 $O((n+m) logn)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> n, m, dist[N];<br><span class="hljs-type">bool</span> used[N];  <span class="hljs-comment">// 记录某个点是否被使用过</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[s] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br><br>    <span class="hljs-keyword">while</span> (!heap.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (used[ver])  <span class="hljs-keyword">continue</span>;<br>        used[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i]) &#123;<br>                dist[j] = dist[ver] + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] &gt;= <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="bellman-ford">Bellman-ford</h3><p><font color="#004a97">时间复杂度 $O(nm)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">10010</span>;<br><br><span class="hljs-type">int</span> n, m, k, dis[N], last[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123; <span class="hljs-type">int</span> a, b, c; &#125; edges[M];   <span class="hljs-comment">// 结构体存边</span><br><br><span class="hljs-comment">// 从起点s出发到任一点n的最短距离,限制最多经过k条边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br><br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++ ) &#123;<br>        <span class="hljs-built_in">memcpy</span>(last, dis, <span class="hljs-keyword">sizeof</span> dis);<span class="hljs-comment">// 备份数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ ) &#123;<br>            <span class="hljs-keyword">auto</span> e = edges[j];<br>            dis[e.b] = <span class="hljs-built_in">min</span>(dis[e.b], last[e.a] + e.c);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 不加边数限制的最短路</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford2</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;                  <span class="hljs-comment">// for (int k = 1; k &lt;= n - 1; k++)</span><br>        <span class="hljs-type">bool</span> update = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 正常情况下外循环最多进行 n - 1 次即可</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">auto</span> t = edges[i];<br>            <span class="hljs-keyword">if</span> (dis[t.a] != <span class="hljs-number">0x3f3f3f3f</span> &amp;&amp; dis[t.b] &gt; dis[t.a] + t.c)<br>                dis[t.b] = dis[t.a] + t.c, update = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!update) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// bellman_ford 判断是否存在负环</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_negative_loop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dis);<br>    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">auto</span> t = edges[j];<br>            <span class="hljs-keyword">if</span> (dis[t.b] &gt; dis[t.a] + t.c) &#123;<br>                dis[t.b] = dis[t.a] + t.c;<br>                <span class="hljs-comment">// 如果第 n 次仍然更新了，则存在负环</span><br>                <span class="hljs-keyword">if</span>(i == n)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="spfa">SPFA</h3><p><font color="#004a97">谜之时间复杂度</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> n, m, dist[N], cnt[N];<br><span class="hljs-type">bool</span> st[N];  <span class="hljs-comment">// 判断当前点是否在队列之中，防止队列中有重复的点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 队列里只存距离变小了的点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[s] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s); st[s] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-comment">// SPFA 判断是否存在负环</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find_negative_loop</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(st));<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    dis[s] = <span class="hljs-number">0</span>, st[s] = <span class="hljs-literal">true</span>;<br>    q.<span class="hljs-built_in">push</span>(s);<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>(); st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])&#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dis[j] &gt; dis[t] + w[i])&#123;<br>                dis[j] = dis[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (!st[j])&#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="floyd">Floyd</h3><p><font color="#004a97">时间复杂度 $O(n^3)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Floyd算法是基于动态规划的原理</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>, INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">int</span> n, m, Q;<br><span class="hljs-type">int</span> d[N][N];  <span class="hljs-comment">// d[i][j]表示从点i到点j的最短距离</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span>    d[i][j] = INF;<br>        &#125;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        d[a][b] = <span class="hljs-built_in">min</span>(d[a][b], c);<br>    &#125;<br><br>    <span class="hljs-built_in">floyd</span>();<br><br>    <span class="hljs-keyword">while</span> (Q--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br><br>        <span class="hljs-type">int</span> t = d[a][b];<br>        <span class="hljs-keyword">if</span> (t &gt; INF / <span class="hljs-number">2</span>)    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="传递闭包">传递闭包</h3><p><font color="#004a97">使用Floyd解决，时间复杂度 $O(n^3)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">350</span>;<br><span class="hljs-type">int</span> n, m, d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) d[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> x, y;   cin &gt;&gt; x &gt;&gt; y;<br>        d[x][y] = d[y][x] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                d[i][j] |= d[i][k] &amp; d[k][j];<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="记录路径">记录路径</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以朴素dijkstra为例，记录一个path数组，当dist数组被更新时，就同步更新path数组。</span><br><span class="hljs-type">int</span> g[maxn][maxn];<br><span class="hljs-type">int</span> st[maxn], dist[<span class="hljs-number">500010</span>];<br><span class="hljs-type">int</span> path[<span class="hljs-number">500010</span>];  <span class="hljs-comment">// 记录走来的路径</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">memset</span>(path, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> path);<br><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br>        &#125;<br><br>        st[t] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + g[t][j]) &#123;<br>                dist[j] = dist[t] + g[t][j];<br>                path[j] = t;  <span class="hljs-comment">// 记录</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_path</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; p;<br>    <span class="hljs-keyword">for</span> (; x != <span class="hljs-number">-1</span>; x = path[x])<br>        p.<span class="hljs-built_in">push_back</span>(x);<br>    <span class="hljs-comment">// p中存下的是n到1的顺序，我们逆反一下顺序。</span><br>    <span class="hljs-built_in">reverse</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            g[i][j] = (i == j) ? <span class="hljs-number">0</span> : INF;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-built_in">dijkstra</span>() &lt;&lt; endl;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; p = <span class="hljs-built_in">get_path</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : p)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, it);<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="最短路计数">最短路计数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> cnt[maxn];  <span class="hljs-comment">// 长度为i的路径的数量</span><br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;  <span class="hljs-comment">// 以bfs为例</span><br>    <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : G[t]) &#123;<br>        <span class="hljs-keyword">if</span> (dist[it] &gt; dist[t] + <span class="hljs-number">1</span>) &#123;<br>            dist[it] = dist[t] + <span class="hljs-number">1</span>;<br>            cnt[it] = cnt[t];<br>            q.<span class="hljs-built_in">push</span>(it);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dist[it] == dist[t] + <span class="hljs-number">1</span>)<br>            cnt[it] = (cnt[it] + cnt[t]) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="最小生成树">最小生成树</h2><h3 id="kruskal">Kruskal</h3><p><font color="#004a97">时间复杂度 $O(mlogm)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>, M = <span class="hljs-number">500010</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m, p[N];<br><br><span class="hljs-comment">// 结构体存边</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123; <span class="hljs-type">int</span> a, b, w; &#125; edges[M]；<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge&amp; a, Edge&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.w &lt; b.w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)  p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m, cmp);<br><br>    <span class="hljs-comment">// 初始化并查集</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    p[i] = i;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br><br>        <span class="hljs-keyword">if</span> (a != b) &#123;<br>            p[a] = b;   <span class="hljs-comment">// 合并集合</span><br>            res += w;   <span class="hljs-comment">// 记录总长</span><br>            cnt++;      <span class="hljs-comment">// 记录边数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果加的边小于n-1, 则原图不连通, 无法构造最小生成树</span><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);<br>        edges[i] = &#123;a, b, w&#125;;<br>    &#125;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">kruskal</span>();<br><br>    <span class="hljs-keyword">if</span> (t == INF)   <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="prim">Prim</h3><p><font color="#004a97">时间复杂度 $O(n^2)$   </font></p><p>适用于稠密图，尤其完全图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m, g[N][N], dist[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))   t = j;<br><br>        <span class="hljs-keyword">if</span> (dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br><br>        res += dist[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b], c);<br>    &#125;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">prim</span>();<br>    <span class="hljs-keyword">if</span> (t == INF)   <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="tarjan">Tarjan</h2><p>有向图至少加多少条边可以变成强连通分量：</p><p>$$max(p,q)\quad \quad ——\ p,q 分别是出度为零和入度为零的点$$</p><br><p>无向图至少加多少条边可以变成边双连通分量：</p><p>$$\lfloor\frac{cnt+1}{2}\rfloor\quad \quad——\ cnt 是缩点以后叶子节点的个数$$</p><br><h3 id="有向图的强连通分量">有向图的强连通分量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>, M = <span class="hljs-number">50010</span>;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> dfn[N], low[N], timetmp;<br><span class="hljs-type">int</span> id[N], scc_cnt, sz[N];<br><span class="hljs-type">int</span> n, m, dout[N];<br><span class="hljs-type">bool</span> st[N];<br>stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    dfn[u] = low[u] = ++timetmp;<br>    stk.<span class="hljs-built_in">push</span>(u), st[u] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dfn[j]) &#123;<br>            <span class="hljs-built_in">tarjan</span>(j);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st[j]) low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[j]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dfn[u] == low[u]) &#123;<br>        ++scc_cnt;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">do</span> &#123;<br>            tmp = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>(), st[tmp] = <span class="hljs-literal">false</span>;<br>            id [tmp] = scc_cnt;<br>            sz[scc_cnt]++;<br>        &#125; <span class="hljs-keyword">while</span>(tmp != u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (!dfn[i])    <span class="hljs-built_in">tarjan</span>(i);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = h[i]; ~j; j = ne[j]) &#123;<br>            <span class="hljs-type">int</span> k = e[j];<br>            <span class="hljs-type">int</span> a = id[i], b = id[k];<br>            <span class="hljs-keyword">if</span> (a != b) dout[a]++;<br>        &#125;<br>    <span class="hljs-type">int</span> zeros = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= scc_cnt; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!dout[i])   zeros++, ans = sz[i];<br>        <span class="hljs-keyword">if</span> (zeros &gt; <span class="hljs-number">1</span>)  ans = <span class="hljs-number">0</span>, i = scc_cnt;<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="无向图的边双连通分量">无向图的边双连通分量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, dfn[N], low[N];<br><span class="hljs-type">int</span> dcc_cnt, timetmp;<br>stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>vector&lt;<span class="hljs-type">int</span>&gt; zz[M];<br><span class="hljs-type">bool</span> is[M];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fr)</span> </span>&#123;<br>    dfn[u] = low[u] = ++timetmp;<br>    stk.<span class="hljs-built_in">push</span>(u);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dfn[j]) &#123;<br>            <span class="hljs-built_in">tarjan</span>(j, i);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>            <span class="hljs-keyword">if</span> (low[j] &gt; dfn[u])    is[i] = is[i ^ <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != (fr ^ <span class="hljs-number">1</span>))     low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[j]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dfn[u] == low[u]) &#123;<br>        ++dcc_cnt;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">do</span> &#123;<br>            tmp = stk.<span class="hljs-built_in">top</span>();    stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// id[tmp] = dcc_cnt;</span><br>            zz[dcc_cnt].<span class="hljs-built_in">pb</span>(tmp);<br>        &#125; <span class="hljs-keyword">while</span> (tmp != u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (!dfn[i])    <span class="hljs-built_in">tarjan</span>(i, i);<br>    <br>    cout &lt;&lt; dcc_cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= dcc_cnt; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, zz[i].<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : zz[i])    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, x);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="无向图的点双连通分量">无向图的点双连通分量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">4</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, root, dcc_cnt;<br><span class="hljs-type">int</span> dfn[N], low[N], timetmp;<br><span class="hljs-type">bool</span> cut[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; zz[N];<br>stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    dfn[u] = low[u] = ++timetmp;<br>    stk.<span class="hljs-built_in">push</span>(u);<br><br>    <span class="hljs-keyword">if</span> (u == root &amp;&amp; h[u] == <span class="hljs-number">-1</span>) &#123;<br>        zz[++dcc_cnt].<span class="hljs-built_in">pb</span>(u);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dfn[j]) &#123;<br>            <span class="hljs-built_in">tarjan</span>(j);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[j]);<br>            <span class="hljs-keyword">if</span> (dfn[u] &lt;= low[j]) &#123;<br>                cnt++;<br>                <span class="hljs-keyword">if</span> (u != root || cnt &gt; <span class="hljs-number">1</span>)   cut[u] = <span class="hljs-literal">true</span>;<br>                ++dcc_cnt;<br>                <span class="hljs-type">int</span> tmp;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    tmp = stk.<span class="hljs-built_in">top</span>();    stk.<span class="hljs-built_in">pop</span>();<br>                    zz[dcc_cnt].<span class="hljs-built_in">pb</span>(tmp);<br>                &#125; <span class="hljs-keyword">while</span> (tmp != j);<br>                zz[dcc_cnt].<span class="hljs-built_in">pb</span>(u);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// 判自环</span><br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (root = <span class="hljs-number">1</span>; root &lt;= n; root++)<br>        <span class="hljs-keyword">if</span> (!dfn[root]) <span class="hljs-built_in">tarjan</span>(root);<br>    <br>    cout &lt;&lt; dcc_cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= dcc_cnt; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, zz[i].<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : zz[i])    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, x);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="lca">LCA</h2><h3 id="倍增lca">倍增LCA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxd = <span class="hljs-number">20</span>;    <span class="hljs-comment">// 估计一下就行</span><br><span class="hljs-type">int</span> ne[M], e[M], h[N], idx;<br><span class="hljs-type">int</span> n, m, p, a, b;<br><span class="hljs-type">int</span> dep[N], fa[N][maxd + <span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    dep[u] = dep[p] + <span class="hljs-number">1</span>;<br>    fa[u][<span class="hljs-number">0</span>] = p;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= n; i++)<br>        fa[u][i] = fa[fa[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dep[j])    <span class="hljs-built_in">dfs</span>(j, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dep[x] &lt; dep[y])    <span class="hljs-built_in">swap</span>(x, y);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxd; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (dep[fa[x][i]] &gt;= dep[y])<br>            x = fa[x][i];<br><br>    <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> x;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxd; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i])<br>            x = fa[x][i], y = fa[y][i];<br><br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(p, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">lca</span>(a, b));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="欧拉序lca">欧拉序LCA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> n, m, p;<br><span class="hljs-type">int</span> e[M], ne[M], h[M], w[M], idx;<br><span class="hljs-type">int</span> lo2[N];       <span class="hljs-comment">// 预处理log2[x]</span><br><span class="hljs-type">int</span> dfn[N], cnt;  <span class="hljs-comment">// 欧拉序</span><br><span class="hljs-type">int</span> f[N][<span class="hljs-number">50</span>];     <span class="hljs-comment">// RMQ中的数组</span><br><span class="hljs-type">int</span> first[N];     <span class="hljs-comment">// 第一次出现的位置</span><br><span class="hljs-type">int</span> dep[N];       <span class="hljs-comment">// 深度</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>    first[u] = ++cnt, dfn[cnt] = u;<br>    dep[cnt] = d;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == fa)    <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-built_in">dfs</span>(j, u, d + <span class="hljs-number">1</span>);<br>        dfn[++cnt] = u;  <span class="hljs-comment">// 回溯时也要加到序列里</span><br>        dep[cnt] = d;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)  <span class="hljs-comment">// 预处理log2</span><br>        lo2[i] = lo2[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++)  f[i][<span class="hljs-number">0</span>] = i;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lo2[cnt]; j++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= cnt; i++) &#123;<br>            <span class="hljs-type">int</span> a = f[i][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> b = f[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">if</span> (dep[a] &lt;= dep[b])   f[i][j] = b;<br>            <span class="hljs-keyword">else</span>    f[i][j] = b;<br>        &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(p, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 欧拉序</span><br>    <span class="hljs-built_in">init</span>();        <span class="hljs-comment">//  RMQ</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        l = first[l], r = first[r];<br>        <span class="hljs-keyword">if</span> (l &gt; r)  <span class="hljs-built_in">swap</span>(l, r);<br><br>        <span class="hljs-type">int</span> p = lo2[r - l + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a = f[l][p], b = f[r - (l &lt;&lt; p) + <span class="hljs-number">1</span>][p];<br>        <br>        <span class="hljs-keyword">if</span> (dep[a] &lt;= dep[b])   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dfn[a]);<br>        <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dfn[b]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="欧拉路径和欧拉回路">欧拉路径和欧拉回路</h2><p><strong>欧拉路径：</strong> 从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边通过且只通过一次。</p><p><strong>欧拉回路：</strong> 起点和终点相同的欧拉路</p><h3 id="对于无向图">对于无向图</h3><p>（所有的边必须都连通）</p><ul><li><p><strong>欧拉路径</strong>：度数为奇数的点只有0或2个</p></li><li><p><strong>欧拉回路</strong>：所有的点度数都为偶数</p></li></ul><br><h3 id="对于有向图">对于有向图</h3><p>（所有的边必须都连通）</p><ul><li><p><strong>欧拉路径</strong>：</p><ol><li>所有的点入度 = 出度</li><li><ul><li>有一个点出度 = 入度 + 1（起点）</li><li>有一个点入度 = 出度 + 1（终点</li><li>其它所有的点入度 = 出度</li></ul></li></ol></li><li><p><strong>欧拉回路</strong>：所有的点出度 = 入度</p></li></ul><br><h2 id="二分图">二分图</h2><h3 id="染色法判断二分图">染色法判断二分图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">200010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;  <span class="hljs-comment">// 邻接表存图</span><br><span class="hljs-type">int</span> color[N];                <span class="hljs-comment">// 1 和 2 两个颜色 </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 如果在染色过程中发生矛盾，则不是二分图</span><br><span class="hljs-comment">// 如果完美染色，则是二分图</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    color[u] = c;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!color[j]) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, <span class="hljs-number">3</span> - c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);  <span class="hljs-comment">// 双边</span><br>    &#125;<br><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 因为并不知道图是否连通，要对每个节点遍历一边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (!color[i]) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>)) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">if</span> (flag)   <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="匈牙利算法">匈牙利算法</h3><p>最小点覆盖 = 最大匹配</p><p>最大独立集 = n - 最大匹配</p><p>最小路径点覆盖 = n - 最大匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n1, n2, m;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> match[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j])) &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i))    res++;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="拓扑排序">拓扑排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> e[N], ne[N], h[N], idx;<br><span class="hljs-type">int</span> n, m, d[N], top[N], cnt;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (!d[i])  q.<span class="hljs-built_in">push</span>(i);<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();  q.<span class="hljs-built_in">pop</span>();<br>        top[cnt++] = t;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (--d[j] == <span class="hljs-number">0</span>)    q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);<br>        d[b]++;<br>        <span class="hljs-built_in">add</span>(a, b);<br>    &#125;<br>    <span class="hljs-type">bool</span> f = <span class="hljs-built_in">topsort</span>();<br><br>    <span class="hljs-keyword">if</span> (!f) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cout &lt;&lt; top[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="差分约束">差分约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs none">A = B     &lt;=&gt; A ≥ B B ≥ A   add(b, a, 0), add(a, b, 0);<br>A &lt; B     &lt;=&gt; B ≥ A + 1     add(a, b, 1);<br>A ≥ B     &lt;=&gt; A ≥ B         add(b, a, 0);<br>A &gt; B     &lt;=&gt; A ≥ B + 1     add(b, a, 1);<br>B ≥ A     &lt;=&gt; B ≥ A         add(a, b, 0);<br></code></pre></td></tr></table></figure><p>$x &gt;= 1$ 时，建立虚拟源点$x_0$  $(dist[x_0] = 0)$</p><p>即$x &gt;= x_0 + 1$   $add(x_0, x, 1);$</p><br><h2 id="网络流">网络流</h2><h3 id="最大流">最大流</h3><h4 id="edmonds-karp">Edmonds-Karp</h4><p><font color="#004a97">最坏情况下，算法的时间复杂度是 $O(nm^2)$</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">20010</span>, INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, zz[N][N], d[N], pre[N];<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(st));<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), st[S] = <span class="hljs-literal">true</span>, d[S] = INF;<br>    <br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (st[j] || !w[i]) <span class="hljs-keyword">continue</span>;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            d[j] = <span class="hljs-built_in">min</span>(d[t], w[i]);<br>            pre[j] = i;<span class="hljs-comment">// 这里记录的实际是前驱边</span><br>            <span class="hljs-keyword">if</span> (j == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">EK</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        ans += d[T];<span class="hljs-comment">// 这里就是我们存图的技巧</span><br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="hljs-number">1</span>])<br>            w[pre[i]] -= d[T], w[pre[i] ^ <span class="hljs-number">1</span>] += d[T];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, c;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        zz[a][b] += c;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (zz[i][j])   <span class="hljs-built_in">add</span>(i, j, zz[i][j]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">EK</span>());<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="dinic">Dinic</h4><p><font color="#004a97">最坏情况下，算法的时间复杂度是 $O(mn^2)$</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, S, T, cur[N], d[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>    e[idx] = a, w[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S), d[S] = <span class="hljs-number">0</span>, cur[S] = h[S];<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (d[j] == <span class="hljs-number">-1</span> &amp;&amp; w[i]) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                cur[j] = h[j];<br>                <span class="hljs-keyword">if</span> (j == T)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == T)<span class="hljs-keyword">return</span> limit;<br>    <br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;<br>        cur[u] = i;  <span class="hljs-comment">// 当前弧优化</span><br>        <span class="hljs-type">int</span> ver = e[i];<br>        <span class="hljs-keyword">if</span> (d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; w[i]) &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(ver, <span class="hljs-built_in">min</span>(w[i], limit - flow));<br>            <span class="hljs-keyword">if</span> (!t)d[ver] = <span class="hljs-number">-1</span>;<br>            w[i] -= t, w[i ^ <span class="hljs-number">1</span>] += t, flow += t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (flow = <span class="hljs-built_in">find</span>(S, INF))<br>            r += flow;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">dinic</span>());<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> ACM-Template </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Template-Data_structure</title>
      <link href="/post/24e496bb.html"/>
      <url>/post/24e496bb.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221208191918315.png" alt="image-20221208191918315"></p><p><font size="5" color="#004a97"><strong>数据结构</strong></font></p><br><h2 id="并查集">并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归回溯的过程中实现了路径压缩优化</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x)  p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="单调栈">单调栈</h2><p><font color="#004a97">时间复杂度 $O(n)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">check</span>(s.<span class="hljs-built_in">top</span>(), i))s.<span class="hljs-built_in">pop</span>();<br>    s.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="单调队列">单调队列</h2><p><font color="#004a97">时间复杂度 $O(n)$   </font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br>deque&lt;<span class="hljs-type">int</span>&gt; q;  <span class="hljs-comment">// q存放编号</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        cin &gt;&gt; a[i];<br><br>    q.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-comment">// 单调递增 求最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] &gt;= a[i])   q.<span class="hljs-built_in">pop_back</span>();<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - k &gt;= q.<span class="hljs-built_in">front</span>())    q.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">if</span> (i &gt;= k) cout &lt;&lt; a[q.<span class="hljs-built_in">front</span>()] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <br>    q.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[q.<span class="hljs-built_in">back</span>()] &lt;= a[i])   q.<span class="hljs-built_in">pop_back</span>();<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - k &gt;= q.<span class="hljs-built_in">front</span>())    q.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">if</span> (i &gt;= k) cout &lt;&lt; a[q.<span class="hljs-built_in">front</span>()] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 二维单调队列</span><br><span class="hljs-type">int</span> n, m, a, b, res;<br><span class="hljs-type">int</span> g[N * N], mp[N][N], ans[N][N];<br>deque&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-type">int</span> x, y, z;<br>    cin &gt;&gt; g[<span class="hljs-number">0</span>] &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N * N; i++) <br>        g[i] = (g[i - <span class="hljs-number">1</span>] * x + y) % z;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>            mp[i][j] = g[(i - <span class="hljs-number">1</span>) * m + j - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">// 先处理行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        q.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; j - b &gt;= q.<span class="hljs-built_in">front</span>()) <br>                q.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; mp[i][q.<span class="hljs-built_in">back</span>()] &gt;= mp[i][j]) <br>                q.<span class="hljs-built_in">pop_back</span>();<br>            q.<span class="hljs-built_in">push_back</span>(j);<br>            ans[i][j] = mp[i][q.<span class="hljs-built_in">front</span>()];<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-comment">// 再处理列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>        q.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - a &gt;= q.<span class="hljs-built_in">front</span>()) <br>                q.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; ans[q.<span class="hljs-built_in">back</span>()][j] &gt;= ans[i][j]) <br>                q.<span class="hljs-built_in">pop_back</span>();<br>            q.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span> (i &gt;= a &amp;&amp; j &gt;= b)   res += ans[q.<span class="hljs-built_in">front</span>()][j];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="树状数组">树状数组</h2><h3 id="单点修改区间查询">单点修改，区间查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i))  ans += tr[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i))<br>        tr[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<span class="hljs-comment">// 区间查询 (l ~ r)</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="区间修改单点查询">区间修改，单点查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 可以用树状数组维护 原数组的差分数组</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, a[N], c[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i))  ans += c[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) c[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-comment">//树状数组维护差分数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">add</span>(i, a[i] - a[i - <span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> l, r, d;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>, op, &amp;l);<br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;C&#x27;</span>) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;r, &amp;d);<br>            <span class="hljs-built_in">add</span>(l, d), <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -d);<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%intd\n&quot;</span>, <span class="hljs-built_in">sum</span>(l));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="区间修改区间查询">区间修改，区间查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 构造两个树状数组 tr1  tr2</span><br><span class="hljs-comment">// a. tr1 维护原数组的差分数组</span><br><span class="hljs-comment">// b. tr2 维护原数组 下标乘差分</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, a[N];<br><span class="hljs-type">int</span> tr1[N], tr2[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> tr[], <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> tr[], <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i))  ans += tr[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">presum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(tr1, x) * (x + <span class="hljs-number">1</span>) - <span class="hljs-built_in">sum</span>(tr2, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> t = a[i] - a[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">add</span>(tr1, i, t);<br>        <span class="hljs-built_in">add</span>(tr2, i, (<span class="hljs-type">int</span>)i * t);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> l, r, d;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);<br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%intd\n&quot;</span>, <span class="hljs-built_in">presum</span>(r) - <span class="hljs-built_in">presum</span>(l - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;d);<br>            <span class="hljs-built_in">add</span>(tr1, l, d), <span class="hljs-built_in">add</span>(tr1, r + <span class="hljs-number">1</span>, -d);<br>            <span class="hljs-built_in">add</span>(tr2, l, l * d), <span class="hljs-built_in">add</span>(tr2, r + <span class="hljs-number">1</span>, (r + <span class="hljs-number">1</span>) * -d);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="线段树">线段树</h2><h3 id="单点修改">单点修改</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, p, last;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> dat, l, r;<br>&#125; tr[N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    tr[x].dat = <span class="hljs-built_in">max</span>(tr[x &lt;&lt; <span class="hljs-number">1</span>].dat, tr[x &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].dat);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tr[p].l = l, tr[p].r = r;<br>    <span class="hljs-keyword">if</span> (l == r)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[p].dat;<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">-0x3f3f3f3f</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r));<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r));<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l == x &amp;&amp; tr[p].r == x) &#123;<br>        tr[p].dat = v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="区间修改">区间修改</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, w[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">int</span> add;<br>&#125; tr[N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    tr[p].sum = tr[p &lt;&lt; <span class="hljs-number">1</span>].sum + tr[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node &amp;c, node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c.add) &#123;<br>        a.add += c.add;<br>        a.sum += (a.r - a.l + <span class="hljs-number">1</span>) * c.add;<br>        b.add += c.add;<br>        b.sum += (b.r - b.l + <span class="hljs-number">1</span>) * c.add;<br>        c.add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-built_in">pushdown</span>(tr[p], tr[p &lt;&lt; <span class="hljs-number">1</span>], tr[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tr[p].l = l, tr[p].r = r;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        tr[p] = &#123;l, r, w[l], <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r) &#123;<br>        tr[p].sum += (tr[p].r - tr[p].l + <span class="hljs-number">1</span>) * v;<br>        tr[p].add += v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, v);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, v);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[p].sum;<br>    <br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="权值线段树">权值线段树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">110</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-comment">// int e[M], ne[M], h[M], w[M], idx;</span><br><span class="hljs-type">int</span> n, m, op[N], a[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, sum;<br>&#125; tr[N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">getid</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">all</span>(v), x) - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tr[p] = &#123;l, r, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(lson, l, mid);<br>    <span class="hljs-built_in">build</span>(rson, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l == tr[p].r) &#123;<br>        tr[p].sum += v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid)    <span class="hljs-built_in">modify</span>(lson, x, v);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">modify</span>(rson, x, v);<br><br>    tr[p].sum = tr[lson].sum + tr[rson].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt; r)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= tr[p].l &amp;&amp; r &gt;= tr[p].r)   <span class="hljs-keyword">return</span> tr[p].sum;<br><br>    <span class="hljs-type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (r &lt;= mid)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(lson, l, r);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l &gt; mid)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rson, l, r);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(lson, l, mid) + <span class="hljs-built_in">query</span>(rson, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-comment">// 查找第k小</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l == tr[p].r) <span class="hljs-keyword">return</span> tr[p].l;<br><br>    <span class="hljs-type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (tr[lson].sum &gt;= k)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(lson, k);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(rson, k - tr[lson].sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;op[i], &amp;a[i]);<br>        <span class="hljs-keyword">if</span> (op[i] != <span class="hljs-number">4</span>) v.<span class="hljs-built_in">pb</span>(a[i]);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(v));<br>    v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(<span class="hljs-built_in">all</span>(v)), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> tot = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, tot);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">1</span>)         <span class="hljs-comment">// 插入</span><br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">getid</span>(a[i]), <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">2</span>)    <span class="hljs-comment">// 删除 </span><br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">getid</span>(a[i]), <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">3</span>) &#123;  <span class="hljs-comment">// x的排名</span><br>            <span class="hljs-type">int</span> ans = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">getid</span>(a[i]) - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">4</span>) &#123;  <span class="hljs-comment">// 排名为x的数</span><br>            <span class="hljs-type">int</span> idx = <span class="hljs-built_in">kth</span>(<span class="hljs-number">1</span>, a[i]) - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v[idx]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[i] == <span class="hljs-number">5</span>) &#123;  <span class="hljs-comment">// 前驱</span><br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">getid</span>(a[i]) - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v[<span class="hljs-built_in">kth</span>(<span class="hljs-number">1</span>, t) - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;                  <span class="hljs-comment">// 后继</span><br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">getid</span>(a[i]));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v[<span class="hljs-built_in">kth</span>(<span class="hljs-number">1</span>, t + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; tt;</span><br>    <span class="hljs-comment">// init();</span><br>    <span class="hljs-keyword">while</span> (tt--)<br>        <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">一、查询第K小的数：</span><br><span class="hljs-comment">这个可以利用权值线段树存储的是数出现的次数</span><br><span class="hljs-comment">维护区间内数字出现的次数</span><br><span class="hljs-comment">查询左右子树数字出现的次数</span><br><span class="hljs-comment">    如果左儿子数字出现次数和是小于K，代表这个第K小在右子树</span><br><span class="hljs-comment">    但是它在右子树的排名是K减去左子树儿子的个数</span><br><span class="hljs-comment">这样不断往下进行查找，当查找到单点的时候，就是第K小。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">二、查询x数的排名：</span><br><span class="hljs-comment">可以利用权值线段树存储的数字个数的信息</span><br><span class="hljs-comment">查询[1,x-1]区间内部数字出现的个数+1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">三、求x的前驱：</span><br><span class="hljs-comment">我们可以求在[1,x-1]区间内部数字出现的次数记为k</span><br><span class="hljs-comment">那么第k大其实就是前面最靠近x的数，也就是前驱</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">四、求x的后继:</span><br><span class="hljs-comment">我们可以求在[1,x]区间内部数字出现的的次数为k</span><br><span class="hljs-comment">那么第k+1大其实就是后面最靠近x的数，也就是后继。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><br><h2 id="主席树">主席树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, a[N],cnt, root[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, sum;<br>&#125; tr[N * <span class="hljs-number">40</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getid</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">all</span>(v), x) - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> pre, <span class="hljs-type">int</span> &amp;now, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    tr[++cnt] = tr[pre];<br>    now = cnt;<br>    tr[now].sum++;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (pos &lt;= mid)  <span class="hljs-built_in">insert</span>(l, mid, tr[pre].l, tr[now].l, pos);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">insert</span>(mid + <span class="hljs-number">1</span>, r, tr[pre].r, tr[now].r, pos);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> st, <span class="hljs-type">int</span> ed, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmp = tr[tr[ed].l].sum - tr[tr[st].l].sum;<br>    <span class="hljs-keyword">if</span> (k &lt;= tmp)   <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, mid, tr[st].l, tr[ed].l, k);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, r, tr[st].r, tr[ed].r, k - tmp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>        v.<span class="hljs-built_in">pb</span>(a[i]);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(v));<br>    v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(<span class="hljs-built_in">all</span>(v)), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, n, root[i - <span class="hljs-number">1</span>], root[i], <span class="hljs-built_in">getid</span>(a[i]));<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> x, y, k;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;k);<br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, n, root[x - <span class="hljs-number">1</span>], root[y], k);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v[idx - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="st表">ST表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, x, f[N][<span class="hljs-number">100</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        f[i][<span class="hljs-number">0</span>] = x;<br>    &#125; <br><br>    <span class="hljs-type">int</span> tmp = (<span class="hljs-type">int</span>)(<span class="hljs-built_in">log</span>(n) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= tmp; j++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++)<br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>    <br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        <span class="hljs-type">int</span> p = (<span class="hljs-type">int</span>)(<span class="hljs-built_in">log</span>(r - l + <span class="hljs-number">1</span>) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-built_in">max</span>(f[l][p], f[r - (<span class="hljs-number">1</span> &lt;&lt; p) + <span class="hljs-number">1</span>][p]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="树剖">树剖</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[M], idx;<br><span class="hljs-type">int</span> n, m, rt, mod, v[M];<br><span class="hljs-comment">//父节点， 深度， 大小， 重儿子</span><br><span class="hljs-type">int</span> fa[N], dep[N], sz[N], son[N];<br><span class="hljs-comment">// 时间戳计数， 时间戳， 重链头， 权值</span><br><span class="hljs-type">int</span> tim, dfn[N], top[N], w[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-type">int</span> add;<br>&#125; tr[N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    tr[p].sum = (tr[p &lt;&lt; <span class="hljs-number">1</span>].sum + tr[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum) % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node &amp;c, node &amp;a, node &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c.add) &#123;<br>        a.add += c.add;<br>        a.sum += (a.r - a.l + <span class="hljs-number">1</span>) * c.add % mod;<br>        b.add += c.add;<br>        b.sum += (b.r - b.l + <span class="hljs-number">1</span>) * c.add % mod;<br>        c.add = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-built_in">pushdown</span>(tr[p], tr[p &lt;&lt; <span class="hljs-number">1</span>], tr[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    tr[p].l = l, tr[p].r = r;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        tr[p] = &#123;l, r, w[l] % mod, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r) &#123;<br>        tr[p].add += v;<br>        tr[p].sum += (tr[p].r - tr[p].l + <span class="hljs-number">1</span>) * v ;<br>        tr[p].sum %= mod;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r, v);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, v);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<br>        <span class="hljs-keyword">return</span> tr[p].sum % mod;<br>    <br>    <span class="hljs-built_in">pushdown</span>(p);<br>    <span class="hljs-type">int</span> mid = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        sum += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> sum % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> pa)</span> </span>&#123;<br>    fa[u] = pa, dep[u] = dep[pa] + <span class="hljs-number">1</span>;<br>    sz[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mxsz = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == pa)    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(j, u);<br>        sz[u] += sz[j];<br>        <span class="hljs-keyword">if</span> (sz[j] &gt; mxsz)   mxsz = sz[j], son[u] = j;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>    dfn[u] = ++tim, top[u] = t;<br>    w[tim] = v[u];<br>    <span class="hljs-keyword">if</span> (!son[u])    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有重儿子</span><br>    <span class="hljs-built_in">dfs2</span>(son[u], t);        <span class="hljs-comment">// 头结点不变</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == fa[u] || j == son[u])  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(j, j);         <span class="hljs-comment">// 再从轻儿子开始</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将x到y最短路径上的结点加z</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify_chain</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;<br>    z %= mod;<br>    <span class="hljs-keyword">while</span> (top[x] != top[y]) &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[x]] &lt; dep[top[y]])  <span class="hljs-built_in">swap</span>(x, y);<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, dfn[top[x]], dfn[x], z);<br>        x = fa[top[x]];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[x] &gt; dep[y])    <span class="hljs-built_in">swap</span>(x, y);<br>    <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, dfn[x], dfn[y], z);<br>&#125;<br><br><span class="hljs-comment">// 求x到y最短路径上的结点之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_chain</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (top[x] != top[y]) &#123;<br>        <span class="hljs-keyword">if</span> (dep[top[x]] &lt; dep[top[y]])  <span class="hljs-built_in">swap</span>(x, y);<br>        res += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, dfn[top[x]], dfn[x]);<br>        x = fa[top[x]];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[x] &gt; dep[y])    <span class="hljs-built_in">swap</span>(x, y);<br>    res += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, dfn[x], dfn[y]);<br><br>    <span class="hljs-keyword">return</span> res % mod;<br>&#125;<br><br><span class="hljs-comment">// 以x为根节点的子树结点都加上z</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify_son</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> z)</span> </span>&#123;<br>    <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>, z);<br>&#125;<br><br><span class="hljs-comment">// 求以x为根节点的子树节点数值之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_son</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;rt, &amp;mod);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    cin &gt;&gt; v[i];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> ta, tb;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;ta, &amp;tb);<br>        <span class="hljs-built_in">add</span>(ta, tb), <span class="hljs-built_in">add</span>(tb, ta);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs1</span>(rt, rt);<br>    <span class="hljs-built_in">dfs2</span>(rt, rt);<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> op;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;op);<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> x, y, z;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);<br>            <span class="hljs-built_in">modify_chain</span>(x, y, z);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-type">int</span> x, y;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">query_chain</span>(x, y)); <br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-type">int</span> x, z;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;z);<br>            <span class="hljs-built_in">modify_son</span>(x, z);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> x;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">query_son</span>(x));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="莫队">莫队</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e4</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, k, a[N], pos[N], cnt[N];<br><span class="hljs-type">int</span> res, ans[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, id;<br>&#125; q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pos[a.l] == pos[b.l])   <span class="hljs-keyword">return</span> a.r &lt; b.r;<br>    <span class="hljs-keyword">return</span> pos[a.l] &lt; pos[b.l];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    cnt[a[x]]++;<br>    res += cnt[a[x]] * cnt[a[x]] - (cnt[a[x]] - <span class="hljs-number">1</span>) * (cnt[a[x]] - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Sub</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    cnt[a[x]]--;<br>    res -= (cnt[a[x]] + <span class="hljs-number">1</span>) * (cnt[a[x]] + <span class="hljs-number">1</span>) - cnt[a[x]] * cnt[a[x]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-type">int</span> ksz = <span class="hljs-built_in">sqrt</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>        pos[i] = i / ksz;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;q[i].l, &amp;q[i].r);<br>        q[i].id = i;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(q + <span class="hljs-number">1</span>, q + <span class="hljs-number">1</span> + m, cmp);<br><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">while</span> (q[i].l &lt; l)  <span class="hljs-built_in">Add</span>(--l);<br>        <span class="hljs-keyword">while</span> (q[i].r &gt; r)  <span class="hljs-built_in">Add</span>(++r);<br><br>        <span class="hljs-keyword">while</span> (q[i].l &gt; l)  <span class="hljs-built_in">Sub</span>(l++);<br>        <span class="hljs-keyword">while</span> (q[i].r &lt; r)  <span class="hljs-built_in">Sub</span>(r--);<br><br>        ans[q[i].id] = res;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        cout &lt;&lt; ans[i] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="点分治">点分治</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[M], w[M], idx;<br><span class="hljs-type">int</span> n, m, rt, sum, cnt;<br><span class="hljs-type">int</span> tmp[N], sz[N], mxsz[N], q[<span class="hljs-number">200</span>], dis[N];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MX = <span class="hljs-number">1e7</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">bool</span> judge[MX], ans[<span class="hljs-number">200</span>], st[N]; <br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">// 找树的重心</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    sz[u] = <span class="hljs-number">1</span>, mxsz[u] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (st[j] || j == fa)   <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(j, u);<br>        sz[u] += sz[j];<br>        mxsz[u] = <span class="hljs-built_in">max</span>(mxsz[u], sz[j]);<br>    &#125;<br>    mxsz[u] = <span class="hljs-built_in">max</span>(mxsz[u], sum - sz[u]);<br>    <span class="hljs-keyword">if</span> (mxsz[u] &lt; mxsz[rt]) rt = u;<br><br>&#125;<br><br><span class="hljs-comment">// 处理每个点到根节点的距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dis[u] &lt;= MX)   tmp[cnt++] = dis[u];<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (j == fa || st[j])   <span class="hljs-keyword">continue</span>;<br>        dis[j] = dis[u] + w[i];<br>        <span class="hljs-built_in">dfs2</span>(j, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (st[j])  <span class="hljs-keyword">continue</span>;<br>        cnt = <span class="hljs-number">0</span>, dis[j] = w[i];<br>        <span class="hljs-built_in">dfs2</span>(j, u);<br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; cnt; x++)    <span class="hljs-comment">// 遍历距离</span><br>            <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; m; y++)  <span class="hljs-comment">// 遍历询问</span><br>                <span class="hljs-keyword">if</span> (q[y] &gt;= tmp[x]) <br>                    ans[y] |= judge[q[y] - tmp[x]];<br>        <br>        <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; cnt; k++) &#123;<br>            que.<span class="hljs-built_in">push</span>(tmp[k]);<br>            judge[tmp[k]] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 优化清空</span><br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        judge[que.<span class="hljs-built_in">front</span>()] = <span class="hljs-literal">false</span>;<br>        que.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 分治</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    st[u] = judge[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">test</span>(u);<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (st[j])  <span class="hljs-keyword">continue</span>;<br>        rt = <span class="hljs-number">0</span>, mxsz[rt] = sum = sz[j];<br>        <span class="hljs-built_in">dfs1</span>(j, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs1</span>(rt, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">divide</span>(rt);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-type">int</span> a, b, c;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;q[i]);<br>    mxsz[<span class="hljs-number">0</span>] = sum = n;<br>    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);     <span class="hljs-comment">// 找根</span><br>    <span class="hljs-built_in">dfs1</span>(rt, <span class="hljs-number">0</span>);    <span class="hljs-comment">// 确定根以后 更新size</span><br>    <span class="hljs-built_in">divide</span>(rt);<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (ans[i]) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;AYE&quot;</span>);<br>        <span class="hljs-keyword">else</span>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NAY&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="二维数点">二维数点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, cnt, c[<span class="hljs-number">10000010</span>], ans[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> x, y, id, op;<br>&#125; qs[N &lt;&lt; <span class="hljs-number">2</span>];<br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.x &lt; b.x;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>&#125; zz[N];<br><span class="hljs-function">il <span class="hljs-type">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(point a, point b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.x &lt; b.x;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i))  ans += c[i];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) c[i] += y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> x, y;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);<br>        zz[i] = &#123;x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> x1, y1, x2, y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br>        x1++, y1++, x2++, y2++;<br>        qs[++cnt] = &#123;x2, y2, i, <span class="hljs-number">1</span>&#125;;<br>        qs[++cnt] = &#123;x1 - <span class="hljs-number">1</span>, y2, i, <span class="hljs-number">-1</span>&#125;;<br>        qs[++cnt] = &#123;x2, y1 - <span class="hljs-number">1</span>, i, <span class="hljs-number">-1</span>&#125;;<br>        qs[++cnt] = &#123;x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(zz + <span class="hljs-number">1</span>, zz + n + <span class="hljs-number">1</span>, cmp2);<br>    <span class="hljs-built_in">sort</span>(qs + <span class="hljs-number">1</span>, qs + cnt + <span class="hljs-number">1</span>, cmp1);<br><br>    <span class="hljs-type">int</span> now = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<br>        <span class="hljs-keyword">while</span> (now &lt;= n &amp;&amp; zz[now].x &lt;= qs[i].x) &#123;<br>            <span class="hljs-built_in">add</span>(zz[now].y, <span class="hljs-number">1</span>);<br>            now++;<br>        &#125;<br>        ans[qs[i].id] += qs[i].op * <span class="hljs-built_in">sum</span>(qs[i].y);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans[i]);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> ACM-Template </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Template-String</title>
      <link href="/post/61c841f1.html"/>
      <url>/post/61c841f1.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221208200822351.png" alt="image-20221208200822351"></p><p><font size="5" color="#004a97"><strong>字符串</strong></font></p><br><h2 id="kmp">KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, nx[N];<br>string s, t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; s &gt;&gt; t;<br>    n = s.<span class="hljs-built_in">size</span>(), m = t.<span class="hljs-built_in">size</span>();<br>    s = <span class="hljs-string">&quot; &quot;</span> + s, t = <span class="hljs-string">&quot; &quot;</span> + t;<br><br>    nx[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br>        nx[i] = nx[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (nx[i] &amp;&amp; t[i] != t[nx[i] + <span class="hljs-number">1</span>])   <br>            nx[i] = nx[nx[i]];<br>        nx[i] += (t[i] == t[nx[i] + <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &lt;= n;) &#123;<br>        <span class="hljs-keyword">while</span> (j != <span class="hljs-number">1</span> &amp;&amp; s[i] != t[j])<br>            j = nx[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == t[j])   i++, j++;<br>        <span class="hljs-keyword">else</span>    i++;<br>        <br>        <span class="hljs-keyword">if</span> (j == m + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, i - m);<br>            j = nx[m] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, nx[i]);<br>    <br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KMP</span> &#123;<br>    <span class="hljs-type">int</span> nxt[maxn];<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">char</span> t[maxn];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123; len = nxt[<span class="hljs-number">0</span>] = nxt[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-comment">/* 1-bas */</span><br>    <span class="hljs-comment">/* 注意在ss结尾添加‘\0’ */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">char</span>* ss)</span> </span>&#123;<br>        len = <span class="hljs-built_in">strlen</span>(ss + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">memcpy</span>(t, ss, (len + <span class="hljs-number">2</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= len; i++) &#123;<br>            nxt[i] = nxt[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (nxt[i] &amp;&amp; ss[i] != ss[nxt[i] + <span class="hljs-number">1</span>])<br>                nxt[i] = nxt[nxt[i]];<br>            nxt[i] += (ss[i] == ss[nxt[i] + <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 求所有在ss串中的start_pos. 如果first_only设置为true，则只返回第一个位置*/</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-type">char</span>* ss, <span class="hljs-type">bool</span> first_only = <span class="hljs-literal">false</span>)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len_s = <span class="hljs-built_in">strlen</span>(ss + <span class="hljs-number">1</span>);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">start_pos</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &lt;= len_s;) &#123;<br>            <span class="hljs-keyword">while</span> (j != <span class="hljs-number">1</span> &amp;&amp; ss[i] != t[j])<br>                j = nxt[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (ss[i] == t[j])  j++, i++;<br>            <span class="hljs-keyword">else</span>    i++;<br>            <span class="hljs-keyword">if</span> (j == len + <span class="hljs-number">1</span>) &#123;<br>                start_pos.<span class="hljs-built_in">push_back</span>(i - j + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (first_only) <span class="hljs-keyword">return</span> start_pos;<br>                j = nxt[len] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> start_pos;<br>    &#125;<br><br>    <span class="hljs-comment">/* 循环周期 形如 acaca 中 ac 是一个合法周期 */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">periodic</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-type">int</span> now = len;<br>        <span class="hljs-keyword">while</span> (now) &#123;<br>            now = nxt[now];<br>            ret.<span class="hljs-built_in">push_back</span>(len - now);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-comment">/* 循环节 形如 acac 中ac、acac是循环节，aca不是*/</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">periodic_loop</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : <span class="hljs-built_in">periodic</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (len % x == <span class="hljs-number">0</span>)   ret.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min_periodic_loop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">periodic_loop</span>()[<span class="hljs-number">0</span>]; &#125;<br>&#125; kmper;<br><br></code></pre></td></tr></table></figure><br><h2 id="失配树">失配树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 两个前缀的公共border其实就是在失配树上求lca</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>, M = N * <span class="hljs-number">2</span>, maxd = <span class="hljs-number">30</span>;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, nx[N], dep[N], fa[N][maxd + <span class="hljs-number">1</span>];<br>string s;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    dep[u] = dep[p] + <span class="hljs-number">1</span>;<br>    fa[u][<span class="hljs-number">0</span>] = p;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= n; i++)<br>        fa[u][i] = fa[fa[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!dep[j])    <span class="hljs-built_in">dfs</span>(j, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dep[x] &lt; dep[y])    <span class="hljs-built_in">swap</span>(x, y);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxd; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (dep[fa[x][i]] &gt;= dep[y])<br>            x = fa[x][i];<br><br>    <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> x;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxd; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (fa[x][i] != fa[y][i])<br>            x = fa[x][i], y = fa[y][i];<br><br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; s &gt;&gt; m;<br>    n = s.<span class="hljs-built_in">size</span>();   s = <span class="hljs-string">&quot; &quot;</span> + s;<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        nx[i] = nx[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (nx[i] &amp;&amp; s[i] != s[nx[i] + <span class="hljs-number">1</span>])   nx[i] = nx[nx[i]];<br>        nx[i] += (s[i] == s[nx[i] + <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> j = nx[i], u = i;<br>        <span class="hljs-built_in">add</span>(u, j), <span class="hljs-built_in">add</span>(j, u);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> p, q;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;p, &amp;q);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-built_in">lca</span>(p, q);<br><br>        <span class="hljs-comment">// 这里处理一下特判就行</span><br>        <span class="hljs-keyword">if</span> (ans == p || ans == q)   ans = nx[ans];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="manacher">Manacher</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Manacher</span> &#123;<br>    <span class="hljs-type">int</span> lc[MAX];<br>    <span class="hljs-type">char</span> ch[MAX];<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-built_in">Manacher</span>(<span class="hljs-type">char</span>* s) &#123;<br>        <span class="hljs-built_in">init</span>(s);<br>        <span class="hljs-built_in">manacher</span>();<br>    &#125;<br>    <span class="hljs-comment">/* s 1 bas */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br>        ch[n * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        ch[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;@&#x27;</span>;<br>        ch[n * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>            ch[i * <span class="hljs-number">2</span>] = s[i];<br>            ch[i * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        &#125;<br>        N = <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">manacher</span><span class="hljs-params">()</span> </span>&#123;<br>        lc[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++) &#123;<br>            <span class="hljs-type">int</span> p = k + lc[k] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i &lt;= p) &#123;<br>                lc[i] = <span class="hljs-built_in">min</span>(lc[<span class="hljs-number">2</span> * k - i], p - i + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lc[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (ch[i + lc[i]] == ch[i - lc[i]])<br>                lc[i]++;<br>            <span class="hljs-keyword">if</span> (i + lc[i] &gt; k + lc[k])<br>                k = i;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><br><h2 id="hash">hash</h2><p><img src="https://gitee.com/Greedy_firtree/picture/raw/master/blog/image-20221209203619250.png" alt="image-20221209203619250"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">305</span> * <span class="hljs-number">305</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> HASH_CNT = <span class="hljs-number">2</span>; <span class="hljs-comment">/* hash次数 */</span><br>ULL Seed_Pool[] = &#123;<span class="hljs-number">911</span>, <span class="hljs-number">146527</span>, <span class="hljs-number">19260817</span>, <span class="hljs-number">91815541</span>&#125;;<br>ULL Mod_Pool[] = &#123;<span class="hljs-number">29123</span>, <span class="hljs-number">998244353</span>, <span class="hljs-number">1000000009</span>, <span class="hljs-number">4294967291ull</span>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hash</span> &#123;<br>    ULL seed, mod;<br>    ULL base[maxn], sum[maxn];<br>    <span class="hljs-comment">// 构造哈希,从1~n,如果没有输入字符串的长度，需要手动把n设为sz(a)-1</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> seedindex, <span class="hljs-type">int</span> modindex, string a)</span> </span>&#123;<br>        seed = Seed_Pool[seedindex], mod = Mod_Pool[modindex];<br>        base[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            base[i] = base[i - <span class="hljs-number">1</span>] * seed % mod;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            sum[i] = (sum[i - <span class="hljs-number">1</span>] * seed % mod + a[i - <span class="hljs-number">1</span>]) % mod;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 这个不会单独用，是为了给外面的函数得到哈希值用的</span><br>    <span class="hljs-function">ULL <span class="hljs-title">gethash</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (sum[r] - sum[l - <span class="hljs-number">1</span>] * base[r - l + <span class="hljs-number">1</span>] % mod + mod) % mod;<br>    &#125;<br>&#125; hasher[HASH_CNT];<br><span class="hljs-comment">// 得到字符串(l~r)的哈希值(双哈希)</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> pair&lt;ULL, ULL&gt; <span class="hljs-title">hashrange</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(hasher[<span class="hljs-number">0</span>].<span class="hljs-built_in">gethash</span>(l, r), hasher[<span class="hljs-number">1</span>].<span class="hljs-built_in">gethash</span>(l, r));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    string a;<br>    cin &gt;&gt; a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; HASH_CNT; i++) &#123;<br>        hasher[i].<span class="hljs-built_in">init</span>(i, i, a);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">int</span> l1, r1, l2, r2;<br>        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hashrange</span>(l1, r1) == <span class="hljs-built_in">hashrange</span>(l2, r2))<br>            cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="字典树">字典树</h2><h3 id="trie">Trie</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, son[N][<span class="hljs-number">26</span>], cnt[N], nowtmp;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : s) &#123;<br>        <span class="hljs-type">int</span> c = i - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][c]) son[p][c] = ++nowtmp;<br>        p = son[p][c];<br>    &#125;<br>    cnt[p]++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : s) &#123;<br>        <span class="hljs-type">int</span> c = i - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][c]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][c];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>]; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        string s;   cin &gt;&gt; s;<br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>)   <span class="hljs-built_in">insert</span>(s);<br>        <span class="hljs-keyword">else</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">query</span>(s)); <br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="01trie">01Trie</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 区间异或值最大</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, a[N], pre[N];<br><span class="hljs-type">int</span> nowtmp, son[N][<span class="hljs-number">2</span>], tag[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> c = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!son[p][c]) son[p][c] = ++nowtmp;<br>        p = son[p][c];<br>    &#125;<br>    tag[p] = id;<br>&#125;<br><br><span class="hljs-function">il PII <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> c = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>, o = c ^ <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (son[p][o])  p = son[p][o], res |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>        <span class="hljs-keyword">else</span>    p = son[p][c];<br>        <span class="hljs-comment">// 这样更新也是可以的</span><br>        <span class="hljs-comment">// if (son[p][o])  p = son[p][o], res = res &lt;&lt; 1 | 1;</span><br>        <span class="hljs-comment">// else    p = son[p][c], res &lt;&lt;= 1;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;res, tag[p]&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);<br>        pre[i] = pre[i - <span class="hljs-number">1</span>] ^ a[i];<br>    &#125;<br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>, l, r;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        PII tmp = <span class="hljs-built_in">search</span>(pre[i]);<br>        <span class="hljs-keyword">if</span> (ans &lt; tmp.first)<br>            ans = tmp.first, l = tmp.second, r = i;<br>        <span class="hljs-built_in">insert</span>(pre[i], i + <span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="可持久01trie">可持久01Trie</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> root[N], son[N * <span class="hljs-number">30</span>][<span class="hljs-number">2</span>], cnt[N * <span class="hljs-number">30</span>], nowtmp;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>    <span class="hljs-type">int</span> u = ++nowtmp, t = u;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> tmp = ((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>        son[u][<span class="hljs-number">0</span>] = son[pre][<span class="hljs-number">0</span>], son[u][<span class="hljs-number">1</span>] = son[pre][<span class="hljs-number">1</span>];<br>        cnt[u] = cnt[pre] + <span class="hljs-number">1</span>;<br>        son[u][tmp] = ++nowtmp;<br>        u = son[u][tmp], pre = son[pre][tmp];<br>    &#125;<br>    cnt[u] = cnt[pre] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> tmp = !((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (cnt[son[r][tmp]] - cnt[son[l][tmp]] &gt; <span class="hljs-number">0</span>) &#123;<br>            res |= (<span class="hljs-number">1ll</span> &lt;&lt; i);<br>            l = son[l][tmp], r = son[r][tmp];<br>        &#125;<br>        <span class="hljs-keyword">else</span>    l = son[l][!tmp], r = son[r][!tmp];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>    n++;<br>    root[<span class="hljs-number">1</span>] = <span class="hljs-built_in">insert</span>(now, root[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> x;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x);<br>        now ^= x;<br>        root[i] = <span class="hljs-built_in">insert</span>(now, root[i - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> x;  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;x);<br>            now ^= x;<br>            n++;<br>            root[n] = <span class="hljs-built_in">insert</span>(now, root[n - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> l, r, x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;l, &amp;r, &amp;x);<br>            <span class="hljs-type">int</span> tmp = now ^ x;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-built_in">query</span>(tmp, root[l - <span class="hljs-number">1</span>], root[r]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="ac自动机">AC自动机</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, M = N;<br><span class="hljs-type">int</span> e[M], ne[M], h[N], w[M], idx;<br><span class="hljs-type">int</span> n, m, fail[N], son[N][<span class="hljs-number">26</span>], nowtmp;<br><span class="hljs-type">int</span> ed[N], sum[N];<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> idx)</span> </span>&#123;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(), p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-type">int</span> c = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (!son[p][c]) &#123;<br>son[p][c] = ++ nowtmp;<br>&#125;<br>p = son[p][c];<br>&#125;<br>ed[idx] = p;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">get_fail</span><span class="hljs-params">()</span> </span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (son[<span class="hljs-number">0</span>][i]) &#123;<br>fail[son[<span class="hljs-number">0</span>][i]]= <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(son[<span class="hljs-number">0</span>][i]);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (son[u][i]) &#123;<br>fail[son[u][i]] = son[fail[u]][i];<br>q.<span class="hljs-built_in">push</span>(son[u][i]);<br>&#125;<br><span class="hljs-keyword">else</span>son[u][i] = son[fail[u]][i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>        <span class="hljs-built_in">dfs</span>(e[i]);<br>        sum[u] += sum[e[i]];<br>    &#125;<br>&#125;<br><br><span class="hljs-function">il <span class="hljs-type">void</span> <span class="hljs-title">acam</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>(), p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>p = son[p][s[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>++sum[p];<br>&#125;<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nowtmp; i++)<br>        <span class="hljs-built_in">add</span>(fail[i], i);<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br><br>    string s;<br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; s;<br>        <span class="hljs-built_in">insert</span>(s, i);<br>    &#125;<br><br>    <span class="hljs-built_in">get_fail</span>();<br>    cin &gt;&gt; s;<br>    <span class="hljs-built_in">acam</span>(s);<br><br>    <span class="hljs-keyword">for</span> (re <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, sum[ed[i]]);<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM-Template </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
